<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/89" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/89" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="백엔드 기본 사항" href="/post/2024-05-16-BACK-ENDBASICS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="백엔드 기본 사항" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-BACK-ENDBASICS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="백엔드 기본 사항" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">백엔드 기본 사항</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="타임 시리즈에 대해 PySpark와 Databricks를 사용한 피처 엔지니어링" href="/post/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="타임 시리즈에 대해 PySpark와 Databricks를 사용한 피처 엔지니어링" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="타임 시리즈에 대해 PySpark와 Databricks를 사용한 피처 엔지니어링" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">타임 시리즈에 대해 PySpark와 Databricks를 사용한 피처 엔지니어링</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="EKS에서 자체 호스팅 LLM을 배포하는 방법 및 그 이유" href="/post/2024-05-16-HowtoDeployaSelf-HostedLLMonEKSandWhyYouShould"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="EKS에서 자체 호스팅 LLM을 배포하는 방법 및 그 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-HowtoDeployaSelf-HostedLLMonEKSandWhyYouShould_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="EKS에서 자체 호스팅 LLM을 배포하는 방법 및 그 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">EKS에서 자체 호스팅 LLM을 배포하는 방법 및 그 이유</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="게임 개발 시작하기 게임 데이터 저장" href="/post/2024-05-16-BeginningGameDevelopmentSavingGameData"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="게임 개발 시작하기 게임 데이터 저장" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="게임 개발 시작하기 게임 데이터 저장" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">게임 개발 시작하기 게임 데이터 저장</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AI-Powered 웹 개발을 위해 사용해야 할 10가지 도구" href="/post/2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AI-Powered 웹 개발을 위해 사용해야 할 10가지 도구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AI-Powered 웹 개발을 위해 사용해야 할 10가지 도구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">AI-Powered 웹 개발을 위해 사용해야 할 10가지 도구</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="잘했어요" href="/post/2024-05-16-Bravo"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="잘했어요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-Bravo_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="잘했어요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">잘했어요</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년 판타지 앱 개발의 최신 기술 이해하기" href="/post/2024-05-16-UnderstandingtheLatestTechnologiesinFantasyAppDevelopmentfor2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 판타지 앱 개발의 최신 기술 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-UnderstandingtheLatestTechnologiesinFantasyAppDevelopmentfor2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 판타지 앱 개발의 최신 기술 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024년 판타지 앱 개발의 최신 기술 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Native 업그레이드 최신 버전iOS에 대한 포괄적 안내" href="/post/2024-05-16-UpgradingReactNativeAComprehensiveGuidetotheLatestVersioniOS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Native 업그레이드 최신 버전iOS에 대한 포괄적 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-UpgradingReactNativeAComprehensiveGuidetotheLatestVersioniOS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Native 업그레이드 최신 버전iOS에 대한 포괄적 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Native 업그레이드 최신 버전iOS에 대한 포괄적 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터 최신 소식 요약 - Google IO 2024" href="/post/2024-05-16-WhatsnewinFlutterRecapGoogleIO2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터 최신 소식 요약 - Google IO 2024" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-WhatsnewinFlutterRecapGoogleIO2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터 최신 소식 요약 - Google IO 2024" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">플러터 최신 소식 요약 - Google IO 2024</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="45초 안에 이해하는 더미를 위한 빅 오 표기법" href="/post/2024-05-16-BigONotationForDummiesIn45Seconds"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="45초 안에 이해하는 더미를 위한 빅 오 표기법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-BigONotationForDummiesIn45Seconds_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="45초 안에 이해하는 더미를 위한 빅 오 표기법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">45초 안에 이해하는 더미를 위한 빅 오 표기법</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/81">81</a><a class="link" href="/posts/82">82</a><a class="link" href="/posts/83">83</a><a class="link" href="/posts/84">84</a><a class="link" href="/posts/85">85</a><a class="link" href="/posts/86">86</a><a class="link" href="/posts/87">87</a><a class="link" href="/posts/88">88</a><a class="link posts_-active__YVJEi" href="/posts/89">89</a><a class="link" href="/posts/90">90</a><a class="link" href="/posts/91">91</a><a class="link" href="/posts/92">92</a><a class="link" href="/posts/93">93</a><a class="link" href="/posts/94">94</a><a class="link" href="/posts/95">95</a><a class="link" href="/posts/96">96</a><a class="link" href="/posts/97">97</a><a class="link" href="/posts/98">98</a><a class="link" href="/posts/99">99</a><a class="link" href="/posts/100">100</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"백엔드 기본 사항","description":"","date":"2024-05-16 03:46","slug":"2024-05-16-BACK-ENDBASICS","content":"\n\n## Node.js와 PostgreSQL 데이터베이스를 활용한 RESTful API 및 AWS EC2 인스턴스 배포 기본\n\n![Image](/assets/img/2024-05-16-BACK-ENDBASICS_0.png)\n\n이 튜토리얼은 백엔드 개발의 특정 측면에 초점을 맞춥니다: Node.js를 사용하여 PostgreSQL 데이터베이스를 Docker에 호스팅하고 AWS EC2 인스턴스에 배포하는 RESTful API 생성.\n\n이 튜토리얼은 백엔드 개발의 모든 측면을 다루지는 않지만 이러한 구체적인 구성 요소 내에서 범위를 유지할 것입니다.\n\n\n\n# 백엔드\n\n과도하게 단순화해서 말하면, 모든 애플리케이션의 백엔드는 일반적으로 어떤 종류의 데이터 저장 시스템과 상호 작용하는 데이터 처리 작업을 포함합니다.\n\n백엔드는 여러 시스템으로 구성될 수 있습니다. 예를 들어, 마이크로 서비스 아키텍처에서는 수십 개의 API가 있는데, 각각이 특정 프로세스를 처리하여 프론트엔드 애플리케이션에서의 요청을 이행합니다.\n\n# API\n\n\n\nAPI(Application Programming Interface)은 사용자(프로그래머, 소비자 등)와 프로세스, 시스템 또는 도구 사이의 인터페이스를 만들기 위해 설계되었습니다.\n\n예를 들어, 운영 체제(OS, Operating System)의 많은 기능 중 하나는 프로그래머와 하드웨어에서 제공되는 리소스 사이의 인터페이스 역할을 하는 것입니다. OS는 각 CPU에서의 프로세스 실행 할당 작업을 추상화하여 프로그래머가 프로그램을 실행할 때마다 각각 구현할 필요가 없도록 합니다.\n\n따라서, API는 입력 값을 받아 이러한 값들을 처리하고 결과를 반환합니다. 이 결과는 API의 인터페이스에서 지정된 성공적인 실행을 나타내는 확인 메시지 또는 다른 출력일 수 있습니다.\n\n\n\n# HTTP/HTTPS\n\nHTTP (Hypertext Transfer Protocol)은 월드 와이드 웹(WWW)에서 클라이언트와 서버 간 메시지 교환을 위한 인터페이스로 작동합니다.\n\n시간이 지나면서 이 프로토콜은 적용 범위를 확대하며 인터넷 상의 클라이언트-서버 응용 프로그램 중 가장 널리 사용되는 프로토콜 중 하나가 되었습니다.\n\nHTTP는 세 가지 주요 구성 요소인 메서드, 헤더 및 상태 코드의 구조를 기반으로 합니다.\n\n\n\n메소드는 요청에서 실행할 수 있는 작은 일련의 작업입니다. 주로 사용되는 메소드에는 GET, POST, PUT 및 DELETE가 포함됩니다.\n\n![이미지](/assets/img/2024-05-16-BACK-ENDBASICS_2.png)\n\n이전에 설명한대로 HTTP는 어떤 종류의 애플리케이션에도 적용 가능하다는 특성을 갖고 있어 웹 페이지에 대한 작업이 추상화되고, 앞에서 언급한 메소드는 일반적으로 유사한 작업을 수행하기 위해 사용됩니다. 자세한 정보는 아래 표를 참조해주세요.\n\n헤더는 HTTP 요청에 추가 정보를 제공합니다. 표준 헤더에는 Content-Type: application/json과 같이 요청 본문에 보내는 객체가 JSON임을 지정하는 예와, 일반적으로 애플리케이션 수준에서 인증에 사용되는 Authorization Header와 같은 예가 있습니다.\n\n\n\n마침내 HTTP 통신에서 응답을 표준화하는 데 사용되는 상태 코드입니다.\n\n![이미지](/assets/img/2024-05-16-BACK-ENDBASICS_3.png)\n\n이들은 응답의 성격을 나타내는 카테고리로 그룹화됩니다. 예를 들어, 403 상태 코드는 'Forbidden(금지됨)'을 의미하며, 일반적으로 클라이언트가 제공한 권한이 서버에서 유효하지 않다고 판단될 때 사용됩니다. 상태 코드의 각 카테고리는 요청 처리에 대한 통찰력을 제공하며, 일반적으로 서버 측에서 디버깅과 응용프로그램 관리에 도움이 됩니다.\n\n# RESTful\n\n\n\nRESTful (Representational State Transfer)은 인터넷을 위한 아키텍처 스타일입니다. 이 스타일은 HTTP 프로토콜을 사용하고, 균일한 인터페이스, 클라이언트-서버, 상태를 저장하지 않음, 캐시 가능, 계층화된 시스템 다섯 가지 원칙을 따릅니다.\n\n- 명확히 정의된 인터페이스가 필수입니다.\n- 서버와 클라이언트는 독립적입니다.\n- 통신에 필요한 모든 정보는 요청 안에 포함되어 있습니다.\n- 캐싱이 필요한 경우 명시적으로 명시되어야 합니다.\n- 통신에 관여하는 구성 요소는 전체 시스템을 인식할 필요가 없습니다.\n\n자세한 설명은 제공된 참고 자료와 아래 비디오를 참조하십시오.\n\n# 구현\n\n\n\n친절한 톤으로 번역해드리겠습니다.\n\n보다 실용적인 관점을 제공하기 위해 RESTful API를 구현하고 사용 및 배포하는 방법을 보여드리겠습니다.\n\n이 구현에는 PostgreSQL 데이터베이스를 Docker에서 실행하고 Node.js를 사용하여 해당 데이터베이스에서 CRUD(Create, Retrieve, Update, Delete) 작업을 수행하는 것이 포함됩니다.\n\n튜토리얼을 더 잘 따를 수 있도록, 이미 구현된 예제 애플리케이션을 사용할 것이며 해당 예제는 GitHub 리포지토리에서 사용 가능합니다.\n\n먼저, 다음 애플리케이션을 다운로드해야 합니다:\n\n\n\n- 서버용으로 Node.js\n- HTTP 요청을 만들기 위해 Postman\n- PostgreSQL 데이터베이스를 실행하기 위해 Docker\n- 데이터베이스에서 SQL 쿼리를 실행하기 위해 DBeaver\n\n# DOCKER\n\n우선, PostgreSQL 데이터베이스를 만들어야 합니다. 이를 위해 아래 명령을 실행하는 Docker를 사용할 것입니다.\n\n```js\nsudo docker run --name postgresdb -p 5432:5432 -e POSTGRES_PASSWORD=postgres -e POSTGRES_USER=postgres -e POSTGRES_DB=postgres -d postgres\n```\n\n\n\n이 작업이 어떤 역할을 하는지 더 잘 이해하려면 Docker Hub의 이 문서를 읽어보세요.\n\n# 데이터베이스 테이블\n\n이제 DBeaver를 열고 Docker run 명령어에 사용한 자격 증명을 입력하여 생성한 PostgreSQL 데이터베이스에 액세스하세요.\n\n연결에 필요한 데이터에 주의를 기울이세요. 암호를 포함한 필수 정보는 Docker run 명령어에 명시되어 있습니다.\n\n\n\n마지막으로, GitHub 저장소에서 찾을 수 있는 SQL 스크립트를 실행해주세요. 이 스크립트는 애플리케이션에서 사용자를 기본 저장하는 데 사용됩니다.\n\n이제 테이블과 데이터베이스가 설정되었으니, 다음 단계는 데이터베이스를 서버에 연결하고 해당 데이터베이스에 쿼리를 시작하는 것입니다.\n\n# 서버\n\n시작하기 전에 이 API가 무엇을 추상화할지 명확하게 알아봅시다.\n\n\n\n데이터베이스 관련 작업에서는 SQL 문을 사용하여 행을 생성, 검색, 업데이트 및 삭제합니다.\n\n이를 기억하면, 이 서버에서 할 일은 이 SQL 명령어의 입력 부분을 채울 값들을 간단히 수락하는 것입니다. \n\n예를 들어 사용자를 생성할 때, 이름, 이메일 및 비밀번호를 문자열로 삽입 문에 채워야 새로운 행을 만들 수 있습니다. 이제 API를 통해 사용자 입력을 받고 이러한 문자열을 채울 수 있습니다.\n\n우리가 추상화하는 내용을 이해했으니, 계속하기 위해 저장소를 복제해야 합니다.\n\n\n\n저장소를 복제한 후, 필요한 Node.js 패키지를 설치하고 다음 명령을 실행하여 서버를 시작하세요.\n\n```js\nnpm i\nnpm start\n```\n\n이제 서버가 http://localhost:3000/ 에서 실행 중입니다. 그러나 서버를 사용하기 전에 이 문서의 DOCUMENTATION 섹션을 완료하는 것을 제안합니다.\n\n이제 한 걸음 물러나서 RESTful API를 생성하는 데 필요한 것들을 다시 살펴보겠습니다.\n\n\n\n인터페이스를 각 메소드마다 정의해야 하며, 사용할 메소드를 지정하고 각 메소드가 무엇을 추상화할지 결정해야 합니다. 이를 위해 이 구조를 반영하도록 설계된 디렉터리 트리를 생성했습니다.\n\n```js\nbackend-basics/\n├── dml.sql\n├── package.json\n├── package-lock.json\n├── README.md\n├── server.js\n└── src\n    ├── controllers\n    │   └── users.js\n    ├── helpers\n    │   └── pg.js\n    ├── queries\n    │   └── users.js\n    └── routes\n        └── routes.js\n```\n\nsrc 폴더 아래에는 API를 RESTful하게 만드는 데 필요한 모든 요소가 포함되어 있습니다.\n\n다음 섹션에 나오는 코드는 GitHub 저장소에서 추출된 것으로 모두를 포함하고 있지 않습니다. 설명을 위해 일부 조각으로 제공됩니다.\n\n\n\n## 매개변수\n\nRESTful API의 가장 중요한 측면은 사용자가 서버 쪽으로 보내는 정보입니다. 일반적으로 세 가지 유형의 매개변수 전달 방법이 적용됩니다: 경로, 쿼리 및 본문.\n\n- **경로**: 매개변수가 URL에 직접 포함됩니다. 예: http://localhost:3000/api/users/Guilherme Huther.\n- **쿼리**: 매개변수는 URL에서 매개변수 이름을 사용하여 지정됩니다. 예: http://localhost:3000/api/users?id_users=d290f1ee-65c54-4b01-90e6-d701748f0851.\n- **본문**: 본문은 요청에서 페이로드 부분에 전송됩니다. 이는 JSON부터 HTML까지 다양한 유형의 콘텐츠일 수 있으며, 일반적으로 클라이언트가 보내는 Content-Type 헤더와 관련하여 데이터 유형을 명시합니다.\n\n## 컨트롤러\n\n\n\n컨트롤러에는 HTTP 프로토콜의 인터페이스, 상태 코드 및 *헤더가 포함되어 있습니다.\n\n필요한 작업을 효과적으로 실행하기 위해 쿼리 및 도우미가 필요합니다.\n\n```js\n// backend-basics/src/controllers/users.js\n\nconst pool = require(\"../helpers/pg\");\n\nconst {\n  sql_get_all_users,\n  sql_get_users,\n} = require(\"../queries/users\");\n\nconst get_users = async (req, res) =\u003e {\n  const id_users = req.query.id_users;\n\n  if (id_users) {\n    pool.query(sql_get_users, [id_users], (err, response) =\u003e {\n      if (err) {\n        res.status(500).send(\"사용자 가져오는 중 오류 발생: \" + err.message);\n\n        return;\n      }\n      res.status(200).send(response.rows);\n\n      return;\n    });\n\n    return;\n  } else {\n    pool.query(sql_get_all_users, (err, response) =\u003e {\n      if (err) {\n        res.status(500).send(\"사용자 가져오는 중 오류 발생: \" + err.message);\n\n        return;\n      }\n      res.status(200).send(response.rows);\n\n      return;\n    });\n    return;\n  }\n};\n```\n\n이 코드에서는 사용자 입력 매개변수를 처리하고 이러한 매개변수를 사용하여 데이터베이스에서 쿼리를 실행한 후 클라이언트에 응답을 제공합니다. 작업이 실패하면 오류가 발생하고 성공하면 쿼리된 데이터가 반환됩니다.\n\n\n\n*헤더: 컨트롤러에서 헤더를 관리할 수 있지만, 이 상황에서는 주로 Express Node.js 패키지를 통해 그들의 사용이 용이해집니다.\n\n## 쿼리 및 헬퍼\n\n이 두 구성 요소에는 API를 통해 중재될 프로세스가 포함되어 있습니다. 이 경우에는 PostgreSQL 데이터베이스에서 CRUD 작업이 포함됩니다.\n\n쿼리는 저장 시스템에서 실행될 SQL 문입니다. 마지막으로, 헬퍼는 Node.js에서 PostgreSQL과 함께 SQL을 실행하는 데 필요한 연결을 관리합니다.\n\n\n\n```js\n// backend-basics/src/helpers/pg.js\n\nconst Pool = require(\"pg\").Pool;\n\nconst pool = new Pool({\n  user: \"postgres\",\n  host: \"localhost\",\n  database: \"postgres\",\n  password: \"postgres\",\n  port: 5432,\n});\n\nmodule.exports = pool;\n```\n\n쿼리를 실행하는 데 필요한 PostgreSQL 데이터베이스 연결입니다.\n\n```js\n// backend-basics/src/queries/users.js\n\nconst sql_get_all_users = `\nSELECT \n    * \nFROM \n    users;\n`;\n\nconst sql_get_users = `\nSELECT \n    * \nFROM \n    users \nWHERE\n    id_users = $1;\n`;\n```\n\n컨트롤러에서 사용되는 쿼리는 사용자의 입력에 따라 달라집니다.\n\n\n\n## 경로\n\n여기서 각 컨트롤러에 대한 HTTP 메소드가 설정되어 있습니다. GET, POST, PUT, DELETE 메소드는 수행 중인 작업의 유형을 나타냅니다.\n\n예를 들어, 이 API에서 POST 엔드포인트는 CRUD에서 \"만들기\" 작업에 해당하며, 데이터베이스에서 새 인스턴스를 만듭니다.\n\n```js\n// backend-basics/src/routes/routes.js\n\nconst express = require(\"express\");\nconst router = express.Router();\n\nconst {\n    get_users,\n    create_users,\n    update_users,\n    delete_users,\n} = require(\"../controllers/users.js\");\n\nrouter.get(\"/users\", get_users);\nrouter.post(\"/users\", create_users);\nrouter.put(\"/users\", update_users);\nrouter.delete(\"/users\", delete_users);\n\nmodule.exports = router;\n```\n\n\n\n라우트는 컨트롤러 프로세스를 활용하여 각 메소드가 무엇을 수행할지와 사용 가능한 메소드를 지정합니다.\n\n## 서버의 다음 단계\n\n보안, 확장성 및 효율성을 강화하기 위해 미들웨어, 웹 소켓 및 기타 기능을 추가할 수도 있습니다.\n\n# 사용법\n\n\n\n이제 API를 테스트하고 상호 작용하기 위해 Postman을 사용할 것입니다.\n\n이 도구를 사용하면 사용자가 HTTP 요청을 만들고 요청의 모든 구성 요소를 사용자 정의할 수 있습니다. 요청에 헤더를 설정하거나 메서드를 변경하거나 요청을위한 URL을 지정하고 본문에 데이터를 보낼 수 있습니다.\n\n기본 사용법을 보여주는 이미지와 API를 테스트하는 방법에 대한 설명서가 여기 있습니다.\n\n# 문서화\n\n\n\n문서 작성은 개발의 중요한 부분입니다. 당신이 무엇을 하는지 이해하는 데 도움이 되며, 무엇보다도 프로젝트의 다른 사람들이 당신의 작업을 이해할 수 있게 해줍니다.\n\n이것은 매우 중요한데, 종종 다른 팀원들이 당신의 기여에 대해 명확한 이해를 가지고 있지 않을 수 있기 때문입니다. 그러므로 철저한 문서 작성이 당신이 성취한 것을 설명하는 가장 좋은 방법입니다.\n\n이 API에는 문서가 포함되어 있으며 다음 URL을 통해 액세스할 수 있습니다:\n\n```js\nhttp://localhost:3000/docs\n```\n\n\n\n# AWS 배포\n\n이 섹션에서는 AWS EC2 인스턴스에 애플리케이션을 배포하는 방법을 안내하겠습니다.\n\n먼저, AWS에서 계정을 생성하고 제공되는 서비스를 사용하기 위해 신용카드 정보를 입력해야 합니다. 비록 무료 티어에 속해있더라도 서비스를 이용하려면 이 작업을 해주셔야 합니다.\n\n다음은 수행해야 할 단계들입니다:\n\n\n\n- EC2 인스턴스 생성;\n- GitHub 저장소 복제;\n- 데이터베이스 설정;\n- 서버 설정.\n\n## EC2 인스턴스 생성\n\n![이미지](\"/assets/img/2024-05-16-BACK-ENDBASICS_4.png\")\n\n![이미지](\"/assets/img/2024-05-16-BACK-ENDBASICS_5.png\")\n\n\n\n\n![Image 6](/assets/img/2024-05-16-BACK-ENDBASICS_6.png)\n![Image 7](/assets/img/2024-05-16-BACK-ENDBASICS_7.png)\n![Image 8](/assets/img/2024-05-16-BACK-ENDBASICS_8.png)\n![Image 9](/assets/img/2024-05-16-BACK-ENDBASICS_9.png)\n  \n\n\n\n\u003cimg src=\"/assets/img/2024-05-16-BACK-ENDBASICS_10.png\" /\u003e\n\n## 깃허브 저장소 복제하기\n\n이제 EC2 인스턴스 내에서 GitHub 계정에 새 SSH 키를 등록하여 머신에 저장소를 복제할 수 있습니다.\n\nWindows - PowerShell(관리자 권한으로 실행해야 함)\n\n\n\n```js\nssh-keygen -t ed25519 -C \"\u003cYOUR_GITHUB_EMAIL\u003e\"\n\ncat \u003cPUBLIC_KEY_PATH\u003e\n# 출력을 복사하고 다음 링크에서 새 SSH 키를 만드세요:\n# https://github.com/settings/keys\n\nGet-Service -Name ssh-agent | Set-Service -Startup Manual\nStart-Service ssh-agent\nssh-add \u003cPRIVATE_KEY_PATH\u003e\ngit clone \u003cSSH_GITHUB_CLONE_CODE\u003e\n```\n\nLinux - Bash\n\n```js\nssh-keygen -t ed25519 -C \"\u003cYOUR_GITHUB_EMAIL\u003e\"\n\ncat \u003cPUBLIC_KEY_PATH\u003e\n# 출력을 복사하고 다음 링크에서 새 SSH 키를 만드세요:\n# https://github.com/settings/keys\n```\n\n일반적으로 키는 .ssh 디렉토리에 위치합니다. 설정이 완료되면 `git clone REPOSITORY_SSH_URL` 명령어를 사용하여 리포지토리를 복제할 수 있습니다. \n\n\n\n\n## 데이터베이스 설정\n\n이제 다음 명령을 실행하여 데이터베이스용 Docker를 다운로드해야 합니다.\n\n```js\nsudo apt update\nsudo apt upgrade\n\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release \u0026\u0026 echo \"$VERSION_CODENAME\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null\n\nsudo apt-get update\n\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n```\n\n다음으로 다음 Docker 명령을 실행하여 PostgreSQL 데이터베이스를 생성하세요:\n\n\n\n```js\nsudo docker run --name postgresdb -p 5432:5432 -e POSTGRES_PASSWORD=postgres -e POSTGRES_USER=postgres -e POSTGRES_DB=postgres -d postgres\n```\n\n마지막으로 데이터베이스 테이블을 만들려면 설정한 도커 컨테이너 안에서 dml.sql 스크립트를 실행하세요:\n\n```js\ncat /home/ubuntu/backend-basics/dml.sql | sudo docker exec -i postgresdb psql -U postgres -d postgres\n```\n\n이제 새로 만든 테이블이 포함된 데이터베이스가 작동 중입니다.\n\n\n\n## 서버 설정\n\n마침내, 서버를 실행할 수 있도록 Node.js와 npm을 다운로드해야 합니다.\n\n```js\nsudo apt update\n\nsudo apt install npm\nsudo apt-get install nodejs\n```\n\n다운로드를 완료한 후, 해당 디렉토리에 액세스하여 서버를 시작하고 필요한 패키지를 다운로드한 다음, 서버를 인스턴스화하는 명령을 실행해야 합니다.\n\n\n\n```js\ncd /home/ubuntu/backend-basics\n\nnpm i\n\nnpm i pm2\n\npm2 start server.js --watch  # 서버를 문제없이 실행하기 위해 시작합니다 \n#\n# 혹은 npm start\n#\n# pm2 stop server.js         # 서버를 중지하는 명령어\n# pm2 logs                   # 서버 로그를 확인하는 명령어\n```\n\nAWS EC2 인스턴스에서 실행 중인 서버에 액세스하려면 인스턴스의 공용 IPv4 주소를 사용하세요. API 요청에서 로컬 주소를 인스턴스의 공용 IPv4로 교체하세요.\n\n사용 방법 섹션에 있는 http://localhost:3000을 http://`EC2_PUBLIC_IPV4`:3000으로 변경하세요.\n\n## AWS 배포의 다음 단계\n\n\n\n\n이제 서버가 배포되었으니, HTTPS 연결 설정, 로드 밸런서 구현, 복제 구성 등 잠재적인 문제에 대해 대응해야 합니다. 이러한 도전에 대해 사전에 대비하고 시스템의 보안 및 성능을 계속 향상시키세요.\n\n링크드인과 깃허브에서 저를 팔로우하세요.\n\n# 참고 자료\n\n- Tanenbaum, A.S. and Wetherall, D.J. (2011) Computer Networks. 5th Edition, Prentice Hall, Inc., 미국.\n- Andrew S. Tanenbaum and Herbert Bos. 2014. Modern Operating Systems (4th. ed.). Prentice Hall Press, 미국.\n- https://github.com/guilhermehuther/backend-basics\n- https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n- https://developer.mozilla.org/en-US/docs/Web/HTTP\n- https://www.ibm.com/topics/rest-apis\n- https://aws.amazon.com/what-is/restful-api/\n- https://restfulapi.net\n- https://www.postgresql.org/docs/current/\n- https://nodejs.org/docs/latest/api\n- https://docs.docker.com","ogImage":{"url":"/assets/img/2024-05-16-BACK-ENDBASICS_0.png"},"coverImage":"/assets/img/2024-05-16-BACK-ENDBASICS_0.png","tag":["Tech"],"readingTime":12},{"title":"타임 시리즈에 대해 PySpark와 Databricks를 사용한 피처 엔지니어링","description":"","date":"2024-05-16 03:43","slug":"2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks","content":"\n\n대규모 데이터 세트에서 고속 쿼리 및 분석에 대한 수요가 증가함에 따라 Apache Spark는 최근 몇 년간 가장 인기 있는 분석 엔진 중 하나로 돌아서고 있습니다. 그것은 분산 데이터 처리에서 강력한데, 마스터-워커 아키텍처 때문에 그렇습니다. 이에는 클러스터 매니저(마스터)와 협력하고 작은 작업을 워커 노드로 분배하는 실행을 제어하는 드라이버 프로그램이 포함되어 있습니다. 게다가, 내부 메모리 데이터 처리 엔진으로 설계된 Spark는 데이터를 저장하고 조작할 때 주로 RAM을 사용하여 디스크 저장소에 의존하는 것 대신 데이터를 더 빨리 처리할 수 있게 도와줍니다.\n\n![이미지](/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_0.png)\n\n## Apache Spark: 낮은 수준에서 높은 수준까지\n\n낮은 수준에서는 그 아키텍처가 두 가지 주요 추상화를 기반으로 설계되어 있습니다.\n\n\n\n- Resilient Distributed Dataset (RDD) - 각 데이터 세트를 논리적 부분으로 분할하고 클러스터 작업자 노드에서 실행하여 병렬 프로그래밍을 지원하는 저수준 데이터 추상화입니다.\n- Directed Acyclic Graph (DAG) - 작업의 종속성과 순서를 최적화하고 예약하는 표현을 의미합니다.\n\n더 높은 수준에서는 Scala, Python 또는 R과 같은 언어를 사용하여 다양한 고수준 도구를 활용할 수 있습니다. 도구 예시로는 SQL 및 데이터프레임 용 Spark SQL, Pandas 작업을 위한 Spark Pandas API, 스트림 처리를 위한 구조적 스트리밍 등이 있습니다.\n\n하지만 이러한 기능을 즐기기 전에는 인프라 설정 및 다양한 복잡한 도구들을 통해 Spark 클러스터를 자체 관리해야 할 수 있으며, 이는 머리를 아프게 만들 수 있습니다.\n\n## Databricks에서 PySpark\n\n\n\n이러한 도전에 대응하기 위해 Databricks에서 PySpark를 최근 산업의 고수준 솔루션 중 하나로 소개하고 있습니다. PySpark는 Spark용 Python API이며, Databricks는 Spark를 기반으로 한 완전한 소프트웨어 플랫폼입니다. 노트북, 인프라 오케스트레이션(자동 프로비저닝 및 스케일링), 프로세스 오케스트레이션(작업 제출 및 예약), 관리 클러스터 및 소스 제어까지 모두 포함하고 있습니다.\n\nDatabricks에서 PySpark API를 사용하여 시계열 데이터에 대한 특성 엔지니어링 프로젝트를 시연하고 수행할 것입니다. 이 실습 여정에서는 Pandas 라이브러리가 일반적으로 데이터 처리에 사용되는 방식을 시뮬레이션하되, 확장성과 병렬성의 추가 혜택을 누릴 수 있습니다.\n\n아래와 같은 시나리오를 고려해 보세요. 2006년 12월부터 2010년 11월까지 1분 간격으로 샘플링된 가정용 전기 사용 데이터가 있습니다. 저희의 목표는 데이터를 수집하고 조작하며 특성을 추출하고 시각화를 생성하는 것입니다.\n\n![Link text](/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_1.png)\n\n\n\n데이터셋 [라이센스: 데이터베이스 오픈 데이터베이스, 콘텐츠: 데이터베이스 콘텐츠]은 Kaggle에서 얻은 것으로서 날짜, 시간, 글로벌 전력 (유효 및 무효), 전압, 글로벌 강도 및 서브미터링 (1, 2 및 3)과 같은 다양한 필드가 포함되어 있습니다. 이제 분석을 시작할 수 있습니다.\n\n## 초기 설정\n\n시작하려면 Databricks Community Edition을 위한 사용자 계정을 만들어야 합니다. 이것은 우리의 개념 증명을 위한 적합한 Databricks 환경을 제공합니다. 그 다음으로 입력 데이터 파일을 FileStore로 업로드해야 합니다. FileStore는 Databricks 전용 경로입니다. \"노트북에 테이블 생성\"을 클릭하면 데이터 수집을 시작하는 코드 템플릿이 제공됩니다.\n\n![이미지](/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_2.png)\n\n\n\n\n![이미지](/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_3.png)\n\n## 피처 엔지니어링 프로젝트 생성\n\n### 1. 데이터 가져오기\n\n- 정적 데이터\n\n\n\n\n우리는 데이터 소스를 읽고 DataFrame, 즉 관계형 테이블을 반환하는 spark.read() 메서드를 사용합니다. CSV, JSON, Parquet 등 다양한 데이터 소스를 지원합니다. 이 경우에는 첫 번째 행이 헤더 역할을 하고 \";\"를 구분자로 사용하는 정의된 스키마로 CSV 형식의 전력 소비 데이터를 읽습니다.\n\n```js\n# 파일 위치 및 유형\nfile_location = \"/FileStore/tables/household_power_consumption.csv\"\nfile_type = \"csv\"\n\n# CSV 옵션\nschema = \"Date STRING, Time STRING, Global_active_power DOUBLE, Global_reactive_power DOUBLE, Voltage DOUBLE, Global_intensity DOUBLE, Sub_metering_1 DOUBLE, Sub_metering_2 DOUBLE, Sub_metering_3 DOUBLE\"\nfirst_row_as_header = \"true\"\ndelimiter = \";\"\n\n# CSV 파일 읽기\norg_df = spark.read.format(file_type) \\\n.schema(schema) \\\n.option(\"header\", first_row_as_header) \\\n.option(\"delimiter\", delimiter) \\\n.load(file_location)\n\ndisplay(org_df)\n```\n\nDataFrame의 몇 가지 첫 행 출력:\n\n\u003cimg src=\"/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_4.png\" /\u003e\n\n\n\n- 데이터 스트리밍\n\n데이터가 지속적으로 생성되는 시나리오에서는 스트림 처리 기술을 사용하여 데이터를 점진적으로 읽습니다. Spark의 동작을 보여주기 위해 원본 데이터 세트를 10개의 하위 집합으로 분할하고 미리 \"/FileStore/tables/stream/\" 경로에 저장했습니다. 그리고 나서 다른 메서드인 spark.readStream()을 사용하여 데이터를 스트리밍합니다.\n\n```js\nsourceStream=spark.readStream.format(\"csv\") \\\n.option(\"header\",True) \\\n.schema(schema) \\\n.option(\"mode\",\"dropMalformed\") \\\n.option(\"maxFilesPerTrigger\",1) \\\n.option(\"ignoreLeadingWhiteSpace\",True) \\\n.load(\"dbfs:/FileStore/tables/stream\") \\\n```\n\n\"dropMalformed\"로 설정된 모드 설정은 손상된 레코드를 방지하기 때문에 구조적 불일치로 인한 손상이든 다른 사용할 수 없는 요소로 인한 손상이든 상관없이 해당 레코드를 폐기합니다. 또한 트리거 이벤트 당 하나의 파일만 처리하도록 선택했습니다.\n\n\n\n데이터를 수신하고 10초마다 레코드 수를 확인하여 스트리밍 데이터가 계속 도착하는 것을 관찰할 수 있습니다.\n\n```js\nimport time\n\n# DataFrame 내용을 스트리밍\nquery = sourceStream.writeStream \\\n.queryName(\"count\") \\\n.format(\"memory\") \\\n.outputMode(\"append\") \\\n.start()\n\n# 행 수를 표시\nfor _ in range(10):\n  spark.sql(\"SELECT COUNT(*) AS no_of_rows FROM count\").show()\n  time.sleep(10)\n```\n\n#2 데이터 조작 및 탐색\n\n- 데이터 변환\n\n\n\n결측값이 포함된 행의 수가 상대적으로 미비하기 때문에 해당 행을 삭제하는 것으로 결정했습니다. 게다가 시간 관련 특성을 추출하여 나중에 더 높은 차원에서 패턴을 관찰할 수 있을 것으로 기대됩니다.\n\n```python\nfrom pyspark.sql.functions import col, concat_ws, to_date\n\n# 결측값이 포함된 행 삭제\ndf = org_df.na.drop()\n\n# \"Date\"와 \"Time\" 열을 새로운 \"DateTime\" 열로 변환\ndf = df.withColumn(\"Date\", to_date(col(\"Date\"),\"d/M/y\"))\ndf = df.withColumn(\"Date\", df[\"Date\"].cast(\"date\"))\ndf = df.select(concat_ws(\" \", to_date(col(\"Date\"),\"d/M/y\"), col(\"Time\")).alias(\"DateTime\"), \"*\")\ndf = df.withColumn(\"DateTime\", df[\"DateTime\"].cast(\"timestamp\"))\n\n# 시간 관련 특성 추가\ndf = df.withColumn(\"year\", year(\"DateTime\"))\ndf = df.withColumn(\"month\", month(\"DateTime\"))\ndf = df.withColumn(\"week_num\", weekofyear(\"DateTime\"))\ndf = df.withColumn(\"hour\", hour(\"DateTime\"))\n```\n\n- 데이터 탐색\n\n다양한 PySpark 기본 메서드로 데이터를 탐색할 수 있습니다.\n\n\n\n(1) 선택하기\n\n\"select\" 메소드를 사용하면 데이터 프레임에서 열 단위로 하위 집합을 만들 수 있습니다. 이 예시에서는 글로벌 액티브 전력의 내림차순으로 열을 선택합니다.\n\n```js\ndf.select(\"DateTime\", \"Global_active_power\", \"Global_intensity\").sort(\"Global_active_power\", ascending=False).show(5)\n```\n\n\u003cimg src=\"/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_5.png\" /\u003e\n\n\n\n(2) 필터\n\n이 필터는 열 값에 따라 데이터 포인트를 필터링합니다. 이 예에서는 \"year\"와 \"Global_intensity\" 열 두 개에 대해 필터링합니다.\n\n```js\ndf.filter(\n    (col(\"year\") == 2009) \u0026\n    (col(\"Global_intensity\") \u003e 40)\n).count()\n\n# 출력: 10\n```\n\n(3) 그룹화\n\n\n\n우리는 집계 작업도 수행할 수 있어요. 데이터셋에서 다양한 월에 대한 전역 활성 전력 및 서브 미터링의 평균을 계산해 봅시다.\n\n```js\ndf.groupby(\"month\").agg(\n     round(mean(\"Global_active_power\"), 2).alias(\"평균_전역_활성_전력\"),\n     round(mean(\"Sub_metering_1\"), 2).alias(\"평균_서브_미터링_1\"),\n     round(mean(\"Sub_metering_2\"), 2).alias(\"평균_서브_미터링_2\"),\n     round(mean(\"Sub_metering_3\"), 2).alias(\"평균_서브_미터링_3\"),\n).sort([\"month\"]).show(5)\n```\n\n![그림](/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_6.png)\n\n#3 창 함수를 사용하여 특성 추출\n\n\n\n위의 기본 PySpark 메소드와 함수에 추가로 Window 함수를 활용하여 시고열 데이터에서 시간적 종속성과 관계를 캡처할 추가적인 피처를 생성할 수 있습니다. 하루 단위로 집계된 전체 글로벌 활성 전력이 변환된 데이터 세트(\"df2\")를 가정해 봅시다. 이러한 피처들을 어떻게 얻을 수 있는지 알아보겠습니다.\n\n(1) Lag features\n\n이는 이전 날짜의 지표 값들을 나타내며, 모델이 과거 데이터로부터 학습하고 추세를 식별하는 데 도움이 됩니다.\n\n```python\nfrom pyspark.sql.window import Window\nfrom pyspark.sql.functions import lag, round\n\n# 'Date' 열을 기반으로 Window 명세 생성\nwindowSpec = Window.orderBy(\"Date\")\n\n# 'Total_global_active_power'의 이전 값 계산\ndf2 = df2.withColumn(\"power_lag1\", round(lag(col(\"Total_global_active_power\"), 1).over(windowSpec), 2))\n\ndisplay(df2)\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_7.png\" /\u003e\n\n(2) Delta features\n\n이는 원 데이터 필드와 랙 데이터 간의 차이를 계산하여 짧은 기간 내의 변화나 변동을 캡처하기 위한 차후 단계를 거치는 것입니다.\n\n```js\n# 열 간의 차이를 계산합니다\ndf2 = df2.withColumn(\"power_lag1_delta\", round(col(\"power_lag1\") - col(\"Total_global_active_power\"), 2))\n\ndisplay(df2)\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_8.png\" /\u003e\n\n(3) 창 평균 피처\n\n이러한 기능은 슬라이딩 윈도우 내에서 대상 데이터 필드의 평균 값을 계산하여 매끄러운 패턴과 상대적으로 장기적인 추세를 포착할 수 있도록 합니다. 여기서 창 크기를 14 (2 주)와 30 (대략 1 개월)로 선택했습니다.\n\n```js\n# 지정된 창 크기에 대한 데이터프레임에 창 평균 필드 추가\ndef add_window_avg_features(df, window_sizes):\n    for window_size in window_sizes:\n        window_col_name = f\"avg_power_l{window_size}\"\n        windowSpec = Window.orderBy(\"Date\").rowsBetween(-window_size, 0)\n        df = df.withColumn(window_col_name, round(avg(col(\"Total_global_active_power\")).over(windowSpec), 2))\n    return df\n\nwindow_sizes = [14, 30]\ndf2 = add_window_avg_features(df2, window_sizes)\n\ndf2.select(\"Date\", \"Total_global_active_power\", \"avg_power_l14\", \"avg_power_l30\").sort(\"Date\", ascending=False).show(5)\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_9.png\" /\u003e\n\n(4) 지수 가중 이동 평균 (EWMA) 피처\n\nEWMA 피처는 최근 데이터에 더 많은 가중치를 할당하여 과거 데이터에 덜 주의를 기울이는 창 평균 피처의 보정 버전입니다. 더 높은 가중치(알파) 값은 EWMA 피처가 원래 시계열에 더 밀접하게 추적하는 것을 의미합니다. 여기서는 0.2와 0.8이라는 두 가지 별도의 가중치를 선택했습니다.\n\n```python\nimport pyspark.pandas as ps\n\n# 데이터프레임에 지정된 알파 값의 EWMA 피처를 추가합니다\ndef add_ewma_features(df, alphas):\n    for alpha in alphas:\n        ewma_col_name = f\"ewma_power_w{str(alpha).replace('.', '')}\"\n        windowSpec = Window.orderBy(\"Date\")\n        df[ewma_col_name] = df.Total_global_active_power.ewm(alpha=alpha).mean().round(2)\n    return df\n\nalphas = [0.2, 0.8]\n# EWM 함수를 사용하기 위해 pandas-on-Spark 데이터프레임으로 변환합니다\ndf2_pd = df2.pandas_api()\ndf2_pd = add_ewma_features(df2_pd, alphas)\n# 다시 Spark 데이터프레임으로 변환합니다\ndf2 = df2_pd.to_spark()\n\ndf2.select(\"Date\", \"Total_global_active_power\", \"ewma_power_w02\", \"ewma_power_w08\").sort(\"Date\", ascending=False).show(5)\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_10.png\" /\u003e\n\n#4 Notebook에서 시각화 생성하기\n\n다양한 PySpark 함수와 메소드를 사용하여 시간 관련 데이터와 특성을 추출한 후, Databricks의 내장 지원을 활용하여 효율적으로 시각화를 생성할 수 있습니다. 이는 시각화 편집기에서 데이터 필드를 끌어다 놓고 시각적 설정을 구성함으로써 작동합니다. 아래는 몇 가지 예시입니다.\n\n- 산점도: 글로벌 활성 전력과 글로벌 강도 간의 관계\n\n\n\n해석: 두 분야 사이에는 매우 강한 양의 상관 관계가 있습니다.\n\n![그림](/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_11.png)\n\n- 상자 그림: 시간대별 글로벌 활성 전력 분포\n\n해석: 7:00부터 21:00까지 글로벌 활성 전력에 상대적으로 큰 변동이 있습니다.\n\n\n\n\n![Line Chart](/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_12.png)\n\n- Line chart: The changes in total global active power, EWMA with alpha 0.2, and EWMA with alpha 0.8 from Jan 2008 to Mar 2008\n\nInterpretation: EWMA with alpha 0.8 sticks more closely to the original time series than EWMA with alpha 0.2.\n\n![Line Chart](/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_13.png)\n\n\n\n\n또한, 기본 데이터 프로필을 생성하여 요약 통계량(개수, 누락된 값의 %, 데이터 분포 등)을 표시할 수 있습니다. 이를 통해 특성 엔지니어링 프로세스 전반에 걸쳐 데이터 품질을 보장할 수 있습니다. 위 시각화는 Databricks SQL을 사용하여 쿼리 출력으로 대체적으로 생성할 수도 있습니다.\n\n## 마무리\n\n저희는 Databricks 플랫폼을 활용하여 시계열 데이터의 피처 엔지니어링을 위해 PySpark를 사용한 실습을 진행했습니다:\n\n- 정적 및 스트리밍 데이터 수집은 각각 spark.read() 및 spark.readStream() 메서드를 사용합니다.\n- 기본 PySpark 함수(pyspark.sql.functions) 및 DataFrame 메서드를 활용하여 데이터 조작 및 탐색이 이루어집니다.\n- trend 관련 피처 추출은 pyspark.sql.Window를 사용하여 데이터 그룹 내의 관계를 계산합니다.\n- 내장된 Databricks Notebook 기능을 활용하여 시각화를 수행합니다.\n\n\n\n대규모 데이터셋을 다룰 때는 PySpark가 Pandas보다 확장성과 성능 능력으로 인해 자주 선호됩니다. PySpark의 지연 평가 지원 덕분에 계산은 필요할 때만 수행되어 오버헤드가 줄어듭니다. 그러나 때로는 Scala가 더 나은 선택일 수도 있습니다. 왜냐하면 Spark 자체가 Scala로 작성되었기 때문에 최신 기능을 적극적으로 활용할 수 있기 때문입니다. 또한 변경할 수 없는 객체를 사용하여 오류가 덜 발생하는 시스템을 설계할 수 있습니다. 각각의 언어나 라이브러리는 그들만의 장점을 갖고 있습니다. 궁극적으로 선택은 기업 요구 사항, 개발자들의 학습 곡선 및 다른 시스템과의 통합에 달려 있습니다.\n\n## 계속 진행하기 전에\n\n이 글을 즐겨 보셨다면, 제 Medium 페이지와 LinkedIn 페이지를 팔로우해 주시기를 초대합니다. 이렇게 하면 데이터 과학 사이드 프로젝트 관련 흥미로운 콘텐츠 및 머신 러닝 운영(MLOps) 방법론에 관한 데모를 최신 상태로 유지할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_0.png"},"coverImage":"/assets/img/2024-05-16-FeatureEngineeringforTime-SeriesUsingPySparkonDatabricks_0.png","tag":["Tech"],"readingTime":11},{"title":"EKS에서 자체 호스팅 LLM을 배포하는 방법 및 그 이유","description":"","date":"2024-05-16 03:39","slug":"2024-05-16-HowtoDeployaSelf-HostedLLMonEKSandWhyYouShould","content":"\n\n생산 환경에서 가격이 폭등하는 토큰에 대해 계속 걱정하고 있나요? 외부 업체가 민감한 데이터를 어떻게 처리하는지 걱정되나요? 이 게시물은 자체 호스팅 LLM을 EKS(Elastic Kubernetes Service)에 배포하는 방법을 안내해 드립니다. 이를 통해 제어권과 비용 효율성을 높일 수 있습니다. 우리는 자체 호스팅을 원하는 이유부터 설정에 필수적인 도구 및 지표에 이르기까지 모든 것을 탐구할 것입니다. 게다가 모델과 상호 작용할 수 있는 간단한 채팅 애플리케이션을 설정하는 방법을 따라해 보겠습니다.\n\n![이미지](/assets/img/2024-05-16-HowtoDeployaSelf-HostedLLMonEKSandWhyYouShould_0.png)\n\n# 자체 호스팅이란?\n\nOpenAI나 Anthropic과 같은 공급업체의 고급 언어 모델은 매우 인상적이지만 항상 지갑 친화적이라고 할 수 없습니다. 실험 및 개발은 금융 오퍼레이션팀의 주의를 끌지 않을 수 있지만, 프로덕션으로 전환하면 토큰당 요금 체계와 관련된 비용이 빠르게 누적될 수 있습니다.\n\n\n\n크고 비싼 모델들이 있긴 하지만, 언제나 당신의 요구 사항을 평가하고 단순히 큰 모델만을 공략하는 것이 아니라는 점을 염두에 두어야 합니다. 하지만 규모에 따라, 작은 모델도 결국에는 비실 것입니다.\n\n하지만, 돈만을 생각할 필요는 없어요. 자체 호스팅은 다음과 같은 중요한 이점들을 제공합니다:\n\n- 데이터 보안 — 모든 민감한 정보, 특히 개인 식별 정보(PII)는 우리 네트워크 내에서 안전하게 보관됩니다. 이 설정은 데이터를 외부로 보내거나 외부 공급 업체가 데이터를 어떻게 사용할지 걱정할 필요가 없게 합니다.\n- 개발자 자유 — 자체 호스팅은 개발자들이 치솟는 비용과 외부 데이터 개인 정보 보호 우려 없이 탐구하고 혁신할 수 있는 자유를 제공합니다. 이 자유는 기술적 실험을 장려하는 창의적인 환경을 지원하여 더 혁신적인 솔루션을 도출하게 됩니다.\n\nGPT-4와 맞먹는 오픈 소스 모델은 많이 찾기 어려울지 몰라도, 보통 GPT-3.5에서 다루는 작업에 적합한 수많은 대안이 있습니다. 이러한 모델 중 일부는 심지어 더 나은 성능을 발휘하면서 더 저렴한 비용으로 제공되고 있습니다. 이를 네트워크에 배포하여 데이터를 제어할 수 있습니다. 무엇보다 중요한 것은 사용량 당 비용을 지불하는 대신 고정 컴퓨팅 가격을 지불하므로 비용을 더 예측 가능하고 관리하기 쉽게 만들 수 있습니다.\n\n\n\n# 필요한 도구는 무엇인가요? (그리고 몇 가지 다른 고려 사항)\n\nAWS 및 EKS에 익숙하다고 가정하고, LLM 모델을 제공하는 데 필요한 다른 구성 요소에 초점을 맞추겠습니다. 고려해야 할 주요 영역은 Compute, 추론 및 모델입니다.\n\n## Compute\n\nLLM 추론을 설정할 때 고려해야 할 주요 자원은 GPU입니다. 특히 GPU의 종류와 수량을 고려해야 합니다. 이는 전체 모델이 GPU의 메모리 (VRAM)에 로드되며, 모든 LLM 계산이 GPU에서 수행되기 때문입니다.\n\n\n\n VRAM 양을 추정하려면 이 안내서를 확인하거나 다음과 같은 간단한 생각의 척도를 따르세요: 모델의 매개변수 수(10억 개 단위)를 두 배하여 기본 요구 사항을 얻은 다음, 캐싱과 오버헤드를 커버하기 위해 20%를 추가하세요. 예를 들어, 70억 개의 매개변수를 가진 모델을 이용하려면 VRAM 약 17GB(7 x 2 x 1.2 = 약 16.8 GB)가 한 개 또는 여러 개의 GPU에서 필요합니다.\n\n## 추론\n\n서빙 프레임워크로는 vLLM을 사용할 것입니다. 이는 LLM 모델을 OpenAI 호환 API 서버로 제공하는 데 설계된 오픈 소스 프레임워크입니다. vLLM은 연속 배치를 지원하며, 다중 동시 요청 및 높은 부하를 처리하기에 이상적입니다. 게다가, vLLM은 분산 서빙을 지원하며, 모델을 여러 GPU 또는 노드에서 실행해야하는 경우를 대비합니다. 분산 서빙을 위해 백엔드로 Ray를 사용하며, 이는 대규모 ML 애플리케이션을 실행하기 위한 또 다른 오픈 소스 프레임워크입니다.\n\n## 모델\n\n\n\n수백 개의 모델이 Hugging Face에 있습니다. Foundation 모델부터 더 구체적이고 특정 문제를 해결하기 위해 디자인된 Feat-Tuned 버전까지 말이죠. Hugging Face를 인공지능(AI) 및 기계학습(ML) 애플리케이션의 \"GitHub\"이라고 생각해보세요. 필요한 어떤 모델이나 데이터셋이든 찾을 수 있는 중요한 장소입니다.\n\n모델을 선택할 때 라이선스를 꼭 확인해주세요. Mistral과 같은 일부 모델은 Apache 라이선스 하에 완전히 오픈 소스입니다. 그러나 많은 모델은 상용 라이선스가 적용됩니다. 이 조항을 검토하는 것은 귀하의 법적 및 운영 계획에 부합하는지 확인하는 데 중요합니다.\n\n# 모두 함께 하기 (데모 시간)\n\n이 데모에서 Mistral 7b instruct 0.2 모델을 사용할 것이며, 이는 Apache 라이선스에 따라 완전히 오픈 소스입니다. 이 모델을 처리하기 위해 주로 15센트 미만의 비용이 드는 AWS g6.xlarge 인스턴스에서 실행할 것입니다. 이 인스턴스는 우리가 상의한 VRAM 견적 규칙에 따라 처리하기에 완벽하게 적합한 24GB VRAM을 갖춘 Nvidia L4 GPU가 장착되어 있습니다.\n\n\n\n데모 중에는 미국 서부-2 지역에 VPC를 배포하고, Fargate에서 Karpenter가 있는 EKS 클러스터, GPU를 위한 Karpenter 프로바이더 하나 및 표준 노드를 위한 또 다른 하나, Kubernetes에서 GPU를 사용할 수 있도록 Nvidia Driver 플러그인, 그리고 모니터링을 위한 Prometheus와 Grafana가 설정될 것입니다. 이 모든 리소스는 Terraform을 사용하여 설정될 것입니다.\n\n비용에 관해서는, 이 데모 실행에 예상되는 비용은 시간당 약 30~40센트입니다. NAT 게이트웨이, EKS 제어 평면 및 GPU가 장착된 노드를 포함한 모든 노드에 대한 요금이 포함됩니다.\n\n## 0. 전제 조건\n\n데모에 들어가기 전에, 다음을 준비해 두세요:\n\n\n\n- AWS 계정 — 데모에서 설치해야 할 VPC, EKS 클러스터 등을 구성할 충분한 권한이 있는 AWS 계정이 필요합니다.\n- AWS 자격 증명 — 로컬 환경에서 자격 증명이 올바르게 구성되어 있는지 확인하세요.\n- Terraform — 여러분의 컴퓨터에 Terraform이 설치되어 있어야 합니다. 데모에 필요한 AWS 리소스를 프로비저닝하고 관리하는 데 사용될 것입니다.\n- Kubectl — Kubernetes 리소스를 관리하기 때문에 Kubectl이 설치되어 있는지 확인하세요.\n- HuggingFace 액세스 토큰 — 이 가이드를 따라 Hugging Face에서 모델을 가져오기 위한 API 액세스 토큰을 생성하세요.\n\n## 1. 기본 인프라\n\n- 터미널을 열고 다음을 실행하여 저장소를 클론합니다:\n\n```js\ngit clone https://github.com/eliran89c/self-hosted-llm-on-eks\n```\n\n\n\n2. 디렉토리를 변경하세요:\n\n```js\ncd self-hosted-llm-on-eks\n```\n\n3. (선택사항) 필요에 따라 Terraform 코드를 조정하여 설정을 사용자 정의하세요.\n\n4. Terraform을 초기화하고 인프라를 배포하기 위해 Terraform 구성을 적용하세요 (EKS 클러스터를 배포하는 데 최대 30분 소요될 수 있습니다).\n\n\n\n```js\nterraform init\nterraform apply\n```\n\n5. 새로 생성된 EKS 클러스터와 상호 작용하기 위해 Kubectl을 설정하세요.\n\n```js\naws eks update-kubeconfig --region us-west-2 \\\n    --name self-hosted-llm \\\n    --alias self-hosted-llm\n```\n\n6. Karpenter와 CoreDNS가 실행 중인지 확인하세요.\n\n\n\n```js\nkubectl get pods --all-namespaces\n```\n\n기대되는 출력은 다음과 같아야 합니다:\n\n![image](/assets/img/2024-05-16-HowtoDeployaSelf-HostedLLMonEKSandWhyYouShould_1.png)\n\n7. Karpenter 제공자가 올바르게 설치되었는지 확인하세요:\n\n\n\n```js\nkubectl get ec2nodeclasses.karpenter.k8s.aws\n```\n\n원하는 결과는 사용 가능한 노드 클래스를 표시해야 합니다:\n\n![Available Node Classes](/assets/img/2024-05-16-HowtoDeployaSelf-HostedLLMonEKSandWhyYouShould_2.png)\n\n## 2. vLLM 배포 및 모델 제공\n\n\n\n- HuggingFace 모델 페이지로 이동하셔서 모델 약관에 동의해주세요\n\n![이미지](/assets/img/2024-05-16-HowtoDeployaSelf-HostedLLMonEKSandWhyYouShould_3.png)\n\n2. HuggingFace API 액세스 토큰을 사용하여 비밀을 생성하세요:\n\n```js\nkubectl create secret generic huggingface-token \\\n    --from-literal=token=\u003cyour_hugging_face_token\u003e\n```\n\n\n\n- 'your_hugging_face_token'을 실제 Hugging Face API 액세스 토큰으로 대체해주세요.\n\n3. (선택 사항) 배포 파일을 검토하고, 특히 배포 인수 섹션을 확인하세요. 필요에 따라 엔진 인수를 수정하여 특정 요구 사항에 더 잘 맞도록 설정할 수 있습니다. 모든 사용 가능한 엔진 인수 목록을 확인하려면 여기를 참조하세요.\n\n4. vLLM 배포하기:\n\n```js\nkubectl apply -f vllm.yaml\n```\n\n\n\n5. 프로메테우스가 vLLM에서 메트릭을 수집하도록 하려면 ServiceMonitor을 배포하십시오.\n\n```js\nkubectl apply -f serviceMonitor.yaml\n```\n\n6. vLLM을 배포한 후에는 일반적으로 GPU로 모델을 다운로드하고 로드하는 데 2-3분 정도가 소요됩니다. 이 초기화 단계 중에 무엇이 발생하는지 모니터링하려면 로그를 직접 확인할 수 있습니다.\n먼저, 파드가 실행 중인지 확인하십시오:\n\n```js\nkubectl get pods\n```\n\n\n\n아래와 같이 로그를 확인하세요:\n\n```js\nkubectl logs -f -l app=vllm\n```\n\n모델이 로딩되고 준비되면, 로그에 다음 메시지가 표시될 것을 기대할 수 있습니다:\n\n![이미지](/assets/img/2024-05-16-HowtoDeployaSelf-HostedLLMonEKSandWhyYouShould_4.png)\n\n\n\n7. 새 터미널을 열고 포트 포워딩을 설정하여 포트 8000에서 OpenAI 호환 API 엔드포인트와 상호 작용할 수 있습니다:\n\n```js\nkubectl port-forward svc/vllm 8000:8000\n```\n\n8. 모든 준비가 되었으므로, LLM을 테스트하기 위해 표준 OpenAI curl 명령을 사용하여 쿼리를 보내보세요. 아래는 예시입니다:\n\n```js\ncurl -X POST http://localhost:8000/v1/chat/completions \\\n-H \"Content-Type: application/json\" \\\n-d '{\n      \"model\": \"mistralai/Mistral-7B-Instruct-v0.2\",\n      \"messages\": [{\"role\": \"user\", \"content\": \"프랑스의 수도는 무엇인가요?\"}]\n    }'\n```\n\n\n\n정보를 성공적으로 검색했는지 확인하기 위해 예상 결과는 다음과 같습니다:\n\n\u003cimg src=\"/assets/img/2024-05-16-HowtoDeployaSelf-HostedLLMonEKSandWhyYouShould_5.png\" /\u003e\n\n## 3. 모델과 상호작용하는 간단한 채팅 애플리케이션 설정\n\n- 다음을 실행하여 새 Python 가상 환경을 만듭니다:\n\n\n\n```js\npython3 -m venv .venv\n```\n\n2. 가상 환경을 활성화합니다:\n\n```js\nsource .venv/bin/activate   # 리눅스 또는 맥OS\n.venv\\Scripts\\activate      # 윈도우\n```\n\n3. 필요한 파이썬 패키지를 설치하려면 다음을 실행하세요:\n\n\n\n\n```bash\npip install -r requirements.txt\n```\n\n이 패키지에는 API 요청을 위한 OpenAI Python 클라이언트와 웹 인터페이스를 만들기 위한 Gradio가 포함되어 있습니다.\n\n4. 아래 명령어를 실행하여 애플리케이션을 시작하세요:\n\n```bash\npython chat.py\n```\n\n\n\n5. 어플리케이션이 실행되면 웹 브라우저를 열고 http://localhost:7860/ 으로 이동하세요.\n\n![이미지](/assets/img/2024-05-16-HowtoDeployaSelf-HostedLLMonEKSandWhyYouShould_6.png)\n\n# 모델 모니터링\n\nLLM에서는 모델의 대기 시간(Latency) 및 처리량(Throughput)을 모니터링하고 측정하는 여러 중요한 지표가 있습니다. 이러한 지표들은 성능을 최적화하고 모델이 효율적으로 작동하는 것을 보장하기 위해 중요합니다. 아래는 고려해야 할 주요 지표입니다:\n\n\n\n첫 번째 토큰 생성 시간(TFFT) - 이 지표는 요청을 제출한 후 모델이 응답의 첫 번째 토큰을 생성하는 데 걸리는 시간을 측정합니다. 이는 모델의 초기 반응성을 나타내는 중요한 지표로, 사용자 상호 작용 애플리케이션에서 응답 시간이 사용자 경험에 영향을 미치는 경우에 특히 중요합니다.\n\n출력 토큰 시간(TFOT) - 위와 유사하게, 이 지표는 처음 토큰 생성 후 각 후속 토큰을 생성하는 데 걸리는 시간을 추적합니다. 이는 모델이 시작된 후 계속해서 내용을 처리하고 생성하는 데 효율성을 이해하는 데 도움이 됩니다. 이로써 실행량 성능에 대한 통찰을 얻을 수 있습니다.\n\n프롬프트/생성 토큰 초당 - 이 지표는 모델이 초당 처리하거나 생성하는 토큰 수를 측정합니다. 이는 모델의 처리량 용량을 평가하는 데 필수적인 지표이며, 높은 비율은 더 효율적인 모델을 나타내며 더 많은 입력을 처리하거나 시간이 적게 소요되면서 더 많은 컨텐츠를 생성할 수 있는 것을 의미합니다.\n\nvLLM은 이러한 지표(및 기타 지표)를 /metrics/endpoint를 통해 내보냅니다. 이미 Prometheus에 스크래퍼를 구성했으며, 이제 Grafana에서 대시보드를 설정하여 이러한 지표를 시각화하고 모델의 성능을 실시간으로 더 잘 이해할 수 있도록 합시다.\n\n\n\n## LLM 메트릭을 모니터링하기 위한 Grafana 대시보드 설정\n\n- 브라우저를 통해 Grafana 대시보드에 액세스하려면 먼저 Grafana 팟을 포트 포워딩해야 합니다. 터미널에서 다음 명령을 입력하세요:\n\n```js\nkubectl port-forward -n kube-prometheus-stack \\\n  service/kube-prometheus-stack-grafana 8080:80\n```\n\n2. 웹 브라우저를 열고 http://localhost:8080으로 이동하세요. 로그인 페이지가 나타날 것입니다. 사용자 이름은 \"admin\"이고 기본 비밀번호는 \"prom-operator\"입니다.\n\n\n\n3. 한 번 로그인한 후, 오른쪽 상단 막대의 “+\" 아이콘을 클릭하고 “대시보드 가져오기\"를 선택합니다.\n\n![image](/assets/img/2024-05-16-HowtoDeployaSelf-HostedLLMonEKSandWhyYouShould_7.png)\n\n4. GitHub 저장소의 루트 폴더에 있는 grafana-dashboard.json이라는 JSON 파일을 업로드하고 “가져오기\"를 클릭합니다.\n\n![image](/assets/img/2024-05-16-HowtoDeployaSelf-HostedLLMonEKSandWhyYouShould_8.png)\n\n\n\n5. 대시보드 상단 좌측에 있는 드롭다운 필터를 사용하여 원하는 모델을 선택해 모니터링할 수 있습니다:\n\n![이미지](/assets/img/2024-05-16-HowtoDeployaSelf-HostedLLMonEKSandWhyYouShould_9.png)\n\n## 환경 철거\n\n셋업을 제거하고 리소스를 해제하려면 다음 단계를 따르세요:\n\n\n\n- vLLM 배포를 제거하세요\n\n```js\nkubectl delete -f vllm.yaml\n```\n\n2. 이제, Terraform을 사용하여 생성된 모든 인프라 리소스를 삭제하세요. 아래 명령어를 실행하세요:\n\n```js\nterraform destroy\n```\n\n\n\n# 결론\n\n이 게시물에서는 중요한 혜택을 제공하는 자체 호스팅 LLM 설정을 살펴보았습니다. 특히 비용 절감과 데이터 제어 측면에서 큰 이점을 제공합니다. 이 설정은 GPT-4와 같이 가장 고급 모델이 필요하지 않거나, 작고 자원 소모가 적은 모델로도 충분한 경우에 특히 유용합니다.\n\n제품 사용을 위한 데모가 아님을 참고해주시기 바랍니다. 제품 환경에서 이 설정을 구현하기 위해 클러스터 건강 상태의 지속적인 모니터링이 매우 중요합니다. 또한 로드를 관리하고 서비스 가용성을 효과적으로 유지하기 위해 인그레스 및 스케일링 정책을 실행하는 것이 중요합니다.\n\n여러 노드에서 실행해야 하는 대규모 모델이 필요한 사용 사례의 경우, Ray operator인 KubeRay를 사용하는 것을 강력히 추천합니다. KubeRay는 복잡한 분산 시스템의 스케일링과 관리를 크게 용이하게 합니다. 큰 규모의 배포에서 KubeRay를 활용하는 방법에 대해 더 깊게 알고 싶으시면, 미래 게시물에서 KubeRay를 활용하는 것에 대해 자세히 다루도록 하겠습니다. 그게 궁금하신 경우 댓글에서 알려주시면 감사하겠습니다!","ogImage":{"url":"/assets/img/2024-05-16-HowtoDeployaSelf-HostedLLMonEKSandWhyYouShould_0.png"},"coverImage":"/assets/img/2024-05-16-HowtoDeployaSelf-HostedLLMonEKSandWhyYouShould_0.png","tag":["Tech"],"readingTime":9},{"title":"게임 개발 시작하기 게임 데이터 저장","description":"","date":"2024-05-16 03:38","slug":"2024-05-16-BeginningGameDevelopmentSavingGameData","content":"\n\n## Unity에서 C#을 활용한 저장 게임 기능 구현하기: 메소드, 저장소, 그리고 개인정보 보호\n\n![게임 개발 데이터 저장하기](/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png)\n\n안녕하세요! 플레이어 경험을 향상시키고 게임 진행 상태를 보장하기 위해 견고한 저장 게임 시스템은 필수입니다. Unity와 C#을 결합하면 다양한 저장 및 불러오기 기능을 구현할 수 있는 유연한 환경을 제공합니다. 이 글에서는 Unity에서 직렬화 기술을 활용하여 게임 상태, 플레이어 진행 상황, 그리고 동적인 게임 요소를 저장하는 방법에 대해 다루고 있습니다. 또한 로컬 저장과 원격 파일 저장의 장단점 및 플레이어 데이터 개인정보 보호에 대한 고려 사항을 살펴봅니다.\n\n1. Unity에서의 직렬화 기술 직렬화란 객체의 상태를 저장하고 나중에 다시 생성할 수 있는 형식으로 변환하는 프로세스입니다. Unity는 게임 상태를 저장하는 데 중요한 여러 직렬화 기술을 지원합니다.\n\n\n\n키 메서드:\n\n- 이진 직렬화: System.Runtime.Serialization.Formatters.Binary 네임스페이스를 사용하여 객체를 이진 형식으로 변환합니다. 이 방법은 빠르고 효율적이지만 사람이 읽기 어려워 디버깅을 복잡하게 할 수 있습니다.\n\n```js\nusing System.IO;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing UnityEngine;\npublic static class SaveSystem\n{\n    public static void SavePlayer(PlayerData player)\n    {\n        BinaryFormatter formatter = new BinaryFormatter();\n        string path = Application.persistentDataPath + \n            \"/player.save\";\n        FileStream stream = new FileStream(path, FileMode.Create);\n        formatter.Serialize(stream, player);\n        stream.Close();\n    }\n    public static PlayerData LoadPlayer()\n    {\n        string path = Application.persistentDataPath + \n            \"/player.save\";\n        if (File.Exists(path))\n        {\n            BinaryFormatter formatter = new BinaryFormatter();\n            FileStream stream = new FileStream(path, FileMode.Open);\n            PlayerData data = formatter.Deserialize(stream) as \n                PlayerData;\n            stream.Close();\n            return data;\n        }\n        else\n        {\n            Debug.LogError(\"Save file not found in \" + path);\n            return null;\n        }\n    }\n}\n```\n\n![게임 개발 시작화면용 데이터 저장 이미지](/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_1.png)\n\n\n\n- JSON 직렬화: Unity의 JsonUtility를 사용하면 객체를 JSON 형식으로 직렬화할 수 있습니다. JSON은 사람이 읽기 쉽고 수정하기 쉬워 설정 및 설정에 적합합니다.\n\n```csharp\nusing UnityEngine;\npublic static class SaveSystem\n{\n    public static void SavePlayer(PlayerData player)\n    {\n        string json = JsonUtility.ToJson(player);\n        System.IO.File.WriteAllText(Application.persistentDataPath + \n             \"/player.json\", json);\n    }\n    public static PlayerData LoadPlayer()\n    {\n        string path = Application.persistentDataPath + \n              \"/player.json\";\n        if (System.IO.File.Exists(path))\n        {\n            string json = System.IO.File.ReadAllText(path);\n            PlayerData data = \n                 JsonUtility.FromJson\u003cPlayerData\u003e(json);\n            return data;\n        }\n        else\n        {\n            Debug.LogError(\"저장 파일을 \" + path + \"(으)로 찾을 수 없음\");\n            return null;\n        }\n    }\n}\n```\n\n![게임 데이터 저장 개발 시작](/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_2.png)\n\n2. 로컬 vs. 원격 파일 저장소: 게임의 디자인과 목표에 따라 로컬 및 원격 저장소 중 어떤 것을 선택할지 결정하는 것이 중요합니다.\n\n\n\n로컬 저장소:\n\n- 장점: 빠른 액세스, 인터넷 연결이 필요하지 않으며 데이터에 대한 완전한 제어.\n- 단점: 장치에 제한됨, 장치가 손상되거나 분실된 경우 데이터 손실 가능성, 플레이어가 조작하기 쉬울 수 있음.\n\n원격 저장소:\n\n- 장점: 모든 장치에서 액세스 가능, 데이터가 백업되어 손실 확률이 적음, 데이터 조작에 대한 보안이 높음.\n- 단점: 인터넷 연결이 필요, 서버 유지보수에 지속적인 비용, 잠재적인 개인정보 보안 문제.\n\n\n\n3. 플레이어 데이터 개인 정보 보호 저장한 게임 기능을 구현할 때 특히 원격 저장 시 개인 정보 보호는 최우선 과제여야 합니다.\n\n개인 정보 보호 규정:\n\n- 암호화: 저장된 데이터를 암호화하면 전송 중 및 휴식 상태에서 민감한 정보를 보호할 수 있습니다.\n- 규정 준수: 게임은 플레이어 데이터를 저장하고 사용하는 방법을 규제하는 유럽의 GDPR과 같은 법적 기준을 준수해야 합니다.\n- 명확한 사용자 허가: 플레이어에게 저장되는 데이터에 대해 알리고 원하는 경우 원격으로 데이터를 저장하지 않도록 선택할 수 있도록 허용하세요.\n\n![이미지](/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_3.png)\n\n\n\n## 결론\n\nUnity에서 C#을 사용하여 세이브 게임 기능을 구현하면 게임 상태와 플레이어 진행 상황을 효과적으로 관리할 수 있는 다양한 방법을 제공합니다. 로컬 또는 원격 저장소를 사용하더라도 각 방법은 보안과 플레이어 개인 정보 보호와 관련하여 장단점이 있습니다. Unity의 직렬화 기능을 이해하고 활용함으로써, 개발자는 플레이어에게 원활하고 안전한 게임 경험을 제공할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png"},"coverImage":"/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png","tag":["Tech"],"readingTime":4},{"title":"AI-Powered 웹 개발을 위해 사용해야 할 10가지 도구","description":"","date":"2024-05-16 03:37","slug":"2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev","content":"\n\n## 이 중에서 각각을 신중하게 시도해본 결과, 정말로 여러분의 삶을 변화시킬 것입니다!\n\n웹 개발의 세계는 끊임없이 진화하고 있습니다. 숙련된 개발자는 늘 교체할 수 없지만, AI는 워크플로우를 최적화하고 생산성을 향상시키는 데 심각한 영향을 미치고 있습니다.\n\n![AI-powerd web development](/assets/img/2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev_0.png)\n\n이 글에서는 경험 수준에 관계없이 웹 개발자를 권능있게 할 수 있는 놀라운 10가지 AI 앱들을 살펴보겠습니다.\n\n\n\n# 1. 창의성을 발휘하세요: 디자인 및 콘텐츠 생성\n\n- Lensa AI: 애니메이션부터 슈퍼히어로까지 독특한 스타일로 자신의 아트 이미지를 만들어보세요.\n\n![이미지](/assets/img/2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev_1.png)\n\n- Deep Art: 사진을 반 고흐 또는 다빈치와 같은 유명한 화가의 작품으로 변환해보세요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev_2.png\" /\u003e\n\n- MyHeritage: MyHeritage의 Deep Nostalgia 기능을 사용하여 오래된 가족 사진에 생명을 불어 넣고 조상들이 살아있는 모습을 보세요!\n\n\u003cimg src=\"/assets/img/2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev_3.png\" /\u003e\n\n# 2. 협업과 사용자 경험을 향상하세요\n\n\n\n- Reface: 친구들과 웃음을 선사할 수 있는 재미있는 GIF 및 비디오 클립에 자신의 얼굴을 올려보세요.\n\n![Reface](/assets/img/2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev_4.png)\n\n- Face Swap Live: 실시간 비디오에서 친구들과 얼굴을 스왑하여 더 많은 웃음을 선사하세요.\n\n![Face Swap Live](/assets/img/2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev_5.png)\n\n\n\n- Avatarify: 이 앱을 사용하여 얼굴 표정을 활용해 아바타를 실시간으로 애니메이션화하세요. 인기 있는 미미나 노래도 추가로 즐길 수 있어요.\n\n![image](/assets/img/2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev_6.png)\n\n# 3. 프로처럼 코딩하기: 도움과 자동화\n\n- ChatGPT, Gemini: 복잡한 코딩 질문에 대한 답변을 받으며 특정 주제에 대한 구조화된 정보를 얻을 수 있어요.\n- GitHub의 Copilot: 프로젝트 컨텍스트를 기반으로 실시간 코드 제안 및 전체 기능 추천을 받을 수 있어요.\n- Tabnine: 이 AI 어시스턴트는 다음 코드 라인을 예측하고 제안하여 개발 프로세스를 가속화시켜 줘요.\n\n\n\n# 4. 더 나은, 빠르고 강력하게: 효율성과 보안\n\n- Sketch2Code (Microsoft 제공): 번거로운 레이아웃 단계를 건너뛰고 간단한 손그림 스케치를 기능적인 HTML 보일러플레이트로 변환합니다.\n\n![이미지](/assets/img/2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev_7.png)\n\n- Snyk: Snyk의 AI 분석 엔진을 사용하여 코드 내의 보안 취약점을 식별하고 처리하세요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev_8.png\" /\u003e\n\n- Mintlify: 코드에서 명확하고 간결한 문서를 자동으로 생성하여 창의적인 작업에 더 많은 시간을 할애할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev_9.png\" /\u003e\n\n# 5. 미래는 지금: 인공지능 기반 웹사이트 생성\n\n\n\n- 내구성: 최신 기술을 활용하여 아름다운 디자인, 콘텐츠 및 이미지로 완전한 웹사이트를 더 적은 시간에 생성하세요.\n\n![image](/assets/img/2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev_10.png)\n\n기억하세요: 인공지능은 놀라운 지원을 제공하지만 인간의 전문지식을 대체해서는 안 됩니다. 이 도구들을 활용하여 여러분의 기술을 향상시키고 제거하지 마세요.\n\n이 AI-기반 도구들을 탐험하고 생산성을 높여보세요! 웹 개발에 관한 몇 가지 기사를 쉽게 작성할 거에요... :P\n\n\n\n당신은 멋져요 :)","ogImage":{"url":"/assets/img/2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev_0.png"},"coverImage":"/assets/img/2024-05-16-10ToolsYouNeedToUseForAI-PoweredWebDev_0.png","tag":["Tech"],"readingTime":3},{"title":"잘했어요","description":"","date":"2024-05-16 03:34","slug":"2024-05-16-Bravo","content":"\n\n## 버밍엄 시의회 IT 고난의 이야기: 왜 기업들은 여전히 대형 소프트웨어 업체를 선택할까요...\n\n![이미지](/assets/img/2024-05-16-Bravo_0.png)\n\n** 참고: 이 기사의 모든 내용은 순전히 의견입니다 **\n\n버밍엄 시의회는 최근 새로운 소프트웨어 시스템의 재앙적인 롤아웃 사태 속에서 오라클을 중단하지 않기로 결정해 헤드라인을 낸 바 있습니다.\n\n\n\n\"결정은, 보고된 바에 의하면, 수백만 파운드가 손실되고 지방세가 상당히 인상된 뒤에 이루어졌습니다.\n\n이 상황에서 생긴 의문은, 왜 기업들이 큰 소프트웨어 벤더를 선택해야 하는데도 그들이 그토록 대단히 실패하는 것처럼 보일 때까지 계속 선택하는지에 대한 것입니다.\n\n# 큰 이름의 유혹\n\n큰 소프트웨어 벤더들은 수십 년 동안 명성을 쌓아 왔습니다.\"\n\n\n\n안녕하세요! 여기서는 기존 시스템에 매끄럽게 통합될 수 있는 제품 스위트와 안정성, 지원을 약속하는 회사에 대해 이야기합니다.\n\nBirmingham City Council과 같은 공공 부문 단체를 비롯한 많은 기관들에게 이러한 약속은 매력적일 수 있습니다. 큰 잘 알려진 회사는 약속을 지킬 자원과 전문지식을 갖추고 있어야 한다는 논리입니다.\n\n# 대규모 프로젝트의 복잡성\n\nBirmingham City Council과 같이 대규모이고 복잡한 조직에서의 새로운 소프트웨어 시스템 구현은 쉬운 작업이 아닙니다. 방대한 양의 데이터 이전, 직원 교육, 모든 시스템 부분이 매끄럽게 작동하는 것을 보장하는 등의 작업이 필요합니다. 대형 소프트웨어 공급 업체는 종종 이러한 복잡한 작업을 처리하는데 있어 경험과 자원을 갖추고 있어서 더 작은 공급 업체가 고민할 수 있는 부분들을 다룰 수 있습니다.\n\n\n\n그러나 버밍엄에서 볼 수 있는 것처럼, 이러한 거대 기업들조차 실수를 범할 수 있습니다. 프로젝트의 복잡성과 잠재적인 잘못된 관리 및 적절한 맞춤화 부재가 큰 문제로 이어질 수 있습니다. 이러한 문제들은 신속히 확대되어 재정 손실과 운영 중단으로 이어질 수 있습니다.\n\n# 안전망 일루전\n\n과거의 실패에도 불구하고 대형 소프트웨어 공급업체들이 계속해서 계약을 체결하는 이유 중 하나는 제공하는 안전망으로 인식된다는 것입니다. 무언가 잘못되었을 때, 조직들은 대형 소프트웨어 공급업체가 문제를 해결할 자원이 있다고 믿습니다. 이런 안전망은 때로는 일루전일 수 있으며, 버밍엄 사례에서 볼 수 있었습니다. 롤아웃이 실패하면, 수정은 종종 비용이 많이 들고 시간이 오래 걸리며, 원래 비용과 복잡성을 더해줍니다.\n\n# 공급업체 잠금현상\n\n\n\n한 조직이 대규모 소프트웨어 공급업체에 투자하면 다른 제공업체로 전환하는 것이 굉장히 어렵고 비용이 많이 들 수 있습니다. 이 현상은 벤더 락-인이라고 알려져 있으며, 문제가 발생해도 조직은 처음 선택한 공급업체를 그만두는 것이 아니라 계속 고수해야 한다고 느낄 수 있습니다. 특히 이미 시간, 비용 및 교육 측면에서 상당한 투자가 이루어진 경우에는 더 그렇습니다.\n\n# 책임 회피\n\n대규모 조직에서 대형 소프트웨어 공급업체를 선택하는 결정은 일반적으로 위원회나 복잡한 구매 과정을 통해 이루어집니다. 이는 책임을 분산시키고 한 명의 개인을 결정에 책임을 물을 수 없게 만들어 프로젝트가 실패하면 잘못된 선택이 처음부터 이루어졌을 수도 있다고 인정하는 것보다 공급업체를 탓하는 것이 더 쉽습니다.\n\n# 모티베이션 희석\n\n\n\n대형 소프트웨어 업체들의 주요 문제 중 하나는 팀원들의 동기 부여가 희석된다는 점입니다. 이들 업체들은 종종 여러 프로젝트에 동시에 다양한 인원을 배정하여 집중과 헌신이 부족해지는 문제가 발생합니다. 팀은 한 프로젝트에서의 성과가 회사 내 전반적인 위치에 영향을 미칠 가능성이 낮기 때문에 더 나은 성과를 내기 위한 동기부여를 받지 못합니다. 내재적 동기 부족은 품질이 낮고 프로젝트별 요구에 충분히 신경을 쓰지 않게 만들 수 있습니다.\n\n한편, 지역 소프트웨어 컨설팅 업체나 사업체들은 성공적인 결과물을 전달할 동기 부여를 가지고 있습니다. 그들의 평판이 그에 달려 있으며, 각 프로젝트는 앞으로의 계약 보장에 상당한 영향을 줄 수 있습니다. 성공적인 효과적인 구현은 그들의 포트폴리오를 강화시키는 것뿐만 아니라, 그들의 능력에 대한 강력한 증거로 작용하여 새로운 비즈니스 기회를 창출할 수 있습니다.\n\n# \"쿠키 커터\" 방식\n\n대규모 소프트웨어 업체들은 종종 \"쿠키 커터\" 방식을 채택하여 서로 다른 클라이언트에 표준화된 방법과 솔루션을 적용합니다. 이러한 방법들은 일부 상황에서 효과가 있을 수 있지만, 종종 기관의 독특한 과정을 강제로 일정한, 미리 정의된 틀에 맞추는 결과를 초래합니다. 맞춤화의 부족은 조직이 소프트웨어에 맞추기보다는 소프트웨어가 조직에 맞게 조절되도록 작업하기 위해 적응하기 어려움을 야기할 수 있습니다.\n\n\n\n이 접근법은 클라이언트의 특정 요구 사항과 워크플로우를 고려하여 디자인된 맞춤형 소프트웨어 솔루션과는 대조적입니다. 맞춤형 솔루션은 유연성을 제공하여 소프트웨어가 조직 요구 사항과 완벽하게 일치하도록 보장하여 생산성과 사용자 만족도를 향상시킵니다.\n\n# Gen-AI 시대의 맞춤형 솔루션 부상 \u0026 고객 기대의 증가\n\nAI의 등장으로 더 맞춤형 경험에 대한 수요가 증가하고 있습니다. \"enshittification\"이라는 개념에서 보듯, 큰 소프트웨어 공급업체들의 느린 개선과 적응 속도가 강조되고 있습니다. 그들은 종종 크기와 관료적인 프로세스로 인해 개선과 적응을 더디 질 수 있습니다.\n\n그에 반해 맞춤형 소프트웨어는 민첩하고 더 개인화되어 있습니다. 작은 팀은 빠르게 반복하고 최신 기술을 통합하며 변화하는 요구에 신속하게 대응할 수 있습니다. 이러한 민첩성은 현재의 빠르게 변화하는 디지털 환경에서 특히 가치가 있으며, 조직은 경쟁력을 유지하기 위해 지속적으로 혁신해야 합니다.\n\n\n\n# 협력 제공 모델 활용\n\n또 다른 중요한 기회는 협력 제공 모델에 있습니다. 대규모 공급업체에 의존하는 대신, 버밍엄 시의회와 같은 기관은 지역 컨설팅 회사와 협력하여 소프트웨어 솔루션을 함께 개발하고 운영할 수 있습니다. 이 협력적 접근은 소프트웨어가 시의회의 특정한 요구에 맞게 맞추어지도록 보장할 뿐만 아니라 잠재적인 수익 흐름을 열어줍니다.\n\n예를 들어, 적합한 시장이 도출되면 개발된 소프트웨어나 해당 파생 제품을 다른 기업이나 시의회에 소프트웨어 서비스(SaaS)로 제공할 수 있습니다. 이 협력 모델은 혁신을 증진시키며, 지역 컨설팅 회사로부터 높은 수준의 헌신을 보장하고 상호 성공 기회를 창출합니다. 표준화된 오퍼링을 제공하는 대규모 공급업체는 이러한 맞춤형 참여 및 상호 성장의 가능성을 제공할 수 없습니다.\n\n# 1,400만 파운드가 달성할 수 있는 것들\n\n\n\n## 내부 소프트웨어 팀 구축하기\n\n버밍엄 시의회가 14백만 파운드의 예산을 가지고 있어, 우수하고 잘 지불되는 내부 소프트웨어 팀을 구축할 수 있었을 것입니다. 이 예산을 어떻게 할당할 수 있는지 살펴보겠습니다:\n\n- 급여: 연봉 70,000 파운드를 받는 20명의 고품질 소프트웨어 개발자 팀을 고용한다면, 연간 1.4백만 파운드가 필요합니다. 3년 프로젝트 동안, 이는 순수 추정치로 3년간 1.5백만 파운드의 국민보험 및 연금 비용 제외하고 총 4.2백만 파운드가 소요됩니다.\n- 혜택 및 교육: 급여의 30%에 해당하는 혜택과 꾸준한 전문적 개발은 3년간 추가 1.26백만 파운드가 소요됩니다.\n- 인프라: 하드웨어, 소프트웨어 라이선스 및 사무 공간 등 필요한 인프라 구축 비용은 약 50만 파운드가 들 것으로 예상됩니다.\n- 프로젝트 관리 및 추가 인력: 프로젝트 관리자, QA 테스터 및 지원 인력을 포함한다면 3년간 추가 1.5백만 파운드 정도가 소요될 것입니다.\n\n이는 3년간 7.46백만 파운드이며 (+국민보험 및 연금 비용으로 추정한 1.5백만 파운드), 추가 인력, 기술 및 혁신에 대한 투자 또는 여유 자금을 확보할 수 있는 충분한 여유가 있다는 뜻입니다.\n\n\n\n## 지역 소프트웨어 컨설팅 회사 고용\n\n또 다른 방법으로 버밍엄 시의 의회는 지역 컨설팅 회사를 고용할 수도 있는데, 커뮤니티와의 밀접한 연관성과 평판 유지에 대한 보다 큰 흥미로 인해 성공적인 결과물을 제공하려는 동기가 더 강할 것입니다.\n\n예산 활용 방법은 다음과 같습니다:\n\n- 컨설팅 비용: 지역 컨설팅 회사는 하루에 컨설턴트 당 £800에서 £1,200 정도의 비용을 청구할 수 있습니다. 평균 £1,000의 요금이 필요하고 1년 동안 10명의 컨설턴트가 필요한 경우, 연간 약 £2.5 백만이 드는 비용이 발생합니다. 3년 프로젝트에 걸쳐 이는 총 £7.5 백만이 됩니다.\n- 맞춤 및 통합: 맞춤, 통합 및 예상치 못한 문제로 인한 추가 비용은 또 £2 백만 정도 추가로 발생할 수 있습니다.\n- 지속 지원 및 유지 보수: 시스템에 대한 지속적인 지원 및 유지 보수는 3년 동안 약 £1 백만이 소요될 수 있습니다.\n\n\n\n이로 인해 총액은 1050만 파운드가 되었으며, 예상치 못한 비용이 발생할 여지를 남겨 프로젝트가 예산 내에 유지되도록 하였습니다.\n\n## 책임과 성실한 주의의 필요성\n\n버밍엄 시의회의 경험은 소프트웨어 벤더를 선택할 때 더 큰 책임과 철저한 실무 조사가 필요함을 강조합니다. 조직은 큰 벤더의 약속이 실제 능력과 지난 성과와 일치하는지를 비판적으로 검토해야 합니다. 참조, 사례 연구 및 소규모 시범 프로젝트는 벤더가 실제로 무엇을 제공할 수 있는지에 대한 소중한 통찰을 제공할 수 있습니다.\n\n# 큰 벤더의 사치 사이클\n\n\n\n이 상황이 얼마나 터무니없는지 우회하지 말자.\n많은 대규모 판매업자가 들뜬 약속과 큰 계약으로 나타난다.\n\n이에 대응하여 시민들의 세금으로 이 거대한 지출을 하기 위해 이사회가 돈을 쏟아부을 것이다. 그리고 이 돈의 상당 부분은 무엇에 쓰일까? 아마도 임원들에게 대규모 보너스로 배출될 것 같다.\n\n버밍엄의 세금 내는 시민들은 자신들의 지역 사회에 재투자되어야 할 실질적 가치를 보기보다는 사치로운 요트와 사적 비행기를 지원하는 데 그 돈이 쓰인다.\n\n# 만일 그 14백만 파운드가 대신 지역 경제에 투자되었다면 상상해보라.\n\n\n\n번가만의 Bedrock 소프트웨어 솔루션을 만들어주었으면서도 현지 기업을 지원하고 일자리를 만들어내며 도시 내 혁신을 촉진할 수 있었을 텐데, 이러한 설치 실패와 과도한 세금 청구로 인해 이제 우리는 이렇게 되었습니다.\n\nBravo.\n\n# 결론\n\n\n\n버밍엄 시의회의 이야기는 큰 소프트웨어 공급업체에 의존하는 것의 함정을 강조하는 예비교를 보여줍니다.\n\n그들의 명성과 자원은 매력적일 수 있지만, 이러한 공급업체는 절대적으로 신뢰할 수 없습니다. 기업과 공공 부문 기관은 엄격한 평가를 수행하고, 책임성을 찾고, 비용이 많이 발생하고 혼란스러운 소프트웨어 실패의 함정에 빠지지 않도록 대안을 고려해야 합니다.\n\n결국 목표는 기관의 요구 사항에 맞는 적합한 솔루션을 찾는 것이어야 하며, 거대한 기업명에 압도당하지 말아야 합니다.\n\n이 접근은 비용을 절감하고, 위험을 감소시키며, 결국 더 성공적인 결과를 이끌어 낼 수 있습니다. 맞춤형 솔루션, 지역 컨설팅 회사 및 혁신적인 파트너십 모델은 보다 맞춤형, 효율적이고 동기부여된 서비스 제공이 가능한 대안으로 나타날 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-16-Bravo_0.png"},"coverImage":"/assets/img/2024-05-16-Bravo_0.png","tag":["Tech"],"readingTime":6},{"title":"2024년 판타지 앱 개발의 최신 기술 이해하기","description":"","date":"2024-05-16 03:32","slug":"2024-05-16-UnderstandingtheLatestTechnologiesinFantasyAppDevelopmentfor2024","content":"\n\n![이미지](/assets/img/2024-05-16-UnderstandingtheLatestTechnologiesinFantasyAppDevelopmentfor2024_0.png)\n\n판타지 장르는 책과 영화를 넘어서 모바일 앱의 동적인 세계에서 관객들을 매료시킵니다. 일일 판타지 스포츠부터 복잡한 롤플레잉 게임까지, 이러한 앱들은 사용자들을 환상적인 세계로 탈출시키고 가상의 영광을 놓고 경쟁하거나 끝없는 창의력을 탐험할 수 있게 합니다. 하지만 기술은 끊임없이 진화하고 있기 때문에 2024년의 판타지 앱 개발에서 선두에 서 있는 것이 중요합니다. 그래서, 귀하의 판타지 앱에 고려해야 할 최첨단 기술은 무엇일까요?\n\n1. 인공 지능 (AI): 사용자들에게 더 몰입하고 동적인 경험을 제공하기 위해 AI의 힘을 받아들이세요.\n\n- AI 기반 선수 예측: 판타지 스포츠 앱에서 AI는 기본 통계 이상의 방대한 양의 선수 데이터를 분석할 수 있습니다. 날씨 조건, 최근 부상, 특정 상대에 대한 역사적 성적 등과 같은 요인을 포함한다고 상상해보세요. 이는 사용자가 데이터 중심 결정을 내릴 수 있도록 도와주며 경쟁 우위를 갖춘 우승 팀을 선발할 수 있게 도와줍니다.\n- 지능형 인게임 조정: RPG에서 AI는 적의 행동을 개인화하거나 플레이어의 선택에 따라 스토리를 조정할 수 있습니다. 플레이어들의 전술에서 배우고 그에 따라 전략을 조정하는 적이나 당신의 결정과 선택에 반응하는 세계로 상상해보세요. 이는 유기적으로 펼쳐지는 참으로 독특한 게임 플레이 경험을 창출해냅니다.\n\n\n\n2. 증강 현실 (AR) 및 가상 현실 (VR):\n\n- AR은 환상의 세계를 현실로 만들어줍니다: 생중계 스포츠 이벤트 중에 실제 세계에 선수 통계 및 성적 열지도를 오버레이하거나 AR을 사용하여 가상 던전을 탐험하고 거실에서 환상적인 생물과 상호 작용할 수 있는 상상해보세요. AR은 사용자가 환상 앱과 상호 작용하는 방식을 혁신적으로 변화시키는 잠재력이 있어서 실제 세계와 가상 세계 사이의 경계를 흐려집니다.\n- 깊은 몰입을 위한 VR: VR은 사용자를 직접 꿈의 세계 속으로 이송할 수 있습니다. VR RPG에서 용과 전투를 벌이거나 환상적인 스포츠 앱에서 가상 스타디움의 쾌감을 느낄 수 있습니다. VR은 몰입적인 관중 소리와 선수 상호 작용이 포함된 환상적인 사용자 경험을 만들어줍니다. VR은 정말로 잊지 못할 사용자 경험을 만들어내는 데 뛰어난 잠재력을 제공합니다.\n\n3. 블록체인 기술:\n\n- 보안이 보장된 앱 내 경제: 블록체인을 활용하여 가상 아이템이나 수집품을 위한 안전하고 투명한 앱 내 경제를 구축할 수 있습니다. 사용자가 실제 가치를 가지는 디지털 자산을 소유하고 거래할 수 있도록 함으로써 사용자 경험을 향상시킬 수 있습니다. 실제 성적에 따라 가치가 변동하는 디지털 선수 카드를 소유하고 거래할 수 있는 환상 스포츠 앱을 상상해보세요. 블록체인 기술은 안전한 거래를 용이하게 하고 이러한 디지털 자산의 소유권을 확실히 할 수 있습니다.\n\n\n\n4. 클라우드 기반 솔루션:\n\n- 확장성 및 성능: 클라우드 기반 솔루션은 판타지 앱을 위한 견고하고 확장 가능한 인프라를 제공합니다. 이를 통해 앱이 성능에 영향을 주지 않고 사용자 기반이 점점 늘어나는 경우에도 처리할 수 있습니다. 특히 드래프트 데이나 주요 스포츠 이벤트와 같은 사용량이 많은 기간 중에도 연말 사용량을 고려하여 매끄러운 사용자 경험을 상상해보세요. 이는 신뢰할 수 있는 클라우드의 강력한 성능 덕분에 가능합니다.\n- 매끄러운 데이터 관리: 클라우드 스토리지는 방대한 양의 사용자 데이터, 선수 통계, 복잡한 게임 내 정보, 그리고 개인 사용자 환경 설정을 관리하는 데 안전하고 신뢰할 수 있는 플랫폼을 제공합니다. 이를 통해 데이터 저장 한계에 대해 걱정하지 않고 매력적인 기능 및 콘텐츠를 개발하는 데 집중할 수 있습니다.\n\n5. 심화 분석 및 머신러닝:\n\n- 더 깊은 연결을 위한 맞춤화: 사용자 데이터와 머신러닝을 활용하여 사용자 경험을 새로운 수준으로 맞춤화할 수 있습니다. 개별 사용자 선호도를 기반으로 판타지 드래프트용 선수를 추천하거나, 사용자 선택에 맞춰 RPG의 스토리를 맞춤화하거나, 사용자가 가장 즐길 만한 앱 콘텐츠를 제안하는 것을 상상해보세요. 머신러닝은 사용자들이 계속해서 참여하고 돌아오도록 유지할 수 있는 진정한 맞춤 경험을 만드는 데 도움을 줄 수 있습니다.\n- 데이터 기반 의사결정: 사용자 행동과 앱 데이터를 분석하여 개선할 부분을 식별하고 미래 업데이트, 버그 수정, 새로운 기능 구현에 대한 정보를 얻을 수 있습니다. 사용자 행동에 대한 실시간 통찰력을 갖는 것은 게임 플레이 메카닉을 최적화하고 문제점을 해결하며 사용자가 진정으로 원하는 기능을 구현하는 데 도움이 됩니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-16-UnderstandingtheLatestTechnologiesinFantasyAppDevelopmentfor2024_1.png\" /\u003e\n\n판타지 앱 성공을 향한 길\n\n이 최신 기술을 통합하여, 혼잡한 시장에서 두드러지는 혁신적이고 매력적인 판타지 앱을 만들 수 있습니다. 그러나 기술만으로는 충분하지 않다는 것을 기억하세요. 성공을 위한 몇 가지 중요한 고려 사항은 다음과 같습니다:\n\n- 사용자 경험(UX)에 초점을 맞추세요: 판타지 장르에 대한 초보자들을 위해 특히 쉽게 탐색할 수 있는 직관적이고 사용자 친화적인 인터페이스를 디자인하세요.\n- 번영하는 커뮤니티 조성: 사용자 간의 소통과 상호 작용을 촉진하는 기능을 통합하세요. 인앱 채팅 기능, 리그 생성 도구, 소셜 미디어 공유 옵션 등이 좋은 예입니다.\n- 숙련된 판타지 앱 개발 회사와 협업하세요: 판타지 앱 개발 경험, 성공의 입증된 업적, 최신 기술에 대한 깊은 이해를 가진 팀을 찾아보세요.\n\n\n\n창의성, 첨단 기술, 그리고 사용자 경험에 중점을 두면, 여러분의 판타지 앱은 2024년부터 미래까지 다가올 대세가 될 수 있습니다. 판타지 앱 개발 여정에 나서는 동안 고려해야 할 몇 가지 추가적인 사항들이 있습니다:\n\n- 혁신 수용: 판타지 앱 환경은 지속적으로 발전하고 있습니다. 최신 트렌드를 파악하고 앱의 기능과 사용자 경험을 향상시킬 수 있는 새로운 기술들을 탐구하는 것이 중요합니다.\n- 보안 우선: 사용자 데이터와 금융 거래(해당하는 경우)는 견고한 보호가 필요합니다. 산업 표준 보안 조치를 도입하여 민감한 정보를 보호하고 사용자 신뢰를 구축하세요.\n- 글로벌 사고, 로컬 행동: 사용자 범위를 단일 지역을 넘어 확대할 계획이라면, 로컬라이제이션 기능을 고려해보세요. 국제 관객들을 위해 콘텐츠, 통화, 문화적 참조를 조정하세요.\n\n판타지 앱의 미래\n\n판타지 앱의 미래는 흥미로운 가능성으로 넘쳐납니다. 기술이 계속 발전함에 따라, 더욱 몰입적인 경험, 깊이 있는 플레이어 참여, 그리고 메타버스와 같은 신흥 기술과의 통합 가능성이 기대됩니다. 이러한 진보를 수용하고 매혹적이며 사용자 중심의 경험을 만들기에 초점을 맞춘다면, 전 세계 사용자들의 상상을 사로잡고 모바일 엔터테인먼트 세계에서 선두 주자가 될 수 있는 판타지 앱을 개발할 수 있습니다.\n\n\n\nDavid Wyatt  \n모바일 앱 개발 전문가  \n판타지 스포츠 앱 전문가  \nSciflare Technologies  \n\n팔로우해주세요:  \n- Behance  \n- dribble  ","ogImage":{"url":"/assets/img/2024-05-16-UnderstandingtheLatestTechnologiesinFantasyAppDevelopmentfor2024_0.png"},"coverImage":"/assets/img/2024-05-16-UnderstandingtheLatestTechnologiesinFantasyAppDevelopmentfor2024_0.png","tag":["Tech"],"readingTime":4},{"title":"React Native 업그레이드 최신 버전iOS에 대한 포괄적 안내","description":"","date":"2024-05-16 03:30","slug":"2024-05-16-UpgradingReactNativeAComprehensiveGuidetotheLatestVersioniOS","content":"\n\n소개: 최신 React Native의 파워 언락하기\n\n모바일 앱 개발의 계속 변화하는 환경에서는 최신 동향을 따라가는 것이 중요합니다. React Native와 같은 프레임워크는 각 새로운 이터레이션마다 개발자에게 향상된 기능과 성능 향상을 제공하여 기술적 경계를 넓혀주고 있습니다. 이 안내서에서는 React Native를 최신 버전으로 업그레이드하는 중요한 과정을 탐구하여 모바일 프로젝트에 가능성을 열어 보겠습니다.\n\n그러니, 최신 버전으로의 업그레이드 경로를 따라가며 React Native 경험을 향상시키고 새로운 높이로 모바일 앱을 성장시키기 위해 준비를 해 보세요.\n\n왜 업그레이드해야 하는가?\n\n\n\nReact Native을 업그레이드하는 것은 그냥 최신 트렌드를 반영하는 것뿐만이 아니라, 앱 개발 프로세스와 최종 사용자 경험을 크게 향상시킬 수 있는 다양한 혜택을 누리는 것입니다. 다음은 React Native의 최신 버전으로 업그레이드하는 것이 중요한 몇 가지 이유입니다:\n\n- 성능 향상.\n- 버그 수정 및 안정성.\n- 보안 개선.\n- 새로운 기능에 대한 액세스.\n- 호환성 및 생태계 지원.\n- 커뮤니티 및 개발자 지원.\n\n요약하자면, React Native을 업그레이드하는 것은 단순히 기술적인 과제 이상으로, 당신의 앱의 미래에 대한 전략적 투자입니다. 성능, 안정성, 보안 및 기능의 최신 진보를 받아들여 사용자에게 기쁨을 주고, 참여를 높이고, 혼잡한 시장에서 차별화를 실현할 수 있는 우수한 앱 경험을 제공할 수 있습니다. 그러니 기다리지 마세요 - 지금 바로 React Native의 최신 버전으로 업그레이드하세요. 당신의 앱 - 그리고 사용자 - 가 놓친 일에 감사할 것입니다.\n\n준비: 원활한 업그레이드를 위한 준비\n\n\n\nReact Native를 업그레이드하는 과정에 바로 뛰어들기 전에, 프로젝트가 성공을 이루기 위한 기초 작업을 완비하고 있어야 합니다. React Native를 업그레이드하기 전 준비 단계에서 수행해야 할 주요 단계를 살펴보겠습니다:\n\n- 프로젝트를 백업하세요.\n- 릴리스 노트를 확인하세요. (https://github.com/react-native-community/releases)\n- 호환성 확인: 프로젝트가 React Native의 최신 버전과 호환되는지를 평가하세요. 새 버전과 호환되도록 할 필요가 있는 서드파티 라이브러리, 의존성 라이브러리 또는 사용자 지정 컴포넌트를 식별하세요.\n- 의존성 업데이트: 프로젝트가 서드파티 라이브러리나 의존성에 의존한다면, 최신 호환 버전으로 업데이트하세요. 이렇게 하면 호환성 문제를 방지하고 원활한 업그레이드 과정을 보장할 수 있습니다.\n- 롤백 전략 계획: 최선을 다하더라도 업그레이드 과정 중 문제가 발생할 수 있습니다. 필요 시 React Native의 이전 버전으로 빠르게 롤백할 수 있는 전략을 갖춰두어 다운타임을 최소화하고 리스크를 완화하세요.\n\nReact Native 업그레이드를 위한 단계별 안내\n\n이제 기초를 다지고 프로젝트를 업그레이드하기 위해 준비가 완료되었으므로, React Native를 최신 버전으로 원활하게 업그레이드하는 방법에 대해 구체적인 지침을 따라가 보세요.\n\n\n\nReact Native CLI를 업데이트해보세요:-\n\n```js\nnpm install -g react-native-cli\n```\n\n현재 버전을 확인해보세요:-\n\n```js\nreact-native --version\n```\n\n\n\nReact Native를 업그레이드해보세요:-\n\n```js\nnpx react-native upgrade\n\n\n이 명령어를 실행하면 구성 파일, 의존성 및 다른 필요한 변경 사항을 자동으로 업데이트하여 프로젝트 파일을 최신 React Native 버전과 일치시킵니다.\n\nReact Native 업그레이드 도우미를 검토하려면 여기를 방문하세요: https://react-native-community.github.io/upgrade-helper/.\n현재 React Native 버전 및 업그레이드하려는 버전(최신 버전)을 선택하세요. 이 사이트에서는 packages.json, pod 파일, info.plist, AppDelegate.mm, AppDelegate.h와 같은 몇 가지 파일에서 수행해야 할 모든 필요한 변경 사항을 보여줍니다.\n\n\n\n\n![Upgrading React Native - A Comprehensive Guide to the Latest Version iOS - Step 0](/assets/img/2024-05-16-UpgradingReactNativeAComprehensiveGuidetotheLatestVersioniOS_0.png)\n\n![Upgrading React Native - A Comprehensive Guide to the Latest Version iOS - Step 1](/assets/img/2024-05-16-UpgradingReactNativeAComprehensiveGuidetotheLatestVersioniOS_1.png)\n\nConflict Resolution: During the upgrade process, conflicts or merge errors may occur, particularly if you've customized your project files. Resolve conflicts manually by carefully reviewing the changes and selecting which version to retain.\n\nUpdate Dependencies: Post React Native upgrade, examine your project's dependencies in the package.json file to ensure they align with the latest version. Utilize npm or yarn to update any outdated dependencies to their current versions.\n```\n\n\n\nCocoaPods를 업데이트하세요:- 패키지를 업데이트한 후에는 아래의 명령어를 사용하여 CocoaPods 의존성을 업데이트하는 것을 잊지 마세요:\n\n```js\ncd ios\npod install\n```\n\n테스트 실행하기: 업그레이드 과정이 완료되고 모든 의존성이 업데이트된 후에는 앱이 예상대로 작동하는지 확인하기 위해 앱을 철저히 테스트하는 것이 중요합니다. UI 구성요소, 네비게이션, API 통합 및 사용자 정의 기능을 포함한 모든 중요한 기능을 테스트해보세요.\n\n호환성 문제 수정하기: 테스트 중 호환성 문제나 오류가 발생하면 React Native 문서, 커뮤니티 포럼 또는 관련 GitHub 이슈를 참조하여 즉시 해결하세요. 필요한 코드 변경이나 업데이트를 수행하여 이러한 문제를 해결하세요.\n\n\n\n## 일반적인 도전 과제와 해결책.\n\nReact Native를 업그레이드하면 다양한 혜택을 누릴 수 있지만, 그 과정에서 도전 과제를 마주칠 수 있는 것은 흔한 일입니다. 이러한 도전 과제는 답답할 수 있지만 적절한 방법으로 해결할 수 있습니다. 여기 한 가지 일반적인 도전 과제와 그 해결책이 있습니다:\n\n**도전 과제**: 업그레이드 후 앱 충돌\n\nReact Native를 업그레이드한 후에, 특히 시작할 때나 특정 기능에 접근할 때에 앱이 예기치 않게 충돌하는 경우가 있을 수 있습니다. 이는 호환되지 않는 종속성, 폐기된 API, 또는 설정이 누락된 것과 관련이 있을 수 있습니다.\n\n\n\n솔루션: AppDelegate 구성 확인\n\nReact Native를 업그레이드한 후 앱이 충돌하는 일반적인 원인 중 하나는 AppDelegate 파일에서 빠진 부분이나 잘못된 구성입니다. 특히 서드 파티 라이브러리나 네이티브 모듈을 통합할 때 중요한 구성을 간과하는 경우가 많습니다. 프로토콜 선언이나 델리게이트 할당과 같은 중요한 구성을 간과하면 런타임 오류나 충돌이 발생할 수 있습니다.\n\n이 문제를 해결하려면 AppDelegate 파일을 주의 깊게 검토하고 모든 필요한 구성이 존재하고 올바르게 설정되어 있는지 확인하세요. 특히, 서드 파티 라이브러리나 네이티브 모듈에서 필요한 프로토콜이나 델리게이트에 주의를 기울이세요.\n\n예를 들어, OAuth 인증을 위해 RNAppAuth 라이브러리를 사용하고 있다면, AppDelegate 인터페이스에 RNAppAuthAuthorizationFlowManagerDelegate 프로토콜이 선언되어 있는지 아래와 같이 표시되어 있는지 확인하세요:\n\n\n```c\n#import \u003cReact/RCTBridgeDelegate.h\u003e\n#import \u003cUIKit/UIKit.h\u003e\n#import \"RNAppAuthAuthorizationFlowManager.h\"\n\n@interface AppDelegate : UIResponder \u003cUIApplicationDelegate, RCTBridgeDelegate, RNAppAuthAuthorizationFlowManager\u003e\n\n@property (nonatomic, strong) UIWindow *window;\n@property(nonatomic, weak)id\u003cRNAppAuthAuthorizationFlowManagerDelegate\u003eauthorizationFlowManagerDelegate;\n\n@end\n```\n\n모든 필수 구성이 완벽하게 되어 있는지 확인하여 앱 충돌을 최소화하고 React Native 업그레이드 후에 더 부드러운 전환을 보장할 수 있습니다.\n\n중요한 점은 철저한 테스트와 세부 사항에 신경을 쓰는 것입니다. 업그레이드 프로세스 중 잠재적인 문제를 식별하고 해결하기 위해 문서, 커뮤니티 포럼 또는 관련 GitHub 저장소를 참고하여 앱 충돌 또는 다른 문제 해결 시 지원받을 수 있습니다.\n\nReact Native 업그레이드는 단순한 기술 작업에 그치는 것이 아닙니다. 혁신, 최적화 및 지속적인 개선에 대한 우리의 헌신의 증명입니다. React Native의 최신 발전을 따라가면서, 더욱 빠르고 신뢰성이 높으며 기능이 풍부한 앱을 만들 수 있는 능력을 키웁니다.\n\n\n\n\n테이블 태그를 Markdown 형식으로 변경해주세요.","ogImage":{"url":"/assets/img/2024-05-16-UpgradingReactNativeAComprehensiveGuidetotheLatestVersioniOS_0.png"},"coverImage":"/assets/img/2024-05-16-UpgradingReactNativeAComprehensiveGuidetotheLatestVersioniOS_0.png","tag":["Tech"],"readingTime":5},{"title":"플러터 최신 소식 요약 - Google IO 2024","description":"","date":"2024-05-16 03:29","slug":"2024-05-16-WhatsnewinFlutterRecapGoogleIO2024","content":"\n\n최신 플러터 혁신과 개발 탐험 중\n\n![](/assets/img/2024-05-16-WhatsnewinFlutterRecapGoogleIO2024_0.png)\n\n## 올해의 구글 I/O는 구글이 많은 흥미로운 뉴스를 공개하며 붐빴습니다. 인공지능은 구글 Workspace, Photos, 그리고 Cloud와 같은 팬들이 좋아하는 제품들에서 최신 기술을 자랑하며 관중을 매료시켰습니다. 그리고 플러터 개발자들에게는 어떤 소식이 있을까요? 앱을 만드는 모험을 더욱 즐겁게 만들어줄 멋진 업데이트가 있었다고 말씀드릴게요. 구글 I/O의 하이라이트를 알아보러 함께해요! 🚀\n\n# Flutter 3.22와 Dart 3.4\n\n\n\n![image](/assets/img/2024-05-16-WhatsnewinFlutterRecapGoogleIO2024_1.png)\n\nFlutter 3.22과 Dart 3.4가 출시되어 Flutter 커뮤니티에 웅장한 파도가 밀려왔습니다. 성능 향상과 플랫폼별 세련된 개선으로, 개발자들은 더 부드러운 시각적 경험, 향상된 탐색 및 확장된 수익 옵션을 기대할 수 있습니다.\n\n# AI 발전\n\nGoogle의 AI에 대한 강력한 헌신이 Google I/O에서 명백히 드러났으며, AI 기반 기능과 견고한 보안 조치의 발전을 강조하는 발표가 있었습니다. 플러터를 사용하는 세계적인 기업들의 주목할 만한 성공 사례는 플러터의 인기와 다재다능성이 높아지고 있다는 것을 보여줍니다.\n\n\n\n\n# 웹어셈블리 지원\n\n플러터의 안정 버전에서 웹어셈블리 (Wasm)을 지원하며, 웹에서 네이티브 수준의 성능을 제공하여 우리가 플랫폼 간에 네이티브 수준의 성능을 전달하는 목표에 한 걸음 더 다가갈 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*JPFkftr0XrFTo1zLm8U3WQ.gif)\n\n# Dart 매크로\n\n\n\nJsonCodable은 개발 프로세스를 간소화하는 새로운 Dart 매크로로, JSON 직렬화 및 데이터 클래스 관리와 같은 작업에 대해 더 나은 옵션을 제공합니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*SKQ_Br2Al0WLRm13C5Od9A.gif)\n\n- 유니버설 스튜디오 Destinations \u0026 Experiences은 할리우드, 오사카, 올랜도 공원용 새로운 Flutter 모바일 앱을 출시했습니다.\n- LG는 웹OS를 개선하기 위해 Flutter를 선택했습니다. 2025년까지 Flutter는 전 세계 수백만 대의 LG TV에서 시스템 앱을 구동할 것입니다.\n- Dart 또는 Flutter 앱에서 Gemini API를 사용하여 AI 기반 기능을 구현하는 Vertex AI for Firebase Dart SDK를 미리 보실 수 있습니다.\n- 안드로이드의 예측 백 제스처는 이제 Flutter 앱 내에서 탐색하거나 다른 앱 또는 홈 화면으로 이동할 때 모두 지원됩니다.\n- iOS의 플랫폼 뷰는 성능을 최적화하여 CPU 사용량을 최대 50% 줄였습니다.\n- DevTools에는 안드로이드 딥 링크 구성에서 오류를 식별하고 해결하는 데 도움이 되는 새로운 딥 링크 유효성 검사기가 추가되어 웹 경험을 Flutter 앱에 더 쉽게 연결할 수 있습니다.\n- DevTools는 이제 타임라인에서 고급 필터링과 CPU 샘플을 지원합니다.\n\n이처럼 Flutter로 탐험할 것이 많습니다. 전 세계 개발자들에게 영감을 주는 Flutter를 확인해보세요. 최신 업데이트와 혁신에 대한 자세한 내용은 자세한 요약을 확인하세요!\n\n\n\n요약하자면, 올해의 Google I/O는 AI가 중심이 되며 플러터 개발자들이 더 많은 기대를 갖고 있던 다양한 업데이트와 혁신이 소개되었습니다. 구글은 Google Workspace, 사진 및 클라우드를 포함한 제품들에서 AI의 중요한 발전을 공개했지만, 플러터 개발자들은 AI 측면에서 더 많은 기능을 기대하고 있었습니다. 그러나 Flutter 3.22와 Dart 3.4의 출시로 커뮤니티에 흥분이 불어왔으며, 성능 향상, 플랫폼별 세부 조정 및 WebAssembly 지원 및 Dart 매크로와 같은 새로운 도구가 제공되었습니다. Flutter가 전 세계 개발자들을 촉진하는 동안 앱 개발의 끊임없이 진화하는 풍경에서 탐험하고 기대할 만한 것이 많이 있습니다.\n\n오늘 Google I/O에서 발표된 가장 좋아하는 기능은 무엇인가요?\n\n읽어 주셔서 감사합니다. 앞으로도 서브스택(substack)에서 팔로우해 주시기 바랍니다.","ogImage":{"url":"/assets/img/2024-05-16-WhatsnewinFlutterRecapGoogleIO2024_0.png"},"coverImage":"/assets/img/2024-05-16-WhatsnewinFlutterRecapGoogleIO2024_0.png","tag":["Tech"],"readingTime":3},{"title":"45초 안에 이해하는 더미를 위한 빅 오 표기법","description":"","date":"2024-05-16 03:27","slug":"2024-05-16-BigONotationForDummiesIn45Seconds","content":"\n\n![image](/assets/img/2024-05-16-BigONotationForDummiesIn45Seconds_0.png)\n\n소프트웨어 엔지니어링 직무를 위한 기술 코딩 면접에 도전한다면 이것을 알아야 합니다.\n\n면접관이 당신에게 문제를 해결하는 코드를 작성하라고 요청할 때, 당신이 솔루션을 코딩한 후, 그는 다음과 같은 질문을 할 수 있습니다:\n\n- 당신의 솔루션의 시간 복잡도는 무엇인가요?\n- 당신의 솔루션은 얼마나 효율적인가요 (또는 시간 효율적인가요)?\n- 당신의 솔루션의 Big O는 무엇인가요?\n\n\n\n주의 — 이 모든 질문들은 대략 동일한 내용을 다룹니다.\n\n## 시간 복잡도/시간 효율성의 의미\n\n일반적으로 알고리즘/함수의 시간 복잡도 또는 시간 효율성은 실행 속도를 나타냅니다.\n\n더 구체적으로 말하면, 주어진 입력 크기 N에 대해, 시간 복잡도/시간 효율성은 알고리즘/함수가 실행되기 위해 필요한 일반적인 반복 횟수를 나타냅니다.\n\n\n\n# 빅 오 표기법은 일반적으로 시간 복잡성/시간 효율성을 측정하는 데 사용됩니다.\n\n참고 — 우리는 반복의 정확한 횟수에 대해 정확히 신경 쓰지 않습니다. 우리가 신경 쓰는 것은 입력 N이 커질수록 일반적인 반복 횟수가 얼마나 증가하는지입니다.\n\n가장 일반적으로 사용되는 빅 오 시간 복잡성은 다음과 같습니다:\n\n- O(1) → 상수 시간 (가장 시간 효율적)\n- O(log n) → 로그 시간\n- O(n) → 선형 시간\n- O(n²) → 다항식 시간\n- O(2^n) → 지수 시간\n- O(n!) → 팩토리얼 시간 (가장 시간 효율적이지 않음)\n\n\n\n# 이들이 의미하는 것 (일반적으로)\n\nO(1) 또는 상수 시간 (최상의 효율성)\n\n- N이 무엇이든 간에 알고리즘은 항상 1단계를 거침\n- N이 1이면 알고리즘은 1단계를 밟음\n- N이 10이면 알고리즘은 여전히 1단계를 밟음\n- N이 1000이면 알고리즘은 여전히 1단계를 밟음\n- 일반적인 사용 사례 — 사전에서 값에 액세스, 단일 작업\n\nO(log n) 또는 로그 시간 (로그의 밑을 2로 가정)\n\n\n\n- 반복 횟수는 N에 대해 로그함수적으로 증가합니다.\n- N이 4일 때, 우리 알고리즘은 2단계가 걸립니다.\n- N이 8일 때, 우리 알고리즘은 3단계가 걸립니다.\n- N이 16일 때, 우리 알고리즘은 4단계가 걸립니다.\n- N이 32일 때, 우리 알고리즘은 5단계가 걸립니다.\n- 일반적인 사용 사례 — 이진 탐색\n\nO(n) 또는 선형 시간\n\n- 반복 횟수는 N에 대해 선형적으로 증가합니다.\n- N이 4일 때, 우리 알고리즘은 4단계가 걸립니다.\n- N이 8일 때, 우리 알고리즘은 8단계가 걸립니다.\n- N이 32일 때, 우리 알고리즘은 32단계가 걸립니다.\n- 일반적인 사용 사례 — for 루프를 이용해 리스트를 반복하는 경우\n\nO(n²) 또는 다항 시간\n\n\n\n- 반복 횟수는 대략적으로 n²이 됩니다.\n- N이 4일 경우, 우리 알고리즘은 16단계가 걸립니다.\n- N이 8일 경우, 우리 알고리즘은 64단계가 걸립니다.\n- N이 32일 경우, 우리 알고리즘은 1024단계가 걸립니다.\n- 일반적인 사용 사례 — 중첩된 for 루프\n\nO(2^n) 또는 지수 시간 (이 효율성이 끔찍해요)\n\n- 반복 횟수는 N과 지수적으로 증가합니다.\n- N이 4일 경우, 우리 알고리즘은 2⁴ 단계 걸립니다 (그건 16이에요).\n- N이 8일 경우, 우리 알고리즘은 2⁸ 단계 걸립니다 (그건 256이에요).\n- N이 32일 경우, 우리 알고리즘은 2³² 단계 걸립니다 (그건 4294967296이에요).\n- 알고리즘이 지수 시간이 걸린다면, 효율적인 방법을 찾아보아야 할 수도 있어요.\n\nO(n!) 또는 계승 시간 (절대적으로 효율성이 끔찍해요)\n\n\n\n- 반복 횟수는 N에 팩토리얼적으로 증가합니다.\n- 만약 N이 4이면, 우리의 알고리즘은 4! 단계를 거칩니다 (24 단계)\n- 만약 N이 8이면, 우리의 알고리즘은 8! 단계를 거칩니다 (40320 단계)\n- 만약 N이 32이면, 우리의 알고리즘은 32! 단계를 거칩니다 (아주 많은 단계)\n- 당신의 알고리즘은 결코 팩토리얼 효율성을 가져서는 안 됩니다.\n\n# 참고 - 여기서는 상수를 무시합니다\n\n우리는 일반적인 반복 횟수에만 관심이 있기 때문에, 상수에 대해서는 그다지 신경쓰지 않습니다. 그런데 이것들이 전체적인 흐름에 큰 영향을 미치지 않기 때문입니다.\n\n- O(1)은 O(2)나 O(20)과 동일합니다 — 우리는 이들 모두를 나타내기 위해 O(1)을 사용합니다\n- O(n)은 O(2n)이나 O(3n)과 동일합니다 — 우리는 이들 모두를 나타내기 위해 O(n)을 사용합니다\n- O(n²)은 O(n³)이나 O(n⁶)과 동일합니다 — 우리는 이들 모두를 나타내기 위해 O(n²)을 사용합니다\n- O(2^n)은 O(3^n)이나 O(7^n)과 동일합니다 — 패턴을 알 수 있겠죠?\n\n\n\n# 빠른 예시\n\n```python\ndef test(n):\n    return n + 1\n\n# 전체 시간 복잡도: O(1)\n```\n\n^ n이 얼마나 커도, 우리 함수는 단지 한 단계를 수행합니다. 즉, 이 함수는 O(1)의 시간 복잡도를 갖습니다.\n\n# 또 다른 예시\n\n\n\n```python\ndef test(n):\n    for i in range(n):    # O(n)\n        print(i)   # O(1)\n\n# overall time complexity: O(n)\n```\n\n여기서는 range(n)을 통해 반복하는 for 루프를 사용하므로 이 for 루프 자체의 시간 복잡도는 O(n)입니다.\n\nprint(i) 문 자체는 O(1)입니다. 따라서 O(n)에 O(1)을 곱하더라도 여전히 O(n)이 되며, 전체 시간 복잡도는 O(n)입니다.\n\n# 또 다른 예시\n\n\n\n\n```js\ndef test(n):\n    for i in range(n):      # O(n)\n        for j in range(n):  # O(n)\n            print(i, j)     # O(1)\n\n# overall time complexity: O(n^2)\n```\n\n^ 여기에 중첩된 for 루프가 있습니다. 하나의 for 루프 안에 다른 for 루프가 있습니다.\n\nO(n)이 O(n)에 곱해지면 O(n²)가 되며, 이는 우리 알고리즘의 시간 복잡성을 다항 시간인 O(n²)로 만듭니다.\n\n# 결론\n\n\n\n이해하기 쉽고 명확했길 바랍니다\n\n## 제작자로서 저를 지원하고 싶다면\n\n- 이 이야기에 대해 50번 박수를 치세요.\n- 생각을 나눠주세요.\n- 이야기에서 가장 좋아하는 부분을 강조해주세요.\n\n감사합니다! 이 작은 동작들이 큰 도움이 되고, 정말 감사합니다!\n\n\n\nYouTube: [https://www.youtube.com/@zlliu246](https://www.youtube.com/@zlliu246)\n\nLinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)\n\nMy Ebooks: [https://zlliu.co/ebooks](https://zlliu.co/ebooks)","ogImage":{"url":"/assets/img/2024-05-16-BigONotationForDummiesIn45Seconds_0.png"},"coverImage":"/assets/img/2024-05-16-BigONotationForDummiesIn45Seconds_0.png","tag":["Tech"],"readingTime":4}],"page":"89","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"89"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>