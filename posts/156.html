<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/156" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/156" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Zustand vs. Redux: 상태 관리 어떤 것을 사용해야할까? 비교 정리" href="/post/2024-05-01-ZustandvsReduxAComprehensiveComparisoninStateManagement"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Zustand vs. Redux: 상태 관리 어떤 것을 사용해야할까? 비교 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-ZustandvsReduxAComprehensiveComparisoninStateManagement_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Zustand vs. Redux: 상태 관리 어떤 것을 사용해야할까? 비교 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Zustand vs. Redux: 상태 관리 어떤 것을 사용해야할까? 비교 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년 최고의 React 보일러플레이트 소개" href="/post/2024-05-01-TopReactBoilerplates2024completeresearch"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 최고의 React 보일러플레이트 소개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 최고의 React 보일러플레이트 소개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024년 최고의 React 보일러플레이트 소개</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Hook Form과 Zod, MUI로 React Form 만들기" href="/post/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Hook Form과 Zod, MUI로 React Form 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Hook Form과 Zod, MUI로 React Form 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Hook Form과 Zod, MUI로 React Form 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NextJS 앱에 JWT 인증 추가하는 방법(2024년 최신)" href="/post/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NextJS 앱에 JWT 인증 추가하는 방법(2024년 최신)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NextJS 앱에 JWT 인증 추가하는 방법(2024년 최신)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NextJS 앱에 JWT 인증 추가하는 방법(2024년 최신)</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 앱을 만들 때 유용한 공짜 API들" href="/post/2024-05-01-APIstoUseforCreatingReactApp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 앱을 만들 때 유용한 공짜 API들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-APIstoUseforCreatingReactApp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 앱을 만들 때 유용한 공짜 API들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 앱을 만들 때 유용한 공짜 API들</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ReactJS와 Firebase를 사용하여 사용자 로그인 및 가입 구현하기(2024년)" href="/post/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ReactJS와 Firebase를 사용하여 사용자 로그인 및 가입 구현하기(2024년)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ReactJS와 Firebase를 사용하여 사용자 로그인 및 가입 구현하기(2024년)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ReactJS와 Firebase를 사용하여 사용자 로그인 및 가입 구현하기(2024년)</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Webpack에 대한 Fallback 구축 방법 -  Module not found Error" href="/post/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Webpack에 대한 Fallback 구축 방법 -  Module not found Error" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Webpack에 대한 Fallback 구축 방법 -  Module not found Error" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Webpack에 대한 Fallback 구축 방법 -  Module not found Error</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Socket.io, React.js, Node.js 및 Express.js를 사용한 실시간 애플리케이션 만들기" href="/post/2024-05-01-BuildingReal-TimeApplicationswithSocketioReactjsNodejsandExpressjsAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Socket.io, React.js, Node.js 및 Express.js를 사용한 실시간 애플리케이션 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-BuildingReal-TimeApplicationswithSocketioReactjsNodejsandExpressjsAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Socket.io, React.js, Node.js 및 Express.js를 사용한 실시간 애플리케이션 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Socket.io, React.js, Node.js 및 Express.js를 사용한 실시간 애플리케이션 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 라우터 기초 내용 정리" href="/post/2024-05-01-ReactRouterNavigateYourAppswithEase"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 라우터 기초 내용 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-ReactRouterNavigateYourAppswithEase_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 라우터 기초 내용 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 라우터 기초 내용 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 19 Beta 릴리스, 새로운 기능 소개 및 정리" href="/post/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 19 Beta 릴리스, 새로운 기능 소개 및 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 19 Beta 릴리스, 새로운 기능 소개 및 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 19 Beta 릴리스, 새로운 기능 소개 및 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/141">141</a><a class="link" href="/posts/142">142</a><a class="link" href="/posts/143">143</a><a class="link" href="/posts/144">144</a><a class="link" href="/posts/145">145</a><a class="link" href="/posts/146">146</a><a class="link" href="/posts/147">147</a><a class="link" href="/posts/148">148</a><a class="link" href="/posts/149">149</a><a class="link" href="/posts/150">150</a><a class="link" href="/posts/151">151</a><a class="link" href="/posts/152">152</a><a class="link" href="/posts/153">153</a><a class="link" href="/posts/154">154</a><a class="link" href="/posts/155">155</a><a class="link posts_-active__YVJEi" href="/posts/156">156</a><a class="link" href="/posts/157">157</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Zustand vs. Redux: 상태 관리 어떤 것을 사용해야할까? 비교 정리","description":"","date":"2024-05-01 18:02","slug":"2024-05-01-ZustandvsReduxAComprehensiveComparisoninStateManagement","content":"\n\n![이미지](/assets/img/2024-05-01-ZustandvsReduxAComprehensiveComparisoninStateManagement_0.png)\n\n현재 웹 개발에서 상태 관리는 응용 프로그램의 성능, 확장성 및 유지 관리성에 직접적인 영향을 미치는 중요한 측면입니다. 전통적으로 Redux는 React 애플리케이션에서 상태를 관리하는 데 사용되는 주요 라이브러리였습니다. 그러나 최근에 Zustand가 경쟁 대상으로 등장하여 더 간단하고 효율적인 대안을 제공하고 있습니다. 이 문서에서는 많은 개발자들이 Zustand를 Redux보다 더 나은 상태 관리 시스템으로 여기는 이유를 살펴볼 것입니다.\n\n# 1. 간결함과 크기\n\nRedux는 강력하지만 그 힘은 복잡성과 함께 옵니다. 액션, 리듀서 및 저장소 설정이 필요하며, 이는 초보자에겐 압도적일 수 있습니다. 반면 Zustand는 최소주의 방법을 취합니다. 복잡한 설정 없이 상태 관리를 제공하는 단일 훅입니다. 이 간결함은 Zustand를 접근하기 쉽게 만들어주며, 특히 작은 프로젝트나 상태 관리에 새로운 개발자들에게 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRedux의 크기는 성능이 중요한 웹 애플리케이션에서도 고려해야 할 사항일 수 있습니다. 그것은 광범위한 기능 세트로 인해 상당한 번들 크기를 가지고 있습니다. 무게가 가벼운 Zustand(압축 후 1KB 미만)는 번들 크기를 유지하는 데 도움을 주어 로드 시간을 단축하고 성능을 향상시킵니다.\n\n# 2. 불변성이 쉬워집니다\n\nRedux는 예측 가능한 상태 변경을 위한 좋은 사례인 불변성을 강제합니다. 그러나 이를 달성하기 위해 종종 많은 보일러플레이트 코드가 필요합니다. Zustand는 React의 useReducer와 useState 훅과 통합되어 상태를 직접 변경할 수 있도록 하여 불변성을 간소화합니다. 이는 완전히 불변성을 포기해야 한다는 뜻은 아니지만 Zustand는 상태 변경을 처리하는 보다 편리한 방법을 제공합니다.\n\n# 3. 편리한 API\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZustand API는 React 개발자들에게 자연스러운 느낌을 제공하도록 설계되었습니다. 스토어를 정의할 때 간단한 create 함수와 상태에 액세스하기 위한 hook을 제공합니다.\n\n다음은 기본적인 예시입니다:\n\n```js\nimport create from 'zustand';\nconst useCountStore = create((set) =\u003e ({\n  count: 0,\n  increment: () =\u003e set((state) =\u003e ({ count: state.count + 1 })),\n  decrement: () =\u003e set((state) =\u003e ({ count: state.count - 1 })),\n}));\n\nfunction Counter() {\n  const count = useCountStore((state) =\u003e state.count);\n  const increment = useCountStore((state) =\u003e state.increment);\n  const decrement = useCountStore((state) =\u003e state.decrement);\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003eCount: {count}\u003c/p\u003e\n      \u003cbutton onClick={increment}\u003eIncrement\u003c/button\u003e\n      \u003cbutton onClick={decrement}\u003eDecrement\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n이 API는 직관적이고 간결하여 Zustand를 사용하기 쉽게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. 성능 최적화\n\nZustand은 React의 컨텍스트와 후크를 활용하여 다시 렌더링을 최적화합니다. React의 내장된 메모이제이션 덕분에 변경된 특정 상태를 사용하는 컴포넌트만 다시 렌더링됩니다. 이는 때로는 불필요한 업데이트가 발생할 수 있는 Redux와 비교해 적은 수의 다시 렌더링을 가져올 수 있습니다.\n\n# 5. 개발 도구 통합\n\nRedux는 디버깅에 매우 유용한 개발자 도구 생태계를 갖추고 있습니다. Zustand은 Redux와 같이 전용 개발 도구 확장 기능을 갖추고 있지 않지만, Redux DevTools 또는 React DevTools와 같은 인기있는 개발 도구와 통합할 수 있습니다. 이를 통해 Redux와 동일하게 Zustand 스토어를 검사하고 타임 트래블 디버깅할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 6. React Concurrent Mode 호환성\n\nReact Concurrent Mode의 등장으로, Zustand는 이와 원활하게 작업할 수 있습니다. Concurrent Mode는 React 애플리케이션의 성능과 반응성을 향상시키기 위해 설계되었으며, Zustand의 가벼운 성격은 이 목표와 잘 맞습니다.\n\n## 7. 커뮤니티 및 채택\n\nRedux는 오랜 기간동안 존재하며 방대한 커뮤니티와 생태계를 갖추고 있습니다. 대규모 및 복잡한 애플리케이션에 유리할 수 있습니다. 그러나 Zustand의 커뮤니티는 꾸준히 성장하고 있으며, 그 간결함과 사용 편의성으로 더 많은 개발자들을 끌어들이고 있어 새로운 프로젝트에 유망한 선택지가 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n종합적으로, Zustand와 Redux는 둘 다 가능성 있는 상태 관리 라이브러리이지만, 그 적합성은 프로젝트 요구사항과 팀원들의 익숙함에 따라 다릅니다. Zustand는 간결함, 크기, 그리고 사용 편의성 측면에서 빛을 발하며, 이는 작거나 중간 규모의 프로젝트나 복잡하지 않은 상태 관리 솔루션을 선호하는 개발자들에겐 탁월한 선택이 될 수 있습니다. Redux는 광범위한 생태계와 도구들을 갖추고 있어, 복잡한 상태 관리가 필요한 대규모 애플리케이션에는 여전히 견고한 선택이 될 것입니다. 결국, Zustand와 Redux 사이의 선택은 프로젝트의 구체적인 요구사항과 제약 사항에 기반하여 이루어져야 합니다.","ogImage":{"url":"/assets/img/2024-05-01-ZustandvsReduxAComprehensiveComparisoninStateManagement_0.png"},"coverImage":"/assets/img/2024-05-01-ZustandvsReduxAComprehensiveComparisoninStateManagement_0.png","tag":["Tech"],"readingTime":4},{"title":"2024년 최고의 React 보일러플레이트 소개","description":"","date":"2024-05-01 17:59","slug":"2024-05-01-TopReactBoilerplates2024completeresearch","content":"\n\n\n![React](/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_0.png)\n\n# 웹 프레임워크 선택 문제\n\n요즘 React는 시대를 앞서가는 인터페이스 프레임워크 중 하나로 자리매김했습니다. 2023년 설문조사에 따르면 전 세계 개발자 중 40.58%가 React.js를 사용하고 있어 가장 인기 있는 웹 프레임워크 중 하나로 떠올랐습니다. Facebook에서 개발된 React.js는 PayPal, Uber, Instagram, Airbnb와 같은 주요 기업들이 사용하여 사용자 인터페이스를 강화하고 있습니다. 확실히 React는 생산성, 구성 요소 기반 아키텍처 및 선언적 구문의 조합으로, 널리 사용되고 강력한 커뮤니티 지원을 받고 있습니다. 이는 개발자들이 이전보다 더 많은 프로젝트를 React로 구축하고 있다는 것을 의미합니다.\n\nReact 라이브러리는 의견을 가지지 않는 설계로, '맨 처음에' 정의되고 구성 요소를 관리하는 핵심 기능 이외에는 실제로 거의 어떤 추가 기능도 포함하지 않습니다. 따라서 프로퍼티 전달, 구성 요소 분해, React 응용 프로그램 파일 구조화, 전체 응용 프로그램 규모 확장 및 기타 세부 사항에 대한 최상의 방법을 알지 못하는 경우 쉽게 혼동할 수 있습니다. 이러한 함정은 내장 함수 및 구성 요소를 포함하여 개발 프로세스를 최적화하고 개발자가 초기 설정 및 구성 처리에 시간을 허비하는 대신 응용 프로그램 로직을 구축하는 데 집중할 수 있도록 하는 보일러플레이트를 사용하여 피할 수 있습니다. 다시 말해, 응용 프로그램 개발을 시작하는 표준화된 기점 역할을 합니다. GitHub에서 'react-boilerplate'을 검색하면 현재 44.8k 저장소가 나옵니다. 개발용으로 선택할 템플릿을 결정할 때, 자신의 응용 프로그램에 해당하고 확장성과 향후 유지 관리에 좋은 것을 선택하는 문제가 생깁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# React 보일러플레이트 유형\n\n과거에는 React 프로젝트를 시작하는 가장 일반적인 방법은 create-react-app (CRA)이었습니다 — 이는 Facebook에서 인기 있는 공식 보일러플레이트였습니다. 그러나 2023년 3월 16일에 발표된 새로운 React 문서에서는 더 이상 CRA를 React 프로그램을 만드는 최적의 해결책으로 권장하지 않습니다. 대안을 고려하고 비교하여 프로젝트를 시작하는 가장 좋은 방법을 결정해봅시다.\n\nReact 보일러플레이트의 다양한 측면을 탐구함으로써, 어떤 기준으로 나눌 수 있는지 살펴보겠습니다:\n\n라이브러리와 설정:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 미니멀리즘 보일러플레이트: React 프로젝트를 위한 기본 구성을 제공하며, Webpack, Babel, ESLint 등의 기본 설정을 포함합니다. 개발자가 필요에 따라 특정 라이브러리와 기능을 추가할 것으로 가정합니다. 대부분의 보일러플레이트가 이 범주에 속합니다.\n- 기능이 풍부한 보일러플레이트: 미리 구성된 추가 라이브러리와 도구를 포함합니다. 상태 관리(예: Redux), 라우팅(React Router), 테스팅 등을 포함할 수 있으며, 기본 UI 구성 요소와 페이지를 포함할 수도 있어 개발 속도를 높여 공통 UI 요소와 레이아웃을 제공합니다.\n\n인증 및 등록:\n\n- 인증 및 등록을 위한 보일러플레이트: 로그인, 가입, 사용자 세션을 위한 컴포넌트를 포함합니다.\n- 인증 없는 보일러플레이트: 인증 구현을 개발자에게 맡깁니다.\n\n풀 스택 vs. 프론트엔드 전용:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 풀 스택 보일러플레이트: React를 사용한 프론트엔드와 백엔드를 모두 다루는 웹 애플리케이션을 구축하기 위한 종합적인 솔루션을 제공합니다.\n- 프론트엔드 전용 보일러플레이트: 주로 React 인터페이스에 초점을 맞춥니다. 개발자가 원하는 서버와 통합해야 합니다.\n\nUI 컴포넌트 라이브러리:\n\n- UI 컴포넌트가 포함된 보일러플레이트: 일관된 디자인 패턴(예: 버튼, 폼, 모달)을 준수하는 전체 UI 컴포넌트 세트가 포함되어 있습니다.\n- UI 컴포넌트가 없는 보일러플레이트: 개발자가 보일러플레이트를 사용하는 동안 컴포넌트를 완전히 개발해야 합니다.\n\n유료 vs. 무료:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 무료/오픈 소스 보일러플레이트: 사용에 제한이 없고 커뮤니티 지원이 있으며 종종 잘 유지보수됩니다.\n- 유료 보일러플레이트: 일부 상용 템플릿은 추가 기능, 프리미엄 지원 또는 확장된 기능을 제공합니다.\n\n위 분류에 따라 가장 인기 있는 React 보일러플레이트는 Vite, Create React App (CRA), Create Next App, Razzle 등이 있으며 React로 개발을 시작하는 데 필요한 기본 라이브러리와 구성만 포함하고 있습니다 (최소한의 보일러플레이트).\n\n# React 템플릿 선택 기준\n\n개발 중에 사용할 보일러플레이트를 결정하는 것은 그냥 애플리케이션을 만드는 것만큼이나 그 이후에 스케일링 및 유지보수하는 것과 관련이 있기 때문에 꽤 어려울 수 있습니다. 그래서 기존 보일러플레이트의 다양성에서 적절한 솔루션을 선택하고 일반적으로 어떻게 선택해야 하는 지 어떻게 결정할 수 있을까요? 프로젝트를 시작할 보일러플레이트를 선택할 때 주의를 기울여야 할 핵심 포인트는 다음과 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 지원 및 유지보수 옵션: 프로젝트는 정기적으로 업데이트되나요?\n- 성능 점수\n- 코드 품질 (구조의 청결성, 확장 가능성, 코드 구성)\n- 제품 준비 상태: 프로젝트가 현재 제품 사용에 준비되었나요?\n- 인증, 라우팅, 국제화, 폼 처리, 테스팅, 기본 페이지 및 UI 구성 요소와 같은 기능의 가용성 — 목록은 계속될 수 있지만, 프로젝트 구현에 필요한 기능을 결정하고 뼈대에 찾으시면 됩니다.\n\n# 프로젝트 구조화 도구\n\nReact 애플리케이션을 개발하는 초기 단계는 일반적으로 Vite, Create React App, Create Next App 또는 Razzle 중 하나를 기반으로 선택하는 것을 포함합니다. 이러한 도구들은 프로젝트 구조 설정, 빌드 도구 구성, 그리고 개발 서버 제공과 관련해 프레임워크 유사한 기능을 제공합니다.\n\nVite는 웹 개발에서 빠른 개발 서버와 워크플로우 속도를 중점으로 두고 있습니다. 개발 중에 자체 ES 모듈을 가져와 시작 시간을 빠르게 하여 속도를 높입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCreate React App (CRA)은 Webpack, Babel 및 기타 빌드 도구의 설정 복잡성을 감추어주어 개발자들이 React 코드 작성에 집중할 수 있도록 도와줍니다. 효율적인 개발을 위해 핫 모듈 리로딩과 같은 기능을 제공합니다.\n\nNext.js는 서버 사이드 렌더링 및 정적 웹 애플리케이션을 구축하기 위한 React 프레임워크입니다. Next.js 프로젝트를 합리적인 기본 설정으로 구성하며, 서버 사이드 렌더링(SSR), 파일 기반 라우팅, API 라우트와 같은 기능을 제공합니다.\n\nRazzle은 에어비앤비에서 만든 빌드 도구로, 서버 사이드 렌더링을 단순화합니다. Razzle은 서버 사이드 렌더링 설정 복잡성을 감추어주고, 다재다능한 자바스크립트 애플리케이션을 쉽게 만들 수 있도록 합니다. 코드 분할, CSS-in-JS, 핫 모듈 교체와 같은 기능을 지원하여, 서버 사이드 렌더링이 필요한 React 애플리케이션을 구축하기에 적합합니다.\n\n상기 언급된 빌드 도구들은 종종 React 보일러플레이트로 언급됩니다. 설정 복잡성을 감춰주고 기본 설정을 제공하며 빌드 워크플로우를 최적화하는 기능만 제공하기 때문에, 추가적인 기능을 포함하고 있지는 않고 매우 기능이 제한되어 있습니다. 따라서 위의 분류에 따라, 이러한 도구들을 미니멀리스틱 보일러플레이트로 분류합니다. 기본 템플릿으로 대표되는 이 도구들은 보다 기능이 풍부한 React 보일러플레이트를 만드는 데 탁월한 도구입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 선택된 보일러플레이트 표\n\n이제 우리는 라이선스 수수료를 부과하지 않거나 기능을 유료로 제공하지 않는 React 보일러플레이트를 고려하고 또한 최근 업데이트 날짜를 고려합니다 (6개월 이내). 이에 따라, 우리는 12가지 보일러플레이트를 고려했습니다*:\n\n* 2024년 4월 기준\n\n# 기능 별 보일러플레이트 비교\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 보일러플레이트를 사용하여 개발자들이 얻을 수 있는 기능을 자세히 살펴보고 고려해야 할 사항을 알아보겠습니다:\n\nAPI 통합: 특정 API 또는 서버 서비스와 통합하기 위한 구성을 포함한 템플릿이 있을 수 있습니다.\n\n상태 관리 솔루션: Redux, MobX, Recoil과 같은 옵션 또는 React의 내장 상태 관리. 또한 비동기 React Query를 무시하기 어렵습니다.\n\n테스트 설정: 미리 정의된 테스트 설정 또는 전혀 없는 것들도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인증 및 권한 부여: 사용자 인증 및 권한이 어떻게 정의되고 처리되는지, 특히 특정 인증 라이브러리와의 통합 여부가 명시되어 있는지 확인해주세요.\n\n국제화(i18n) 및 지역화(Localization): react-i18next나 react-intl과 같은 라이브러리를 사용하여 여러 언어를 지원할 수 있는 기능을 제공하는지 확인해주세요.\n\nESLint 규칙 준수: 코드 포맷팅 중에 문제를 감지하거나 수정하는 것뿐만 아니라 잠재적인 버그를 식별할 수 있도록 하는지 확인해주세요.\n\n스타일링 솔루션: CSS 모듈, styled-components 또는 UI 라이브러리를 사용하여 스타일드 컴포넌트를 쉽고 효율적으로 재사용할 수 있는 솔루션이 있는지 확인해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트의 타입 안전성: TypeScript를 사용하여 개발 중 정적 유형을 제공하며, 클래스 또는 모듈을 활용하여 더 확장 가능하고 신뢰할 수 있는 애플리케이션을 만듭니다.\n\n앱 테마 선택: 사용자가 기본 설정 또는 자동 설정에 따라 라이트와 다크 테마 사이에서 전환할 수 있도록 합니다.\n\n사전 제작된 폼 컴포넌트: 양식 전체에서 재사용되도록 의도된 컴포넌트를 제공하여 코드 중복을 줄이고 표준화를 촉진합니다. 내장된 유효성 검사와 오류 처리를 포함할 수도 있으며, 개발을 더 신뢰할 수 있게 합니다.\n\nUI 컴포넌트 라이브러리: 버튼 및 모달 창과 같은 사전 제작 및 사용자 정의 가능한 컴포넌트를 제공하여 개발자가 애플리케이션에 쉽게 통합할 수 있습니다. 이러한 요소를 처음부터 디자인하고 코딩하는 시간과 노력을 절약할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 각 보일러플레이트를 분석한 후 다음과 같은 표를 얻었습니다:\n\n# 표의 보일러플레이트 설명\n\nExtensive-react-boilerplate. 이 React 보일러플레이트는 모든 종류의 프로젝트를 위해 설계되었습니다. 이는 백엔드 보일러플레이트 nestjs-boilerplate과 완벽하게 호환되는 것뿐만 아니라 독립적인 솔루션으로도 동작하여 주요 장점 중 하나입니다. 이 템플릿은 다음과 같은 다양한 기능을 제공합니다:\n\n- 사용자 인증 및 권한 부여, 구글 또는 페이스북 계정 사용 가능.\n- 페이지의 공개 또는 비공개 액세스 설정.\n- 코드 효율성과 깨끗함을 높이기 위한 사용자 정의 규칙이 설정된 ESLint.\n- 작성된 코드의 신뢰성을 확보하기 위한 타입 안전성.\n- 사용자 정의 useLanguage hook을 사용한 프로젝트 로컬라이징.\n- E2E 테스트 지원.\n- 사용자의 선택에 따라 Light 또는 Dark Mode.\n- MUI를 기반으로 한 컨트롤 컴포넌트 라이브러리, 기본적으로 react-hook-form과 통합되어 있어 입력 필드를 컨트롤러에 연결하는 추가 시간을 소비할 필요가 없습니다.\n- React Query를 사용한 비동기 작업 처리를 위한 상태 관리.\n- 사용자 관리 기능 (CRUD).\n- dropzone 기능이 있는 아바타 선택 및 업로드 기능.\n- 향상된 애플리케이션 성능과 SEO 최적화를 위한 Next.js 프레임워크 (SSR) 지원.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 언급된 기능들을 보시면, 이 보일러플레이트는 프로젝트의 시작 시간을 크게 줄여줍니다 (대략 193시간), 고려할 가치가 있는 선택입니다.\n\n카테고리: 기능이 풍부한 보일러플레이트, 인증 및 등록이 포함된 보일러플레이트, 프론트엔드 전용 (그리고 완벽히 호환되는 백엔드 보일러플레이트도 있어서 풀 스택 보일러플레이트로 사용할 수 있음), 무료.\n\nReact-starter-kit. React를 기반으로 웹 애플리케이션을 만들기 위한 템플릿입니다. CSS-in-JS, Vitest, VSCode 설정, Cloudflare 지원, SSR과 같이 미리 구성된 세팅이 제공됩니다. 데이터베이스로는 Firestore 연결이 사용됩니다. Joy UI를 기반으로 한 툴바나 사이드바와 같은 몇 가지 UI 구성 요소가 구현되어 있습니다.\n\n카테고리: 기능이 풍부한 보일러플레이트, 인증 및 등록이 포함된 보일러플레이트, 프론트엔드 전용, 무료.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact-redux-saga-boilerplate. Redux를 사용하여 상태 관리를 하는 React 애플리케이션을 생성하는데 사용하는 스타터 프로젝트입니다. 유닛 및 엔드 투 엔드 테스트, react-helmet 지원하며, Emotion 라이브러리를 사용하여 CSS 스타일링을 간단하게 합니다. styled 기능을 사용하여 헤더나 푸터와 같은 사용자 정의 컴포넌트를 제공합니다.\n\n카테고리: 기능이 풍부한 보일러플레이트, 인증 없는 보일러플레이트, 프론트엔드 전용, 무료.\n\nNext-js-Boilerplate. 이 보일러플레이트는 유연한 코드 구조를 가지고 있어 필요한 기능을 선택하고 저장하기만 하면 됩니다. Tailwind CSS 통합, Clerk와의 인증 지원, SQLite, PostgreSQL, 그리고 MySQL 데이터베이스와 호환됩니다. 유닛 테스트는 Jest를 사용하며, Zod 라이브러리는 유효성 검사 스키마에 사용됩니다.\n\n카테고리: 기능이 풍부한 보일러플레이트, 인증 및 등록이 있는 보일러플레이트, 프론트엔드 전용, 무료.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라디안-리액트-템플릿. 이 보일러플레이트는 다국어 지원, 부드러운 애니메이션 및 JSON 파일에 모든 콘텐츠를 저장하여 React.js에 대한 사전 지식이 없어도 텍스트를 관리할 수 있도록 해줍니다. styled-components를 사용하여 HTML 엘리먼트를 스타일링한 자체 컴포넌트(버튼, 입력란, 텍스트영역 등) 세트를 포함하고 있습니다.\n\n카테고리: 기능이 풍부한 보일러플레이트, 인증 없는 보일러플레이트, 프론트엔드 전용, 무료.\n\n코어. Vite를 기반으로 빠른 프로젝트 생성 도구를 사용하여 개발된 현대적인 템플릿입니다. TypeScript를 지원하여 타입 안정성을 제공하며 ESLint, Prettier, CommitLint, Husky, Lint-Staged에 대한 좋은 구성을 포함하고 있습니다.\n\n카테고리: 최소주의 보일러플레이트, 인증 없는 보일러플레이트, 프론트엔드 전용, 무료.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNextjs-boilerplate. 이 React 보일러플레이트는 정적 페이지 생성을 위해 Next.js를 사용합니다. git 메시지 규칙을 지원하며, Plop를 사용하여 컴포넌트 생성을 지원하며, Tailwind CSS를 사용하여 스타일을 구성합니다. 컴포넌트 문서화를 위해 Storybook이 포함되어 있습니다.\n\n카테고리: 미니멀리즘 보일러플레이트, 인증 없는 보일러플레이트, 프론트엔드 전용, 무료.\n\nReact-pwa. 프로젝트를 처음부터 시작하기 위한 준비된 세트입니다. React 애플리케이션을 개발할 때 개발자들이 typicall하게 필요로 하는 핵심 라이브러리, 컴포넌트 및 유틸리티의 미니멀한 결합으로 구성되어 있습니다. 페이지의 오류 처리를 위한 자체 HOC가 포함되어 있으며, Vite를 기반으로 개발되었습니다.\n\n카테고리: 기능이 풍부한 보일러플레이트, 인증 없는 보일러플레이트, 프론트엔드 전용, 무료.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비타민. Tailwind CSS와 기본적인 스타일 리셋이 포함된 스타터 프로젝트로, Prettier 플러그인을 사용하여 자동으로 클래스를 정리합니다. Vitest, Testing Library, Cypress 등의 도구를 사용하여 테스트하지만, React UI 컴포넌트 라이브러리는 포함되어 있지 않습니다.\n\n카테고리: 미니멀리즘 보일러플레이트, 인증 없는 보일러플레이트, 프론트엔드 전용, 무료.\n\nNext-saas-stripe-starter. 이 보일러플레이트를 사용하면 Next.js, Prisma, Planetscale, Auth.js v5, Resend, React Email, Shadcn/ui, Stripe와 같은 기능을 추가하여 프로젝트 기능을 확장할 수 있습니다. Radix UI와 Tailwind CSS를 사용하여 구성된 컴포넌트 라이브러리가 포함되어 있습니다.\n\n카테고리: 기능 풍부한 보일러플레이트, 인증 및 등록이 포함된 보일러플레이트, 풀스택 보일러플레이트, 무료.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGatsby-starter-apple. 멋진 반응형 디자인을 갖춘 애플리케이션을 만들기 위한 템플릿으로, 모바일 메뉴에 애니메이션이 포함되어 있습니다. 사용된 컴포넌트들의 스타일링은 styled-components를 기반으로 합니다. 이 보일러플레이트는 검색 엔진 최적화를 잘 지원하며 RSS 피드 기능을 갖추고 있습니다.\n\n카테고리: 미니멀리스트 보일러플레이트, 인증 없는 보일러플레이트, 프론트엔드 전용, 무료.\n\nFullstack-typescript. 이 보일러플레이트는 프로젝트를 신속하게 시작하기 위한 풀스택 애플리케이션으로, Material UI를 기반으로 한 사용자 정의 컴포넌트 라이브러리를 갖추고 있습니다. 클라이언트-서버 통신에는 axios가 사용되며, Redux, MobX 등 특정 상태 관리 기술을 지원하지 않습니다.\n\n카테고리: 미니멀리스트 보일러플레이트, 인증 없는 보일러플레이트, 풀스택 보일러플레이트, 무료.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 일부 기능 구현 특이사항\n\n일반적으로, React 템플릿은 개발 프로세스의 속도를 높이고 표준화하기 위한 다양한 구현 기능을 제공합니다. 그 중에는 UI 컴포넌트 라이브러리와 스타일링, 상태 관리, 기본 ESLint 구성을 포괄하는 일반적인 접근 방식이 포함됩니다.\n\n## React UI 컴포넌트 라이브러리\n\nReact 보일러플레이트의 기능 구현은 주로 구성 요소가 재사용 가능하고 조합 가능하게 설계되어 있는 모듈화된 개발을 중심으로 진행됩니다. 현재 라이브러리를 분석하고 이 기사에 따르면, 다음은 가장 인기 있는 것들로 간주될 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_1.png)\n\n지금은 Material UI가 가장 인기 있는 라이브러리로 91.2k 개의 GitHub 스타와 매주 300만 회 이상의 다운로드가 있습니다. 반응형 웹 디자인(RWD) 기능 덕분에 응용 프로그램이 다양한 화면과 장치에 자동으로 적응할 수 있으므로 안심할 수 있습니다.\n\n## 스타일링 솔루션\n\nCSS 모듈, styled-components, 또는 Sass와 같은 스타일링 솔루션은 일반적으로 React 보일러플레이트에 포함되어 있습니다. 이들은 컴포넌트에 스타일을 적용하는 다양한 방법을 제공하여 유연성과 확장성을 유지하면서 컴포넌트 캡슐화를 유지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nstyled-components를 스타일링 솔루션으로 사용하는 장점:\n\n- 라이브러리가 페이지에 렌더링된 컴포넌트를 자동으로 추적하고 그 스타일만 적용합니다.\n- 스타일에 고유한 클래스 이름을 자동으로 생성하여 클래스 이름에 오류가 없도록 합니다.\n- 스타일이 특정 컴포넌트에 연결되어 CSS 자체를 쉽게 제거할 수 있습니다.\n- 코드에서 보이는 것처럼 손쉬운 동적 스타일링(bc-boilerplates에서 인스턴스 코드 아래 참고).\n\n![이미지](/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_2.png)\n\n5. 스타일링 중 컴포넌트의 동적 props를 사용합니다. 이를 통해 변수의 값에 따라 스타일이 업데이트되도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_3.png)\n\n6. 이를 통해 한 구성 요소에서 다른 구성 요소로 스타일을 재사용하거나 다른 구성 요소에 영향을 미칠 수 있습니다 (상위-하위 관계).\n\n![이미지](/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_4.png)\n\n## 상태 관리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상태 관리는 복잡한 애플리케이션에서 특히 확장성과 유지 보수성을 제공하는 중요한 요소입니다. 보통 상태 관리 도구를 선택할 때 Redux, MobX, Zustand이 떠오릅니다. 그러나 이들은 클라이언트 측 라이브러리이며, 비동기 데이터 저장과 같은 작업에 React Query와 비교했을 때 효율적이지 않을 수 있습니다.\n\nReact Query는 서버 상태 라이브러리입니다. 서버와 클라이언트 간 비동기 작업을 관리할 뿐만 아니라 React 및 Next.js 애플리케이션에서 데이터 검색, 캐싱 및 업데이트를 위한 기능을 제공하는 역할을 합니다. 몇 줄의 코드로 React Query는 클라이언트 상태에서 캐시된 데이터를 관리하기 위해 사용되는 부재 코드를 대체합니다. 이 상태 관리 접근 방식은 extensive-react-boilerplate에서 사용됩니다.\n\n## 보일러플레이트의 ESLint 규칙\n\n프로젝트 개발 중 ESLint 규칙을 사용하는 효율성은 사용자 지정 규칙을 작성하는 데도 나타납니다. ESLint는 포맷팅 및 규칙뿐만 아니라 내부 프로젝트 결정 사항도 고려할 수 있도록 많은 기능과 유연성을 제공합니다. 예를 들어, 폼 작업 시 불필요한 렌더링 가능성을 제어하고 개발자에게 경고를 주거나, 객체 작업 시에는 잘못된 솔루션을 알리거나, 사용하지 않는 import를 가리킬 수 있습니다. 예를 들어, extensive-react-boilerplate에서는 이러한 문제를 다음과 같이 다룹니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 패턴을 잘못 사용한 경우의 규칙에 대해 경고합니다\n\n![이미지](/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_5.png)\n\n- 제어할 수 없는 렌더링이 발생할 수 있다는 가능성을 알립니다\n\n![이미지](/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n효과적인 React 템플릿을 선택하는 것은 프로젝트의 성공에 중요합니다. 바퀴를 다시 발명하는 대신, 잘 선택된 보일러플레이트의 파워를 활용하면 개발 프로세스를 크게 가속화하고 견고한 기반을 구축할 수 있습니다. 보일러플레이트를 선택할 때, 해당 디렉토리 구조와 구성 파일을 숙지하여 기반, 통합 용이성, 모듈화 및 기술적 요구에 최대한 부합하는지를 이해하는 것이 좋습니다. 제공되는 기능이 필요한 기능을 제공할 수 있는지 고려하십시오. 이렇게 하면 개발 시간을 절약하고 잘 유지되고 테스트된 코드를 활용할 수 있을 수도 있습니다.\n\n다양한 보일러플레이트를 동시에 적용하는 방법에 대한 질문이 자주 있었는데, 이러한 템플릿에서 포괄적인 기능이 부족한 점 때문에 bc 보일러플레이트 팀은 광범위한 리액트 보일러플레이트로 해결책을 제안했습니다. 우리는 이견을 제시하고 널리 알려진 대안들 사이에서 자리를 잡고 주목할만한 경쟁 상대가 될 수 있는 것으로 생각합니다. 이제 한 번 시도해보시고 새로운 스타로서의 피드백을 기다리겠습니다.\n\n# 간단하게 이야기하기 🚀\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클로하고 팔로우해주세요 👏\n- 저희를 팔로우해주세요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_0.png"},"coverImage":"/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_0.png","tag":["Tech"],"readingTime":13},{"title":"React Hook Form과 Zod, MUI로 React Form 만들기","description":"","date":"2024-05-01 17:57","slug":"2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio","content":"\n\nReact Hook Form과 Zod 스키마를 사용하여 효율적으로 유효성을 검사하는 방법을 배우세요. MUI 컨트롤과 함께 사용하여 양식 유효성 검사 능력을 한 단계 업그레이드하세요. 이 포괄적인 가이드를 통해 React 애플리케이션에서 견고함과 정확성을 보장하세요. 통합 프로세스를 몰두하고 개발 워크플로우를 간소화하세요!\n\n효율적이고 사용자 친화적인 양식을 작성하는 것은 React 애플리케이션에서 중요합니다. 그러나 유효성 검사, 상태 및 스타일 관리는 지루하고 복잡해질 수 있습니다. 이것이 React Hook Form, Zod 및 MUI의 조합이 빛을 발하는 곳입니다!\n\n![](/assets/img/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio_0.png)\n\nReact Hook Form:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 선언적 접근 방식: 등록, 유효성 검사 및 제출에 대한 후크를 사용하여 양식 관리를 간소화합니다.\n- 내장 유효성 검사: 외부 라이브러리가 필요하지 않습니다. 양식 내에서 직접 유효성 검사 규칙을 정의하세요.\n- 비제어 컴포넌트: 네이티브 HTML 입력 또는 제어 컴포넌트를 활용하여 유연성을 높이세요.\n\nZod:\n\n- 유형 안전한 유효성 검사: 강력한 스키마 유효성 검사 라이브러리로 데이터 품질을 보장하세요.\n- 명확한 오류 메시지: Zod 스키마를 사용하면 사용자가 어떤 오류가 발생했는지 이해할 수 있도록 명확한 오류 메시지를 작성할 수 있습니다. 더 나아가 중첩된 유효성 검사를 사용하여 고급 유효성 검사 규칙을 작성할 수 있어 복잡한 데이터 구조를 처리하기가 더 쉬워집니다.\n- React Hook Form과의 통합: zodResolver와의 원활한 통합으로 양식에서 간편한 유효성 검사를 수행하세요.\n\nMUI:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 아름다운 UI 구성 요소: 미리 만들어진 MUI 컴포넌트를 사용하여 시각적으로 매력적이고 접근성 있는 양식을 만들어보세요.\n- 사용자 정의: 브랜드 아이덴티티에 맞춰 테마를 사용자 정의하여 앱 UI의 모양과 느낌을 조정하세요.\n- 쉬운 통합: Material-UI 컴포넌트는 React Hook Form과 원활하게 통합되어 스타일 충돌 가능성을 줄입니다.\n\n이 3가지를 사용하는 장점:\n\n- 향상된 개발자 경험: 보일러플레이트를 줄이고 더 깔끔하고 유지보수하기 쉬운 코드를 작성하세요.\n- 향상된 사용자 경험: 자동 유효성 검사, 명확한 오류 메시지, 부드러운 작업 흐름을 활용하세요.\n- 오류 감소: 타입 안전한 유효성 검사로 데이터 문제를 일찍 발견하고 예방하세요.\n- 빠른 개발: 기능 구축에 집중하고 양식과의 싸움을 줄이세요.\n\n예제를 만들어봅시다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 폼 유효성 검사를 위한 Zod 스키마 정의\n// Yup 유효성 검사를 대신 사용할 수도 있습니다.\nconst schema = z.object({\n  email: z.string().email(\"유효하지 않은 이메일입니다.\").min(1, \"이메일은 필수입니다.\"),\n  password: z.string().min(6, \"비밀번호는 최소 6자 이상이어야 합니다.\"),\n  phoneNumber: z\n    .string()\n    .min(10, \"전화번호는 최소 10자 이상이어야 합니다.\")\n    .max(10)\n    .optional(),\n  country: z.string().min(1, \"국가는 필수입니다.\"),\n});\n```\n\n여기서 복잡한 객체를 Zod를 사용하여 유효성 검사하는 방법입니다.\n\n```js\nconst addressSchema = z.object({\n  street: z.string().min(1, \"거리를 입력해주세요.\"),\n  city: z.string().min(1, \"도시를 입력해주세요.\"),\n  zipCode: z\n    .string()\n    .min(5, \"우편번호는 최소 5자 이상이어야 합니다.\")\n    .refine(value =\u003e /^\\d+$/.test(value), {\n      message: \"우편번호는 숫자로만 이루어져야 합니다.\"\n    }),\n});\n\nconst userSchema = z.object({\n  email: z.string().email(\"유효하지 않은 이메일입니다.\").min(1, \"이메일은 필수입니다.\"),\n  password: z.string().min(6, \"비밀번호는 최소 6자 이상이어야 합니다.\"),\n  phoneNumber: z\n    .string()\n    .min(10, \"전화번호는 최소 10자 이상이어야 합니다.\")\n    .max(10)\n    .optional(),\n  country: z.string().min(1, \"국가는 필수입니다.\"),\n  address: addressSchema,\n});\n```\n\n폼 데이터의 유형을 정의하고 useForm 훅을 사용하여 입력 상태를 관리하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 폼 데이터 유형 정의\ntype FormData = z.infer\u003ctypeof schema\u003e;\n// react-hook-form에서 useForm을 구조분해하여 가져옵니다\nconst {\n  // register: 입력 요소 등록 함수\n  register,\n  // handleSubmit: 폼 제출 처리 함수\n  handleSubmit,\n  // watch: 폼 입력 값 감시 함수\n  watch,\n  // formState: 폼 상태 정보를 포함한 객체\n  formState: { errors, touchedFields }, // formState에서 errors 및 touchedFields를 구조분해합니다\n} = useForm\u003cFormData\u003e({ // generic 타입 FormData로 useForm 훅 호출\n  // resolver: Zod를 사용하여 폼 유효성 검사에 대한 리졸버 지정\n  resolver: zodResolver(schema), // Zod 스키마를 리졸버에 전달\n  // defaultValues: 폼 입력의 기본 값 지정\n  defaultValues: {\n    email: \"\", \n    password: \"\", \n    phoneNumber: \"\",\n    country: \"\",\n  },\n});\n\n const onSubmit = (data: FormData) =\u003e {\n    console.log(data); // 제출된 데이터로 API 호출\n };\n```\n\nReact Hook Form과 Material-UI 컴포넌트, MUI 폼 컨트롤을 사용하여 폼을 생성해봅시다.\n\n```js\n        \u003cform onSubmit={handleSubmit(onSubmit)}\u003e\n          \u003cTypography variant=\"h4\" gutterBottom\u003e\n            회원가입\n          \u003c/Typography\u003e\n          \u003cTextField\n            label=\"이메일\"\n            fullWidth\n            margin=\"normal\"\n            defaultValue={defaultValues.email}\n            {...register(\"email\")}\n            error={!!errors.email}\n            helperText={errors.email?.message}\n          /\u003e\n          \u003cTextField\n            label=\"비밀번호\"\n            type=\"password\"\n            fullWidth\n            margin=\"normal\"\n            defaultValue={defaultValues.password}\n            {...register(\"password\")}\n            error={!!errors.password}\n            helperText={errors.password?.message}\n          /\u003e\n          \u003cTextField\n            label=\"전화번호\"\n            fullWidth\n            margin=\"normal\"\n            defaultValue={defaultValues.phoneNumber}\n            {...register(\"phoneNumber\")}\n            error={!!errors.phoneNumber}\n            helperText={errors.phoneNumber?.message}\n          /\u003e\n\n          \u003cFormControl fullWidth margin=\"normal\" error={!!errors.country}\u003e\n            \u003cInputLabel\u003e국가\u003c/InputLabel\u003e\n            \u003cSelect\n              label=\"국가\"\n              {...register(\"country\")}\n              defaultValue={defaultValues.country}\n              sx={ my: 1 }\n            \u003e\n              \u003cMenuItem value=\"USA\"\u003e미국\u003c/MenuItem\u003e\n              \u003cMenuItem value=\"Canada\"\u003e캐나다\u003c/MenuItem\u003e\n              {/* 필요한 경우 다른 국가 추가 */}\n            \u003c/Select\u003e\n            \u003cFormHelperText\u003e{errors.country?.message}\u003c/FormHelperText\u003e\n          \u003c/FormControl\u003e\n\n          \u003cButton type=\"submit\" variant=\"contained\" color=\"primary\"\u003e\n            제출\n          \u003c/Button\u003e\n        \u003c/form\u003e\n```\n\n위의 코드에서 무슨 일이 벌어지고 있는지 설명드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n- defaultValue={defaultValues.phoneNumber}: 여기서는 입력 필드의 기본값을 저장된 값으로 설정합니다.\n- {...register(\"phoneNumber\")}: 이 줄은 React Hook Form과 입력 필드를 등록하여 폼 데이터의 \"phoneNumber\" 필드와 연결합니다. 이를 통해 React Hook Form을 사용하여 폼 유효성 검사 및 데이터 처리를 활성화할 수 있습니다.\n- error={!!errors.phoneNumber}: 이 속성은 입력 필드에 대한 오류 상태를 표시할지 여부를 결정합니다. 만약 폼 데이터의 \"phoneNumber\" 필드에 오류가 있으면 오류 상태를 트리거합니다.\n- helperText={errors.phoneNumber?.message}: 여기서 \"phoneNumber\" 필드와 관련된 오류 메시지를 표시합니다. 오류가 없으면 이 속성은 비어 있지만, 폼 유효성 검사 중 오류가 발생하면 사용자에게 오류 메시지를 표시하여 안내합니다.\n```\n\n사용자에게 피드백을 제공하고 유효성 검사 오류를 조건적으로 표시하는 데 touchedFields 객체를 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio_1.png)\n\n예를 들어 사용자가 상호 작용한 필드에 대해서만 유효성 검사 오류를 표시하고 싶을 수 있습니다. 필드의 touched 상태가 true인지 확인하여 오류 메시지를 조건부로 렌더링할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nerror={!!errors.firstName \u0026\u0026 touchedFields.firstName}\n```\n\nwatch를 사용하면 사용자가 입력하는 값의 변경 사항을 추적하고 반응할 수 있습니다. 비밀번호를 입력할 때 암호 강도를 표시하고 싶다면, 입력 값을 기반으로 실시간으로 유효성을 검사하는 watch를 사용하여 이를 달성할 수 있습니다.\n\n```js\nconst password = watch('password');\n\nuseEffect(() =\u003e {\n    console.log(passwordWatch); // 로깅\n    if (password.length \u003c 8 || !hasAlphabet(password) || !hasLowercase(password) || !hasSpecialCharacter(password)) {\n      // 비밀번호 강도 경고 표시\n    } else {\n      // 경고 숨기기\n    }\n  }, [password]);\n```\n\n비밀번호가 변경될 때마다 비밀번호 값이 변경되는 것을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio_2.png\" /\u003e\n\nFormControl과 control은 서로 다른 목적을 가지고 있습니다.\n\nFormControl\n\n- Material-UI의 컴포넌트: 이 컴포넌트는 텍스트 필드, 체크박스, 라디오 버튼과 같은 폼 컨트롤을 스타일링하고 그룹화하기 위해 특별히 디자인된 컴포넌트입니다. 시각적 일관성과 접근성을 위한 스타일링 및 레이아웃 옵션을 제공합니다.\n- 예시: 코드에서 FormControl은 이메일과 비밀번호 필드를 위해 InputLabel과 Select 컴포넌트를 감싸는 데 사용되어, 레이블과 에러 처리를 포함하는 스타일링된 인풋 그룹을 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컨트롤\n\n- react-hook-form의 기능: useForm 훅에서 제공되는 함수로, 폼 입력을 등록하고 값 및 상태를 관리할 수 있게 해줍니다. 입력을 폼 상태에 연결하고 검증 및 상호작용 메커니즘을 제공하는 내부 논리를 처리합니다.\n- 예시: register 내에서 컨트롤 함수를 전달하면 필드 이름(이메일 또는 비밀번호)과 함께 입력을 폼 상태에 등록할 수 있습니다. 이렇게 하면 react-hook-form이 입력의 값을, 오류 및 검증 상태를 추적할 수 있습니다.\n\n![이미지](/assets/img/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio_3.png)\n\nreact-hook-form-mui 라이브러리를 사용하는 것을 고려해보세요. 이 라이브러리는 Material-UI 구성요소에 대한 사용자 지정 컴포넌트 및 래퍼를 제공하며, react-hook-form과 원활하게 통합됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 일반 사용 사례\n\nMaterial-UI 구성 요소를 사용할 때는 register 및 Controller 간의 선택이 특정 컴포넌트 및 원하는 제어 수준에 따라 달라집니다:\n\n다음에 register 사용:\n\n- 제어된 동작을 갖는 기본 Material-UI 구성 요소:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 텍스트 필드\n- 선택\n- 체크박스\n- 라디오 그룹\n\n컨트롤러 사용 사례:\n\n기본적으로 제어된 동작을 따르지 않는 고급 Material-UI 구성 요소\n\n- 자동 완성\n- 날짜 선택기\n- 시간 선택기\n- 스위치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 주요 기능\n\n## Re-Renderers 분리하기\n\nRe-Renderers 분리하기는 React Hook Form의 기능 중 하나로, 필요한 컴포넌트만 다시 렌더링하여 폼의 성능을 개선할 수 있게 해줍니다. 전체 폼을 다시 렌더링하는 대신 업데이트해야 할 컴포넌트만 다시 렌더링하는 것이 중요합니다. 이는 폼이 로드되는 데 필요한 시간을 줄이고 사용자와의 상호 작용을 향상시킬 수 있습니다.\n\n세 개의 자식 컴포넌트를 포함한 폼이 있다고 상상해봅시다: 자식 컴포넌트 A, 자식 컴포넌트 B, 자식 컴포넌트 C. 제어되는 폼에서 자식 컴포넌트 A를 변경하면, 자식 컴포넌트 B와 자식 컴포넌트 C가 업데이트될 필요가 없더라도 세 개의 자식 컴포넌트가 모두 다시 렌더링됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact Hook Form을 사용하면 Child Component A의 다시 렌더링을 격리시켜 해당 컴포넌트가 변경되었을 때 해당 컴포넌트만 다시 렌더링됩니다. 이렇게 하면 대형이거나 복잡한 폼을 사용할 경우 폼의 성능을 크게 향상시킬 수 있습니다.\n\n# 결론\n\nReact Hook Form, Zod 및 MUI를 결합하여 견고하고 효율적이며 사용자 친화적인 폼을 만들어 React 개발 경험을 향상시킬 수 있습니다. 그러니 복잡성을 버리고 엔터프라이즈 수준의 폼 빌딩 여정을 위해 이 강력한 세트를 환영해 보세요!\n\n유용하게 여겨진다면 박수 버튼을 눌러주세요.","ogImage":{"url":"/assets/img/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio_0.png"},"coverImage":"/assets/img/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio_0.png","tag":["Tech"],"readingTime":9},{"title":"NextJS 앱에 JWT 인증 추가하는 방법(2024년 최신)","description":"","date":"2024-05-01 17:56","slug":"2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps","content":"\n\n![이미지](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_0.png)\n\n# 소개\n\n본 문서는 NextJS를 사용하여 인증을 구현하는 방법에 대한 간단한 자습서입니다. 가이드에 들어가기 전에 사용될 기술을 시연하겠습니다:\n\n- JWT 또는 JSON Web Token은 두 당사자 간에 안전하게 클레임을 나타내는 데 사용되는 산업 표준 RFC 7519 방법입니다.\n- NextJS 미들웨어: 미들웨어를 사용하면 요청이 완료되기 전에 코드를 실행할 수 있으며, 수신된 요청을 기반으로 응답을 수정하여 리다이렉팅하거나 요청 또는 응답 헤더를 수정하거나 직접 응답하는 등의 작업을 수행할 수 있습니다. 이를 사용하여 우리는 인증을 처리하는 라우팅을 돕겠습니다.\n- JWT 인증 서비스: JWT를 사용하여 인증을 지원하는 백엔드 서비스가 필요합니다. NestJS를 사용하여 어떻게 만드는 지에 대한 내 튜토리얼을 확인하거나 다른 기술을 사용하여 직접 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 레이아웃\n\n먼저 사용자 인터페이스가 필요해요. 이 간단한 레이아웃을 살펴봐요:\n\n![이미지](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_1.png)\n\n레이아웃을 보고 루트를 말해줄 수 있어요. 총 3가지 종류의 루트가 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 공개 경로: 누구나 접근할 수 있는 경로\n- 인증 경로: 인증되지 않은 사용자만 접근할 수 있는 경로\n- 보호된 경로: 인증된 사용자만 접근할 수 있는 경로\n\n# 인증 서비스\n\nAPI 로그인을 호출해야 합니다. 따라서 인증 API 호출을 처리하는 서비스가 필요합니다. 이 예제에서는 axios를 사용하여 API 호출을 처리할 것입니다.\n\n![이미지](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로그인 요청이 성공하면 사용자 이름, accessToken 또는 JWT, 만료 시간을 얻을 수 있습니다.\n\n# 인증 훅\n\n3 가지 간단한 훅이 필요합니다:\n\n- useCurrentUser : 현재 로그인한 사용자 정보를 가져오는 훅\n- useLogin : 로그인 방법을 제공하는 훅\n- useLogout : 로그아웃 방법을 제공하는 훅\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 먼저 첫 번째 useLogin으로 들어갈 거에요:\n\n![HowtoaddJWTAuthenticationtoNextJSApps_3](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_3.png)\n\n사용자 정보를 쿠키로 저장했죠. 왜 쿠키를 사용했을까요? 나중에 설명할게요.\n\nuseLogout:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_4.png)\n\n로그아웃하려면 쿠키를 지우기만 하면 됩니다.\n\n사용자 현재 사용자\n\n![이미지](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 미들웨어\n\nReact만 사용하면 모든 라우트에서 인증을 확인하는 것이 꽤 어렵습니다. 그러나 NextJS 미들웨어를 사용하면 매우 쉽게 처리할 수 있습니다.\n\n먼저, 라우트를 확인해 봅시다:\n\n![라우트 이미지](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 가이드는 간단한 것이므로, 이렇게 가보겠습니다.\n\n중요한 부분은 미들웨어입니다. NextJS에서 미들웨어는 요청이 완료되기 전에 코드를 실행할 수 있게 해주며, 들어오는 요청을 기반으로 요청이나 응답 헤더를 수정하거나, 리다이렉팅하거나, 요청이나 응답에 직접 응답할 수 있게 해줍니다.\n\n즉, 미들웨어는 프로젝트의 모든 경로에 대해 호출될 것입니다.\n\n미들웨어.ts 파일을 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_7.png)\n\n해석:\n\n- 먼저 쿠키에서 현재 사용자를 가져옵니다.\n- 다음 경로가 보호된 경로인지 확인한 후, 사용자가 인증되지 않았거나 토큰이 만료되었는지 확인합니다. 사용자를 쿠키에서 삭제하고 /login으로 리디렉트합니다.\n- 다음 경로가 인증 경로이지만 사용자가 로그인되어 있는 경우, 사용자를 /profile로 리디렉트합니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서, NextJS에서 인증을 처리하는 간단한 구현이다. 이 글이 유용하게 느껴지길 바라며, 예제 코드가 너무 난해하다면 소스 코드를 여기서 확인해보세요.\n\n# 마지막으로\n\n내 컨텐츠는 누구에게나 무료이지만, 이 글이 도움이 되었다면 여기에서 커피 한 잔 사주시면 감사하겠습니다.","ogImage":{"url":"/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_0.png"},"coverImage":"/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 앱을 만들 때 유용한 공짜 API들","description":"","date":"2024-05-01 17:53","slug":"2024-05-01-APIstoUseforCreatingReactApp","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-APIstoUseforCreatingReactApp_0.png\" /\u003e\n\n리액트는 현대적인 웹 및 모바일 애플리케이션을 구축하는 데 가장 인기 있는 프레임워크 중 하나가 되었습니다. 그 인기의 주요 이유 중 하나는 캡슐화된 UI 요소를 구축할 수 있는 구성 기반 아키텍처입니다.\n\n그러나 실제 세계 애플리케이션은 프론트엔드 UI 코드보다 훨씬 더 많은 기능이 필요합니다. 사용자 인증, 데이터베이스 액세스, 결제 처리, 분석 추적 등과 같은 능력이 종종 필요합니다.\n\n이러한 복잡한 기능을 처음부터 구축하는 대신, 외부 API를 활용하는 것이 일반적인 실천 방법이 되었습니다. Reactjs 개발자를 고용하여 바퀴를 다시 발명하지 않고 강력한 기능을 추가할 수 있으며, 개발자들은 빠르게 잘 구조화된 구성 요소를 구축하고 API를 통합하여 기능을 빠르게 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제는 다양한 범주에서 개방 API가 수천 개 제공됩니다. 이 범주에는 개발, UI, 인증 등이 포함됩니다. Remix 앱을 만들기 위해 API를 결합하면 제품을 위한 독특한 가치를 구축하는 데 집중할 수 있습니다.\n\n이 게시물에서는 React 앱에 쉽게 통합할 수 있는 일반적인 사용 사례의 가장 유용한 API 목록을 살펴볼 것입니다. React 컴포넌트에서 이러한 API를 직접 호출하여 결제, UI, 인증, 데이터, 저장소 등과 같은 기능을 추가하는 방법을 살펴볼 것입니다.\n\nAPI를 활용하고 React 개발자를 고용하면 풀 속도로 기능이 풍부한 앱을 빠르게 구축할 수 있습니다. 이러한 도구를 사용하여 React 앱을 강화하는 방법을 알아봅시다!\n\nReact 앱을 구축할 때 유용한 API 통합 목록을 더 잘 이해하기 위해.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 인증\n\n인증 API는 현대의 웹 및 모바일 애플리케이션의 중심 역할을 합니다. 사용자의 안전한 리소스 접근을 효과적으로 조절하여, 사용자 등록, 로그인, 비밀번호 유지 및 세션 감독과 같은 기능을 수행합니다. 이러한 API 기능은 민감한 데이터와 상호 작용할 수 있는 사용자가 인증된 사용자만인지를 확인하여, 사용자 신뢰가 최우선이 되는 오늘날의 디지털적으로 결합된 생태계에서, 인증 API는 꼭 필요한 존재입니다. 이는 보안 및 사용자 중심 애플리케이션을 구축하기 위한 기초가 되며, 보안과 사용자 경험의 원활함을 최우선으로 하는 애플리케이션의 핵심 요소입니다.\n\n![인증 이미지](https://miro.medium.com/v2/resize:fit:960/1*sqHSJsqvTfKPEJ7XKhadHw.gif)\n\n## Firebase Auth\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGoogle의 Firebase 플랫폼은 Firebase Authentication이라는 신뢰할 수 있는 인증 메커니즘을 제공합니다. 모바일 및 웹 애플리케이션의 사용자 권한 부여 및 인증 프로세스를 개선하는 다양한 기능을 제공합니다.\n\n다음은 Firebase Authentication API의 주요 특징 중 일부입니다:\n\n- 다중 서인 메소드\n- 사용자 관리\n- 신원 확인\n- 사용자 정의 인증 시스템\n- 단일 로그인\n- 보안 규칙\n\n## Auth0\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAuth0은 웹 및 모바일 개발자들이 강력한 인증 및 권한 부여 솔루션을 손쉽게 통합할 수 있도록 하는 현존하는 최첨단 Identity-as-a-Service (IDaaS) 플랫폼으로, 사용자의 신원 관리 복잡성을 간소화하며 소셜 로그인, 기업 연결 및 비밀번호 없는 대체 옵션을 포함한 다양한 로그인 옵션을 지원합니다. 개인 블로그나 글로벌 전자 상거래 제국을 개발하고 있다 하더라도, Auth0을 통해 보안과 사용자 참여를 강화하고 끊임없이 변화하는 온라인 규정과 조화를 이룰 수 있습니다.\n\n다음은 Auth0 API의 주요 기능 몇 가지입니다:\n\n- 인증 방법\n- 사용자 정의 인증\n- 비밀번호 없는 인증\n- 다중 요소 인증 (MFA)\n- 사용자 관리\n- 단일 로그인 (SSO)\n\n# 결제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결제 API는 전자 상거래의 디지턄 동맥 역할을 하며, 기업들이 온라인 환경에서 재정 거래를 원활하게 처리할 수 있도록 합니다. 이러한 API는 자금을 안전하고 효율적으로 이체하는 주요 동력이며, 고객들이 제품과 서비스를 쉽게 구매할 수 있도록 가능하게 합니다. 디지털 시장이 기하급수적으로 성장하는 시대에, 결제 API는 금융 데이터 보호, 결제 프로세스 간소화, 그리고 기업이 온라인 상거래 세계에서 번창할 수 있도록 하는 중추적 역할을 합니다.\n\n![](https://miro.medium.com/v2/resize:fit:1000/1*89T2MjogSTQDwIZUldjfHg.gif)\n\n## Stripe\n\nStripe는 신용 카드, 모바일 지갑 및 로컬 결제 수단을 지원하는 인기 있는 결제 처리 서비스 중 하나입니다. 이들의 API를 통해 React 애플리케이션 내에서 일회성 및 반복 결제를 손쉽게 수락할 수 있습니다. Stripe는 React, React Native, Node.js 등에 대한 클라이언트 라이브러리를 제공하여 통합을 간편하게 할 수 있습니다. 몇 줄의 코드로 안전하게 결제를 수락하고 거래를 관리할 수 있습니다. 많은 기업에게 결제가 중요한 만큼, Stripe는 React 앱을 수익화하는 데 필수적인 API입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 Stripe의 일부 기능들입니다:\n\n- 결제 처리\n- 정기 구독 청구\n- 지급\n- 사기 방지\n- 송장\n- 재무 보고서\n\n## PayPal\n\nPayPal을 React 앱에 통합하면 고객에게 신용카드와 함께 선호하는 결제 방법을 제공할 수 있습니다. PayPal의 글로벌 플랫폼은 PayPal 계정, 신용/직불 카드 또는 은행 이체를 통해 안전한 결제를 제공합니다. React용 전용 JavaScript SDK를 사용하여 PayPal 버튼 및 PayPal 체크아웃과 같은 구성 요소를 통해 쉽게 PayPal 결제를 구현할 수 있습니다. 백엔드에서는 PayPal의 node.js API가 주문 처리와 거래를 관리합니다. 이 통합을 통해 변환율과 수익을 향상시킬 수 있으며, 더 넓은 사용자 베이스를 대상으로 한 원활한 결제 경험을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 PayPal의 일부 기능들입니다:\n\n- 결제 처리\n- 글로벌 범위\n- 보안\n- 구매자 및 판매자 보호\n- 비즈니스용 PayPal\n- 국제 거래\n\n# 데이터 및 저장\n\n현대적인 React 애플리케이션은 사용자 프로필 및 콘텐츠와 같은 지속적인 데이터 저장이 필요합니다. 자체 데이터베이스 서버를 관리하는 대신 Firebase Firestore, Supabase, Airtable과 같은 써드파티 API를 사용하면 애플리케이션 데이터를 클라우드에 저장하고 쿼리하는 것이 쉬워집니다. 이들의 React SDK 및 훅을 사용하면 컴포넌트에서 데이터에 선언적으로 액세스할 수 있으므로 데이터베이스 구성보다는 프론트엔드 구축에 집중할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Firebase Firestore](https://miro.medium.com/v2/resize:fit:520/1*9fLgRS8xnprs6gidpYMYFg.gif)\n\n## Firebase Firestore\n\n파이어베이스 Firestore는 유연하고 NoSQL 구조의 클라우드 데이터베이스로, 사용자 간에 앱 데이터를 실시간으로 저장하고 동기화할 수 있습니다. 데이터 검색, 추가, 업데이트, 삭제 및 쿼리와 같은 데이터 작업에 대한 간단한 API를 제공합니다. Firestore는 인증 및 호스팅과 같은 다른 파이어베이스 서비스와 매끄럽게 통합됩니다. React-Firebase 훅스 라이브러리는 컴포넌트 내에서 파이어베이스 API를 직접 호출하기 위한 쉽게 사용할 수 있는 React 훅스를 제공합니다. 실시간 리스너를 통해 협업 및 소셜 기능을 더 쉽게 구축할 수 있습니다. 전반적으로, Firestore는 클라우드에서 확장 가능한 실시간 데이터베이스가 필요한 React 앱에 필수적인 데이터 API입니다.\n\n다음은 Firebase Firestore의 주요 기능 몇 가지입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- NoSQL 데이터베이스\n- 실시간 데이터 동기화\n- 확장 가능하고 유연한\n- 오프라인 데이터 액세스\n- 보안 규칙\n- 쿼리 기능\n\n## Airtable\n\nAirtable은 API의 유연성과 쉽게 사용할 수 있는 스프레드시트 인터페이스를 독특하게 결합한 관계형 데이터베이스 옵션입니다. Airtable은 내부적으로 데이터를 레코드로 저장하는 스프레드시트와 유사한 테이블 형태로 관리합니다. Airtable의 React SDK를 사용하면 Records 및 RecordForm과 같은 선언적 구성 요소를 사용하여 데이터의 가져오기, 필터링 및 변경 작업을 수행하여 앱에 Airtable을 원활하게 통합할 수 있습니다. 직관적인 스프레드시트 뷰는 비기술 팀원이 데이터를 관리할 수 있도록 Airtable을 우수한 선택지로 만듭니다. 자체 서버를 관리하지 않으면서 관계형 데이터 중심의 React 앱을 구축하고 싶다면, Airtable의 React 통합을 통해 제공되는 단순성과 강력함의 조합은 탐험할 가치가 있는 훌륭한 선택지입니다.\n\n다음은 Airtable의 주요 기능입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 사용자 친화적 인터페이스\n- 관계형 데이터베이스\n- 협업 및 공유\n- 사용자 정의 가능한 템플릿\n- 데이터 가져오기 및 내보내기\n- API 통합\n\n# 머신러닝\n\n머신러닝 기능을 추가하면 앱이 더욱 발전하게 됩니다. 그러나 ML 모델을 구축하려면 심층적인 전문 지식이 필요합니다. ML API를 사용하면 시각, 언어, 예측 등을 위한 사전 훈련된 모델을 손쉽게 통합할 수 있습니다. Google, AWS, Microsoft 같은 클라우드 제공업체는 이미지 분류, 음성 인식, 자연어 처리 등과 같은 일반적인 사용 사례를 다루는 ML API를 제공합니다. Clarifai와 같은 전문 API는 컴퓨터 비전에 집중합니다. 이러한 ML API를 활용하면 React 개발자들은 자신의 앱에 지능적인 기능을 추가할 수 있으며 AI 전문가가 아니어도 자체 모델을 훈련시키기 위한 리소스가 없어도 됩니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*i3OGEnu6h_0WRNiJzjBSqg.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## TensorFlow\n\nTensorFlow.js는 웹 브라우저나 Node.js와 같은 JavaScript 환경에서 모델을 구축하고 배포하기 위한 ML 프레임워크입니다. 컴퓨터 비전, NLP 및 기타 분야에 대한 사전 훈련된 모델을 제공합니다. React TensorFlow 모듈을 사용하면 React 구성 요소 내에서 쉽게 모델을 사용하고 다시 훈련할 수 있으며, use TensorFlow와 같은 후크를 사용할 수 있습니다. 머신 러닝을 통합하려는 React 개발자들에게 TensorFlow.js는 필수적인 시작점입니다.\n\nTensorFlow의 주요 기능 중 일부는 다음과 같습니다.\n\n- 오픈 소스 프레임워크\n- 딥 러닝 기능\n- 모델 빌딩을 위한 유연성\n- 확장성\n- 생태계 및 커뮤니티 지원\n- 크로스 플랫폼 호환성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 클라우드 비전 API\n\n구글의 클라우드 비전 API는 이미지를 이해하기 위한 강력한 사전 훈련된 머신러닝 모델을 제공합니다. 라벨, 얼굴 감지, OCR 등을 통해 이미지를 이해하는 기능을 제공합니다. 몇 줄의 코드로 React 앱에 지능적인 이미지 분류 및 분석 기능을 추가할 수 있습니다. 사용자 정의 모델을 훈련시킬 필요 없이 컴퓨터 비전을 통합하는 간단한 방법입니다.\n\n다음은 클라우드 비전 API의 주요 기능입니다.\n\n- 이미지 인식\n- 물체 탐지\n- 얼굴 인식\n- 광학 문자 인식 (OCR)\n- 라벨링 및 분류\n- 안전 검색 및 음란물 감지\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 애널리틱스\n\n애널리틱스를 통해 사용자 행동을 이해하는 것은 성공적인 앱을 만드는 데 중요합니다. Google 애널리틱스와 Mixpanel과 같은 플랫폼을 사용하면 이벤트, 퍼널 및 지표를 측정하여 이용자 참여를 측정할 수 있습니다. React 라이브러리를 통해 이벤트를 직접 컴포넌트에서 분석 파이프라인으로 보낼 수 있습니다. 자체 추적 인프라를 구축하는 대신에 이러한 애널리틱스 플랫폼을 활용하면 상당한 개발 시간을 절약하고 강력한 애널리틱스 대시보드를 기본으로 제공받을 수 있습니다.\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*x8wKS9HGaskNnFSTg9Ws0g.gif)\n\n## Google 애널리틱스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 인기 있는 분석 솔루션인 Google Analytics은 웹 사이트 트래픽 및 사용자 참여를 추적하는 데 중요합니다. react-ga 라이브러리는 Google Analytics를 React와 통합하여 컴포넌트에서 페이지 뷰, 이벤트, 시간 및 기타를 직접 보낼 수 있도록 합니다.\n\n다음은 Google Analytics의 주요 기능입니다.\n- 실시간 데이터 모니터링\n- 전자 상거래 목표 추적\n- 웹 사이트 트래픽 분석\n- 사용자 행동 추적\n- 전환 추적\n- 사용자 정의 가능한 보고서\n\n## Mixpanel\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 인기 있는 분석 솔루션으로, Google Analytics는 웹 사이트 트래픽 및 사용자 참여를 추적하는 데 중요합니다. react-ga 라이브러리는 Google Analytics를 React와 통합하여 페이지 뷰, 이벤트, 타이밍 등을 컴포넌트에서 직접 전송할 수 있습니다.\n\n다음은 Mixpanel의 주요 기능들입니다.\n\n- 이벤트 추적\n- 사용자 행동 분석\n- 퍼널 분석\n- 충성도 분석\n- A/B 테스트\n- 사용자 정의 대시보드\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사는 React 앱을 개발할 때 타사 API의 사용을 논의하면서 외부 서비스 및 데이터를 통합하는 중요성을 강조합니다. 개발자들은 Firebase, Stripe 및 Mixpanel과 같은 기술을 활용하여 개발을 가속화하고 매력적인 사용자 경험을 제작하는 데 집중할 수 있습니다. 야심찬 앱을 구축하고 효과적으로 확장하기 위해, 이 기사는 확장되는 React 생태계와 모든 프로젝트에 API를 통합할 수 있는 가능성을 강조합니다. 또한 최신 솔루션에 대해 계속해서 알아둘 중요성을 강조합니다.","ogImage":{"url":"/assets/img/2024-05-01-APIstoUseforCreatingReactApp_0.png"},"coverImage":"/assets/img/2024-05-01-APIstoUseforCreatingReactApp_0.png","tag":["Tech"],"readingTime":8},{"title":"ReactJS와 Firebase를 사용하여 사용자 로그인 및 가입 구현하기(2024년)","description":"","date":"2024-05-01 17:51","slug":"2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide","content":"\n\u003cimg src=\"/assets/img/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide_0.png\" /\u003e\n\n# 소개:\n\n현재의 디지털 환경에서 사용자 인증 및 등록은 모든 웹 애플리케이션의 기본적인 측면입니다. 개인 블로그, 전자 상거래 플랫폼 또는 협업 도구를 구축하고 있더라도 안전하고 간편한 로그인 및 사용자 가입 프로세스를 구현하는 것이 중요합니다. ReactJS는 사용자 인터페이스를 구축하기 위한 인기 있는 JavaScript 라이브러리이며, 강력한 백엔드 플랫폼인 Firebase와 결합하면 응용 프로그램에서 사용자 인증을 관리하는 강력한 솔루션을 제공합니다.\n\n본문에서는 ReactJS와 Firebase를 사용하여 로그인 및 사용자 가입 기능을 구현하는 단계별 안내를 제공하며, Bootstrap의 유연성과 디자인 기능을 활용합니다. 이 튜토리얼을 완료하면 ReactJS 응용 프로그램의 사용자 경험을 향상시킬 수 있는 원활하고 안전한 사용자 인증 시스템을 만들기 위한 지식과 기술을 갖추게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 튜토리얼을 통해 다음 주제를 다룰 예정입니다:\n\n- ReactJS 프로젝트 설정 및 필요한 종속 항목 설치하기.\n- Firebase 프로젝트 생성 및 Firebase 인증 구성하기.\n- 로그인 기능 구현하기, 폼 유효성 검사 및 오류 처리 포함.\n- 사용자 등록 기능 구현하기, 새로운 사용자 등록 허용하기.\n- 시각적으로 매력적이고 반응형 디자인을 위해 Bootstrap 통합하기.\n\n이 포괄적인 안내를 따라가면 ReactJS에서 튼튼한 로그인 및 사용자 등록 시스템을 구현하는 방법을 이해하고 Firebase의 인증 기능과 Bootstrap의 디자인 구성 요소를 활용할 수 있습니다. 그러니 시작해보고 애플리케이션을 무결한 사용자 인증 경험으로 강화해보세요!\n\n# 1. ReactJS 프로젝트 설정 및 필요한 종속 항목 설치하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구현 세부 사항에 들어가기 전에 ReactJS에 대해 기본적인 이해가 있고 ReactJS 프로젝트를 이미 설정한 것으로 가정한 이 기사를 읽으셔야 합니다. ReactJS에 익숙하지 않거나 프로젝트 설정에 대한 지침이 필요한 경우 이전 기사를 참고하는 것을 권장합니다.\n\nReactJS에서 로그인 및 사용자 가입 기능을 구현하려면 이 과정을 돕는 여러 패키지를 설치해야 합니다. 이 패키지에는 Bootstrap, Firebase, react-bootstrap, react-google-button, react-router-dom, react-scripts, 그리고 web-vitals이 포함됩니다. 각 패키지와 이들이 구현에서 하는 역할에 대해 자세히 살펴보겠습니다:\n\n- Bootstrap: Bootstrap은 반응형이고 시각적으로 매력적인 사용자 인터페이스를 구축하기 위한 다양한 CSS와 JavaScript 컴포넌트를 제공하는 인기 있는 프론트엔드 프레임워크입니다. 응용 프로그램을 디자인하고 스타일을 쉽게할 수 있도록 도와주며 복잡한 CSS 스타일링에 시간을 할애하는 대신 기능에 집중할 수 있게 해줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트의 터미널이나 명령 프롬프트를 열고 ReactJS 프로젝트의 루트 디렉토리로 이동하세요. 다음 명령을 사용하여 npm(Node Package Manager)을 통해 Bootstrap을 설치해보세요:\n\n```js\nnpm install bootstrap\n```\n\nFirebase: Firebase는 Firebase 인증을 포함한 다양한 서비스를 제공하는 강력한 백엔드 플랫폼입니다. Firebase Authentication은 이메일/비밀번호 인증, Google 및 Facebook과 같은 제공업체를 이용한 소셜 인증 등과 같이 사용할 수 있는 인증 기능을 제공합니다. Firebase Authentication은 응용 프로그램에 대한 안전한 사용자 관리, 인증 흐름, 및 신원 확인을 보장합니다.\n\n```js\nnpm install firebase\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. react-bootstrap: react-bootstrap은 Bootstrap의 강력함과 ReactJS의 쉬운 사용성 및 유연성을 결합한 라이브러리입니다. 재사용 가능한 React 컴포넌트로 구성된 미리 만들어진 Bootstrap 컴포넌트를 제공하여 Bootstrap의 스타일링 기능을 ReactJS 애플리케이션에 원활하게 통합할 수 있습니다.\n\n```js\nnpm install react-bootstrap\n```\n\n4. react-google-button: 이 패키지는 Google Sign-In 기능을 쉽게 추가할 수 있는 편리한 방법을 제공합니다. Google Sign-In 버튼 컴포넌트를 제공하여 Google의 인증 프로세스를 처리하고 Google 인증을 로그인 및 사용자 가입 흐름에 간소화되게 통합할 수 있습니다.\n\n```js\nnpm install react-google-button\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5. react-router-dom: react-router-dom은 ReactJS 애플리케이션에서 라우팅 기능을 활성화하는 패키지입니다. 이를 사용하면 애플리케이션의 각 페이지에 대한 다른 경로를 정의하여 로그인 페이지, 가입 페이지 및 사용자 대시 보드와 같은 서로 다른 뷰 간에 원할하게 이동할 수 있습니다.\n\n```js\nnpm install react-router-dom\n```\n\n6. web-vitals: web-vitals는 페이지 로드 시간, 상호 작용 및 콘텐츠 렌더링과 같은 중요한 웹 성능 지표를 측정하고 추적하는 데 도움이 되는 패키지입니다. 웹 성능 지표를 모니터링하면 애플리케이션의 성능을 최적화하고 원활한 사용자 경험을 보장할 수 있습니다.\n\n```js\nnpm install web-vitals\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 패키지를 설치하고 활용하면 강력한 로그인 및 사용자 가입 시스템을 구현하는 데 필요한 도구를 갖게 됩니다.\n\n## 2. Firebase 프로젝트 생성 및 Firebase 인증 구성\n\nReactJS 애플리케이션을 위한 Firebase 프로젝트를 만들고 Firebase 인증을 구성하는 방법은 다음과 같습니다:\n\n- Firebase 프로젝트 생성:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Firebase 콘솔(https://console.firebase.google.com/)로 이동해서 Google 계정으로 로그인해주세요.\n- \"프로젝트 추가\" 버튼을 클릭하여 새 Firebase 프로젝트를 만드세요.\n- 프로젝트 이름을 입력하고 원하는 지역을 선택해주세요.\n- Firebase 프로젝트를 생성하려면 \"프로젝트 만들기\" 버튼을 클릭하세요.\n\n2. Firebase 인증 활성화:\n\n- Firebase 프로젝트가 생성되면 프로젝트 대시보드로 리디렉션됩니다.\n- 왼쪽 사이드바에서 \"Develop\" 섹션 아래에 있는 \"Authentication\" 옵션을 클릭하세요.\n- Authentication 페이지에서 \"Sign-in method\" 탭 아래의 \"시작하기\" 버튼을 선택하세요.\n- 이메일/비밀번호 및 Google과 같은 인증 제공자를 선택하고 활성화하세요.\n\n3. Firebase 구성 세부정보 획득:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Firebase 프로젝트 대시보드에서 왼쪽 상단에있는 \"프로젝트 개요\" 옆에 있는 \"프로젝트 설정\" 기어 아이콘을 클릭합니다.\n- \"일반\" 탭에서 \"앱\" 섹션으로 스크롤하고 프로젝트에 새 웹 앱을 추가하려면 \"/\" 아이콘을 클릭합니다.\n- 앱에 대한 별명을 제공하고 \"이 앱에 대해 Firebase 호스팅도 설정\" 확인란을 선택 취소 해주세요.\n- \"앱 등록\" 버튼을 클릭하여 계속합니다.\n- Firebase에서 앱의 구성 세부 정보를 생성합니다. Firebase SDK 스니펫이 포함됩니다.\n\n4. ReactJS 애플리케이션과 Firebase 연결:\n\n- firebase.js 파일을 만들고 SDK 스니펫을 붙여넣어 주세요:\n\n```js\nimport { initializeApp } from \"firebase/app\";\nimport { getAuth } from \"firebase/auth\";\n\nconst firebaseConfig = {\n  apiKey: \"여러분의-API키\",\n  authDomain: \"여러분의-인증도메인\",\n  projectId: \"여러분의-프로젝트ID\",\n  storageBucket: \"여러분의-저장소버킷\",\n  messagingSenderId: \"여러분의-메시징발신자ID\",\n  appId: \"여러분의-앱ID\",\n};\n\n// Firebase 초기화\nconst app = initializeApp(firebaseConfig);\nexport const auth = getAuth(app);\nexport default app;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 컨텍스트 API 구축:\n\nReactJS에서는 컨텍스트 API를 사용하여 컴포넌트 트리를 통해 데이터를 전달할 수 있습니다. 각 레벨에서 명시적으로 props를 전달할 필요 없이 데이터를 전달하는 방법을 제공합니다. 컨텍스트 API에는 두 가지 주요 구성 요소가 있습니다: 컨텍스트 제공자와 컨텍스트 소비자가 있습니다.\n\n컨텍스트 제공자는 데이터를 트리 내의 다른 컴포넌트와 공유해야 하는 React 컴포넌트입니다. 이는 데이터의 진실의 원천 역할을 하며 해당 데이터를 사용할 수 있도록 만듭니다. 제공자는 컨텍스트를 생성하고 그것이 공유하려는 데이터를 지정하는 것이 책임입니다.\n\n- 컨텍스트 생성: (UserAuthContext.js)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst userAuthContext = createContext();\n\nexport function useUserAuth() {\n  return useContext(userAuthContext);\n}\n```\n\n2. Provider 만들기: (UserAuthContext.js)\n\n```js\nexport function UserAuthContextProvider({ children }) {\n  const [user, setUser] = useState({});\n\n  return (\n    \u003cuserAuthContext.Provider value={{ user, logIn, signUp, logOut, googleSignIn }}\u003e\n      {children}\n    \u003c/userAuthContext.Provider\u003e\n  );\n}\n```\n\n3. App을 Provider로 감싸기: (App.js)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cUserAuthContextProvider\u003e\n           내 앱\n\u003c/UserAuthContextProvider\u003e\n```\n\n컨텍스트 프로바이더는 여러 컴포넌트에서 필요로 하는 데이터가 있고 props를 수동으로 전달하는 것을 원치 않을 때 유용합니다. 데이터 공유를 간소화하고 코드베이스를 유지보수 가능하고 확장 가능하게 만듭니다. 그러나 컨텍스트를 과도하게 사용하면 복잡하고 관리하기 어려운 코드로 이어질 수 있습니다.\n\n# 4. Firebase 함수 만들기:\n\n이제 LogIn, SignUp, LogOut 및 googleSignIn 함수를 만들겠습니다. 여기서는 firebase.js 파일에서 만든 Auth 인스턴스를 사용할 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n function logIn(email, password) {\n    return signInWithEmailAndPassword(auth, email, password);\n  }\n  function signUp(email, password) {\n    return createUserWithEmailAndPassword(auth, email, password);\n  }\n  function logOut() {\n    return signOut(auth);\n  }\n  function googleSignIn() {\n    const googleAuthProvider = new GoogleAuthProvider();\n    return signInWithPopup(auth, googleAuthProvider);\n  }\n```\n\nonAuthStateChanged:\n\n파이어베이스에서 onAuthStateChanged는 Firebase 인증 모듈에서 제공하는 메소드입니다. 이는 사용자의 인증 상태를 실시간으로 모니터링할 수 있는 리스너 함수입니다. 이 함수는 사용자 세션을 관리하고 응용 프로그램에서 관련 인증 로직을 처리하는 데 특히 유용합니다.\n\nonAuthStateChanged 함수는 Firebase 인증 시스템에 옵저버를 등록하고 사용자의 인증 상태 변경을 듣습니다. 사용자가 로그인하거나 로그아웃하거나 인증 토큰이 만료될 때와 같이 사용자의 인증 상태가 변경될 때마다 콜백 함수를 트리거합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n  useEffect(() =\u003e {\n    const unsubscribe = onAuthStateChanged(auth, (currentuser) =\u003e {\n      console.log(\"인증 상태\", currentuser);\n      setUser(currentuser);\n    });\n\n    return () =\u003e {\n      unsubscribe();\n    };\n  }, []);\n```\n\n# 5. 사용자 가입 작업중:\n\n\u003cimg src=\"/assets/img/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide_1.png\" /\u003e\n\n여기서 먼저 부트스트랩을 사용하여 간단한 폼 UI를 만들겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이메일과 비밀번호에 대한 값은 각각 이메일(email)과 비밀번호(password)로 설정할 것입니다.\n\n```js\n\u003cForm.Group className=\"mb-3\" controlId=\"formBasicEmail\"\u003e\n    \u003cForm.Control\n        type=\"email\"\n        placeholder=\"이메일 주소\"\n        onChange={(e) =\u003e setEmail(e.target.value)}\n    /\u003e\n\u003c/Form.Group\u003e\n\n\u003cForm.Group className=\"mb-3\" controlId=\"formBasicPassword\"\u003e\n    \u003cForm.Control\n        type=\"password\"\n        placeholder=\"비밀번호\"\n        onChange={(e) =\u003e setPassword(e.target.value)}\n    /\u003e\n\u003c/Form.Group\u003e\n```\n\n회원가입 기능을 구현하기 위해 UserAuthContext.js 파일의 context API를 사용할 것입니다.\n\n```js\nconst Signup = () =\u003e {\n    const [email, setEmail] = useState(\"\");\n    const [error, setError] = useState(\"\");\n    const [password, setPassword] = useState(\"\");\n    const { signUp } = useUserAuth();\n    let navigate = useNavigate();\n\n    const handleSubmit = async (e) =\u003e {\n        e.preventDefault();\n        setError(\"\");\n        try {\n            await signUp(email, password);\n            navigate(\"/\");\n        } catch (err) {\n            setError(err.message);\n        }\n    };\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 6. 유저 로그인 작업 중:\n\n![User Login](/assets/img/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide_2.png)\n\n회원가입과 완전히 같은 방식으로, 부트스트랩을 사용하여 이메일과 비밀번호 값을 설정하는 로그인 페이지를 디자인할 것입니다. 다만 회원가입 기능 대신 로그인 기능을 사용할 것입니다.\n\n또한 Google 로그인을 위해 react-google-button을 사용하여 디자인할 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cGoogleButton className=\"g-btn\" type=\"dark\" onClick={handleGoogleSignIn} /\u003e\n```\n\n```js\nconst handleGoogleSignIn = async (e) =\u003e {\n  e.preventDefault();\n  try {\n    await googleSignIn();\n    navigate(\"/home\");\n  } catch (error) {\n    console.log(error.message);\n  }\n};\n```\n\n# 7. 보호된 라우트:\n\nReactJS에서 보호된 라우트란 응용 프로그램의 경로 중 인증된 사용자만 액세스할 수있는 경로를 나타냅니다. 일부 응용 프로그램의 특정 부분에 대한 액세스를 제한하여 로그인에 성공한 사용자 만이 특정 페이지 또는 구성 요소를 볼 수 있도록합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReactJS 애플리케이션에서 보호된 경로를 구현하는 방법에 대한 단계별 안내서가 있어요:\n\n![이미지](/assets/img/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide_3.png)\n\nApp.js에서 `Home /`을 보호된 경로로 설정할 거에요,\n\n```js\n\u003cRoute\n  path=\"/home\"\n  element={\n    \u003cProtectedRoute\u003e\n      \u003cHome /\u003e\n    \u003c/ProtectedRoute\u003e\n  }\n/\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 PretectedRoute.js 파일에서는 사용자가 로그인했는지 여부를 확인하고, 로그인되지 않은 경우 로그인 페이지로 리디렉션합니다.\n\n```js\nconst ProtectedRoute = ({ children }) =\u003e {\n  const { user } = useUserAuth();\n\n  console.log(\"Check user in Private: \", user);\n  if (!user) {\n    return \u003cNavigate to=\"/\" /\u003e;\n  }\n  return children;\n};\n```\n\n이 포괄적인 기사에서는 ReactJS 애플리케이션에서 Firebase를 사용하여 인증하고 디자인하기 위해 Bootstrap을 사용하여 로그인 및 사용자 가입 기능을 구현하는 방법에 대해 탐구했습니다. ReactJS의 기본적인 이해가 있다고 가정하여 ReactJS 프로젝트 설정부터 Firebase 프로젝트 생성 및 Firebase 인증 구성에 이르기까지 모든 중요한 단계를 다루었습니다.\n\n이 기사가 ReactJS 애플리케이션에서 견고한 로그인 및 사용자 가입 기능을 구현할 수 있는 지식과 자신감을 제공했기를 바랍니다. 여기서 제시된 단계를 따라가면 사용자의 전체 경험을 향상시키는 안전하고 사용자 친화적인 인증 시스템을 만들기 위한 준비가 충분히 갖춰집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n행복한 코딩과 ReactJS 앱을 Firebase와 Bootstrap으로 멋지게 만드는 여정에 행운을 빕니다!\n\nGitHub에서 소스 코드를 확인하세요.\n","ogImage":{"url":"/assets/img/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":11},{"title":"React Webpack에 대한 Fallback 구축 방법 -  Module not found Error","description":"","date":"2024-05-01 17:50","slug":"2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError","content":"\n\u003cimg src=\"/assets/img/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError_0.png\" /\u003e\n\n리액트 프로젝트에 google-sheets npm 패키지를 통합하려고 했는데 \"모듈을 찾을 수 없음: 오류 ...\"라는 오류 메시지가 나타났어요. 스택 추적을 통해 여러 종속성을 설치하면이 문제를 해결할 수 있다는 정보를 얻었지만, 그렇게 해도 여전히 이 오류가 발생했어요. 이 오류를 해결하려면 모듈을 찾을 수 없는 오류를 방지하기 위해 종속성과 대체값을 포함해야 합니다.\n\n## 우리의 오류 주요 부분\n\n이 문제를 해결하기 전에 스택 추적에서 몇 가지 항목을 이해해야 합니다. 오류 메시지의 첫 번째이자 가장 중요한 부분은 다음 줄입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n중요 변경 사항: webpack \u003c 5는 기본적으로 node.js 핵심 모듈을 위한 폴리필을 포함했었습니다. 이제는 그렇지 않습니다. 이 모듈이 필요한지 확인하고 그에 대한 폴리필을 구성하세요.\n```\n\n이 줄은 이 문제를 해결하는 데 필요한 모든 맥락을 제공하지만, webpack은 무엇이며 폴리필은 무엇인지, 그리고 중요 변경이란 무엇인지 등 궁금증을 불러일으킵니다. 먼저 webpack이 무엇인지 알아보겠습니다.\n\n## Webpack이란?\n\nUI / UX에 대한 중요한 디자인 고려 사항 중 하나는 속도입니다. 사용자들은 페이지의 구조나 자산이로드되기를 기다리고 싶어하지 않습니다. 첫 콘텐츠 렌더링 시간을 줄이고, 네트워크 트래픽을 감소시키고 사용자 경험을 향상시킬 수 있는 모든 방법을 고려해야 합니다. 이를 돕기 위해 우리는 webpack을 사용합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹팩은 자바스크립트 모듈, CSS 스타일, HTML 코드 및 기타 자산을 가져와 서버에서 요청하는 클라이언트로 최적화되어 전송되는 방식을 최적화하는 모듈 번들러입니다. 의존성 그래프를 생성하여 이러한 자산 및 코드가 클라이언트로 전송될 때 결합되는 방식을 최적화하는 데 도움이 됩니다.\n\n![Webpack Image](/assets/img/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError_1.png)\n\n이미지에는 여러 .js, .css 및 .png 파일이 몇 가지 항목으로 컴파일되어 클라이언트와 공유됩니다. 이것은 SPA(싱글 페이지 애플리케이션)를 빠르게 만드는 방식으로 코드를 구성하는 데 도움이 되어 React와 같은 프론트엔드 프레임워크에서 인기 있는 도구입니다.\n\n## 무엇이 중요한 변경 사항인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중요한 변경 사항을 이해하기 위해서는 소프트웨어 버전 관리를 이해해야 합니다. 소프트웨어는 비트와 바이트, 1과 0으로 이루어져 있죠. 이 원자적인 단위를 넘어, 소프트웨어는 살아 숨 쉬는 존재입니다. 개발자들은 소프트웨어 코드를 수정합니다. 새로운 기능을 추가하고 기존 기능을 업데이트합니다. 변경되고 업데이트되는 의존성에 대응하여 엔드 사용자들에게 스무스한 경험을 제공하기 위해 노력합니다.\n\n하지만 모든 변경이 안전한 것은 아닙니다. 그래서 소프트웨어는 버전 관리 방법을 갖고 있습니다. 아니, 우리는 물건을 '내 패키지 1', '내 패키지 2'와 같이 이름 붙이는 것이 아니에요. 대신 다음과 같은 3자리 숫자 형식을 사용합니다:\n\n![이미지](/assets/img/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError_2.png)\n\n왼쪽에서 오른쪽으로 읽을 때, 첫 번째 숫자는 주요 버전입니다. 이 숫자는 주요 소프트웨어 변경 사항이 발생할 때마다 올라갑니다. 이 변경 사항은 의존하는 프로그램에 영향을 미칠 것으로 확신되는 변경 사항이기 때문에 '중요한 변경 사항'이라 불립니다. 변경 사항에는 리소스나 메서드에 대한 다른 이름이나 기존 프로그램이 데이터를 찾지 못하게 만들 수 있는 API 구조의 변화 등이 포함될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가운데 숫자는 마이너 버전 변경을 나타냅니다. 이는 새로운 기능을 도입할 수 있지만, 소프트웨어 내의 기존 기능에는 영향을 미치지 않아야 합니다. 마지막 숫자는 패치 버전 변경이며, 기능을 확장하지는 않고 오직 고장난 코드를 수정하는 버그 수정을 의미합니다.\n\n오류 메시지에서 볼 수 있듯이, Webpack 5보다 큰 모든 주요 버전에서 중단 변경이 발생했습니다.\n\n## 폴리필이란 무엇인가요?\n\n소프트웨어는 정적이 아니며, 프로그램의 각 버전이나 그것에 액세스하는 도구는 예기치 못한 효과를 초래할 수 있습니다. 웹 개발자들은 HTML5 및 CSS3 코드를 사용할 때 발생하는 브라우저 문제에 대해 이 문제를 알고 있습니다. 이것이 caniuse.com과 같은 웹 사이트가 인기 있는 이유입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nECMAScript 버전은 HTML5와 CSS3처럼 작동하여, 새로운 버전에서는 오래된 JavaScript 버전과 호환되지 않는 기능이 추가됩니다. ECMAScript의 새로운 버전은 개발자들에게 개발을 더 쉽게 만들어주는 내장 메소드와 구조를 제공하지만, 클라이언트가 해당 코드를 지원하지 않을 경우에는 오작동한 코드를 유발할 수 있습니다. 이때 폴리필이 도움이 됩니다.\n\n폴리필은 웹 브라우저에서 해당 기능을 지원하지 않는 경우에 해당 기능의 기능성을 구현하는 코드 조각입니다. 이를 통해 개발자들은 최신 웹 기능을 사용할 수 있으면서도 프로그램이 오래된 브라우저에서도 작동하는 것을 보장할 수 있습니다.\n\n우리가 보고 있는 오류를 해결하려면 의존성 후폭풍을 추가할 수 있습니다. 우리의 코드가 webpack 5에서 제외된 내장 노드.js 모듈을 찾을 때, 실패하는 대신에, 우리가 제공하고 대신 사용할 대체 패키지를 찾을 것입니다.\n\n## NPM과 폴리필을 사용하여 모듈을 찾을 수 없는 오류를 어떻게 해결할 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹팩이 무엇인지, 소프트웨어 버전 관리 방법 및 폴리필이 무엇인지에 대해 이야기했습니다. 이제 모듈을 찾을 수 없는 오류를 해결할 준비가 되었습니다. 브라우저 JavaScript와 서버 JavaScript는 사용할 수 있는 패키지가 다르기 때문에, 누락된 모듈 오류를 해결하기 위해 필요한 패키지를 다운로드해야할 수 있습니다.\n\n이 오류를 해결하기 위해 해결해야 할 문제가 두 가지 있습니다:\n\n- 프로젝트에 필요한 npm 패키지가 포함되어 있지 않음\n- 클라이언트 친화적인 패키지를 사용하고, 노드 패키지를 웹 패키지로 매핑해야 함\n\n오류 메시지에서 필요한 모든 정보를 얻을 수 있습니다. 첫 번째 단계는 누락된 패키지를 포함해야 합니다. 예를 들어 path 패키지를 살펴보겠습니다. 이것은 표준 노드 패키지이지만 클라이언트 친화적이지 않습니다. 우리의 React 앱에 필요한 것은 path-browserify 패키지입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 path-browserify를 npm install할 수 있지만, 이것은 첫 번째 단계만 해결합니다. 앱을 작동시키기 위해서는 webpack에게 path 대신 path-browserify를 찾도록 해야 합니다. webpack.config.js 파일로 이동할 수 있습니다:\n\n```bash\n/node_modules/react_scripts/config/webpack.config.js\n```\n\n이 파일은 로컬 서버를 react 스크립트 명령(npm start dev)으로 시작할 때 webpack 설정을 다룹니다. 우리는 이전 의존성인 path를 새 의존성인 path-browserify로 매핑하고자 합니다. 이 매핑에 대한 예외 처리 또는 catch 문을 사용하고 있으므로 이를 명확히 해주어야 합니다.\n\n만약 파일에서 \"fallback: \"을 검색하면, 모듈에 대한 여러 예외 매핑을 넣을 수 있는 해시를 찾을 수 있습니다. 에러 문구에서 코드를 복사하여 다음과 같이 해시에 넣어주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError_3.png)\n\n서버를 재시작해야 할 수도 있지만, 종속성을 설치하고 폴백 경로를 추가하면 오류가 해결될 것입니다!\n","ogImage":{"url":"/assets/img/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError_0.png"},"coverImage":"/assets/img/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError_0.png","tag":["Tech"],"readingTime":5},{"title":"Socket.io, React.js, Node.js 및 Express.js를 사용한 실시간 애플리케이션 만들기","description":"","date":"2024-05-01 17:48","slug":"2024-05-01-BuildingReal-TimeApplicationswithSocketioReactjsNodejsandExpressjsAComprehensiveGuide","content":"\n\n**실시간 웹 개발: Socket.io, React.js, Node.js 및 Express.js를 활용한 대화형 애플리케이션 구축에 대한 포괄적인 가이드**\n\n![BuildingReal-TimeApplicationswithSocketioReactjsNodejsandExpressjsAComprehensiveGuide_0.png](/assets/img/2024-05-01-BuildingReal-TimeApplicationswithSocketioReactjsNodejsandExpressjsAComprehensiveGuide_0.png)\n\n오늘날의 디지털 환경에서 실시간 통신은 웹 애플리케이션의 중요한 측면이 되었습니다. 채팅 애플리케이션, 협업 도구 또는 실시간 업데이트와 같이 사용자는 페이지를 새로 고치지 않고 즉시 업데이트를 기대합니다. 이것이 Socket.io, React.js, Node.js 및 Express.js가 등장하는 곳입니다.\n\nSocket.io는 웹 서버와 클라이언트 간의 양방향 및 이벤트 기반 통신을 가능하게 하는 강력한 라이브러리입니다. React.js, 사용자 인터페이스를 구축하기 위한 인기 있는 JavaScript 라이브러리, 그리고 Express.js를 통한 Node.js와 결합하면 다양한 웹 애플리케이션을 만들 수 있는 다재다능한 웹 애플리케이션 프레임워크를 통해 개발자는 원활하고 대화형 실시간 애플리케이션을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 블로그에서는 Socket.io의 기본을 탐구하고 React.js, Node.js, Express.js와 통합하는 방법을 알아볼 것입니다. 우리는 기본 개념, 단계별 구현 방법, 실시간 애플리케이션을 구축하는 데 가장 좋은 방법에 대해 이야기할 것입니다. 이 안내서를 마치면 이러한 기술을 활용하여 사용자가 실시간으로 참여하는 동적이고 반응적인 어플리케이션을 만드는 방법에 대해 확고한 이해를 갖게 될 것입니다. 그러니 Socket.io, React.js, Node.js, Express.js와 함께하는 실시간 웹 개발의 흥미로운 여정을 시작해봅시다!\n\n먼저 클라이언트 및 서버 폴더가 필요합니다. 서버 폴더에서 Node.js 프로젝트를 초기화하세요.\n\n```js\nnpm init\n```\n\n그런 다음 필요한 종속성(Express, Cors, Nodemon, Socket.io)을 설치하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm install express cors nodemon socket.io\n```\n\n- Express: Express는 Node.js를 위한 인기 있는 웹 애플리케이션 프레임워크입니다. 웹 애플리케이션과 API를 구축하는 간편하고 유연한 방법을 제공합니다.\n- Cors: Cross-Origin Resource Sharing (CORS)는 웹 브라우저에 의해 구현된 보안 메커니즘으로, 다른 출처의 리소스에 대한 액세스를 제한합니다. 웹 애플리케이션을 개발할 때, 하나의 도메인에서 다른 도메인으로 요청을 보낼 때 CORS 문제가 발생할 수 있습니다. cors 라이브러리를 사용하여 Express 애플리케이션에서 CORS 관련 문제를 처리합니다.\n- Nodemon: Nodemon은 소스 코드에 변경 사항이 감지될 때마다 Node.js 애플리케이션을 자동으로 다시 시작하는 개발 유틸리티입니다.\n- Socket.io: Socket.io는 웹 브라우저와 서버 간에 실시간 양방향 통신을 가능하게 하는 JavaScript 라이브러리입니다. 주로 즉각적인 데이터 업데이트나 대화형 기능이 필요한 애플리케이션을 구축하는 데 사용됩니다.\n\n그 후, 서버 폴더에 index.js 파일을 만들고 다음 코드를 추가하세요.\n\n```js\nconst express = require('express');\nconst app = express();\nconst http = require('http');\nconst { Server } = require(\"socket.io\");\nconst cors = require('cors');\napp.use(cors());\n\nconst server = http.createServer(app);\nconst io = new Server(server, {\n    cors: {origin:\"http://localhost:3000\", methods: [\"GET\", \"POST\"]},\n});\n\nserver.listen(4000, () =\u003e { console.log(\"listening on *:4000\"); });\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 클라이언트 폴더로 이동하여 리액트 앱을 만들어봅시다.\n\n```js\nnpx create-react-app .\n```\n\n여기서 소켓 IO 클라이언트 종속성을 설치해야 합니다.\n\n```js\nnpm install socket.io-client\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱.js에 다음 코드를 추가하세요.\n\n```js\nimport \"./App.css\";\nimport { useEffect } from \"react\";\nimport io from \"socket.io-client\";\nconst socket = io.connect(\"http://localhost:4000\");\n\nfunction App() {\n  function sendMessage() {\n    console.log(\"버튼 클릭됨\");\n    socket.emit(\"send_message\", { message: \"클라이언트에서 안녕하세요\" });\n  }\n  useEffect(() =\u003e {\n    socket.on(\"receive_message\", (data) =\u003e {\n      alert(data.message);\n    });\n  }, [socket]);\n\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cinput placeholder=\"메시지\" /\u003e\n      \u003cbutton onClick={sendMessage}\u003e메시지 보내기\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n게다가, 서버 폴더에 있는 index.js 파일에 다음 코드를 추가하세요.\n\n```js\nio.on(\"connection\", (socket) =\u003e {\n  console.log(`유저가 연결되었습니다 ${socket.id}`);\n  \n  socket.on(\"send_message\", (data) =\u003e {\n    socket.broadcast.emit(\"receive_message\", data);\n  });\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드 줄들로 기본 메시지 '클라이언트에서 안녕하세요'를 보낼 수 있고, 다른 모든 사용자에게 방송할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*owCRflCEFkCAw6365cvt0g.gif)\n\n지금까지 socket.io가 올바르게 작동하고 있습니다. 이제 할 일은 메시지 데이터를 전송하는 것뿐입니다.\n\n여기 클라이언트 앱의 최종 버전인 app.js 파일이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport \"./App.css\";\nimport { useEffect, useState } from \"react\";\nimport io from \"socket.io-client\";\nconst socket = io.connect(\"http://localhost:4000\");\n\nfunction App() {\n  const [message, setMessage] = useState(\"\");\n  const [messageReceived, setMessageReceived] = useState(\"\");\n  function sendMessage() {\n    console.log(\"Button clicked\");\n    socket.emit(\"send_message\", { message: message });\n  }\n  useEffect(() =\u003e {\n    socket.on(\"receive_message\", (data) =\u003e {\n      setMessageReceived(data.message);\n    });\n  }, [socket]);\n\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cinput\n        placeholder=\"메시지를 입력하세요\"\n        onChange={(e) =\u003e {\n          setMessage(e.target.value);\n        }}\n      /\u003e\n      \u003cbutton onClick={sendMessage}\u003e메시지 보내기\u003c/button\u003e\n      \u003ch1\u003e\n        받은 메시지: {messageReceived}\n      \u003c/h1\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n서버의 index.js 파일 최종 버전은 다음과 같습니다.\n\n```js\nconst express = require(\"express\");\nconst app = express();\nconst http = require(\"http\");\nconst { Server } = require(\"socket.io\");\nconst cors = require(\"cors\");\napp.use(cors());\n\nconst server = http.createServer(app);\nconst io = new Server(server, {\n  cors: { origin: \"http://localhost:3000\", methods: [\"GET\", \"POST\"] },\n});\n\nio.on(\"connection\", (socket) =\u003e {\n  console.log(`사용자가 연결되었습니다: ${socket.id}`);\n\n  socket.on(\"send_message\", (data) =\u003e {\n    socket.broadcast.emit(\"receive_message\", data);\n  });\n});\nserver.listen(4000, () =\u003e {\n  console.log(\"4000번 포트에서 수신 대기 중\");\n});\n```\n\n최종 결과는 다음과 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Real-time applications](https://miro.medium.com/v2/resize:fit:1400/1*f0e54kuZSGu0pvAivmOJug.gif)\n\n이 포괄적인 가이드는 Socket.io, React.js, Node.js 및 Express.js를 사용하여 실시간 애플리케이션을 구축하는 방법을 탐구합니다. 이러한 기술을 활용하여 개발자는 사용자에게 즉각적인 업데이트를 제공하는 동적 대화형 애플리케이션을 만들 수 있습니다. 이 안내서는 기본 개념, 단계별 구현 및 모베스트 프랙티스를 다룹니다. 전체 소스 코드는 GitHub 저장소 https://github.com/matheshyogeswaran/React_socket_io.git 를 방문해주세요. 즐겁게 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-01-BuildingReal-TimeApplicationswithSocketioReactjsNodejsandExpressjsAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-01-BuildingReal-TimeApplicationswithSocketioReactjsNodejsandExpressjsAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":6},{"title":"리액트 라우터 기초 내용 정리","description":"","date":"2024-05-01 17:47","slug":"2024-05-01-ReactRouterNavigateYourAppswithEase","content":"\nReact Router는 React 애플리케이션을 위한 강력한 라우팅 라이브러리입니다. URL을 기반으로 다른 컴포넌트를 렌더링하고 탐색을 처리하는 것을 통해 전체 페이지 새로 고침이 필요하지 않도록 해줍니다. 간단히 말해, React Router는 사용자 인터페이스가 URL 변경에 동적으로 업데이트되어 사용자에게 더 부드럽고 원활한 브라우징 경험을 제공하는 단일 페이지 애플리케이션(SPA)을 만드는 데 도움을 줍니다.\n\nReact Router를 사용하는 장점:\n\n- 클라이언트 측 라우팅: 페이지 전체를 새로 고치지 않고 뷰 간의 부드럽고 빠른 전환이 가능하여 좀 더 원활한 사용자 경험을 제공합니다.\n- 선언적 라우팅: React 컴포넌트 내에서 라우트를 쉽게 정의하고 관리할 수 있습니다.\n- 동적 라우팅: React Router는 동적 라우팅을 지원하여 개발자가 URL 매개변수를 사용하여 라우트를 생성하고 URL에 따라 동적 콘텐츠를 렌더링할 수 있습니다. 이를 통해 React를 사용하여 동적이고 데이터로 구동되는 사용자 인터페이스를 구축할 수 있습니다.\n- 중첩된 라우팅: React Router는 중첩된 라우트를 지원하여 중첩된 컴포넌트와 라우트로 복잡한 UI 계층 구조를 만들 수 있습니다. 이는 다수의 탐색 수준을 갖는 대규모 애플리케이션을 구성하고 관리하는 데 유용합니다.\n- 리다이렉트 및 오류 처리: 예상치 못한 상황에서도 사용자 경험을 향상시킵니다.\n\nReact Router를 사용하는 방법은 어떻게 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 설치: 먼저 npm 또는 yarn을 사용하여 React Router를 설치하세요:\n\n```js\nnpm install react-router-dom\n또는\nyarn add react-router-dom\n```\n\n2. 라우트 설정: 주로 App.js와 같은 주요 컴포넌트 파일을 연 후 react-router-dom에서 필요한 컴포넌트를 가져옵니다.\n\n라우트를 설정하는 과정에서 `BrowserRouter`의 역할을 이해하는 것이 중요합니다. 이 컴포넌트는 애플리케이션의 최상위 래퍼로 작동하여 클라이언트 측 라우팅을 가능하게 합니다. 우리의 전체 애플리케이션을 `BrowserRouter`로 감싸면 내비게이션과 라우트 변경을 원활하게 처리할 수 있습니다. `BrowserRouter`를 우리 애플리케이션의 내비게이션의 주요 컨트롤러로 생각해보세요. 이를 통해 애플리케이션 내의 모든 컴포넌트가 라우팅 기능에 액세스할 수 있게 되며, 효과적으로 라우트를 정의하고 관리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { BrowserRouter as Router, Route, Switch } from \"react-router-dom\";\n```\n\n리액트 앱에서 주요 구성 요소인 보통 App이 모든 것을 제어합니다. 그러나 React Router를 추가하면 Router 구성 요소가 새로운 주인이 됩니다. 이는 네비게이션에 대한 마스터 컨트롤러와 같습니다. Router를 가장 높은 부모로 만들면 모든 구성 요소가 라우팅 슈퍼파워에 액세스할 수 있습니다. 이렇게 하면 다른 페이지 간에 쉽게 이동하고 라우트 정보에 액세스할 수 있습니다. 요약하면 최상위 부모로 Router를 사용하면 앱의 모든 구성 요소가 React Router의 혜택을 누릴 수 있습니다.\n\n가장 간단한 방법으로 React Router를 설정하려면 index.js 파일에 다음을 포함하십시오:\n\n```js\nReactDOM.render(\n  \u003cRouter\u003e\n    \u003cApp /\u003e\n  \u003c/Router\u003e\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 네비게이션에 링크 사용하기: React 애플리케이션에서 React Router를 사용하여 네비게이션을 위해 `Link` 컴포넌트를 사용하려면, React Router에서 Link를 import하십시오.\n\n```js\nimport { Link } from \"react-router-dom\";\n```\n\nReact Router의 `Link` 컴포넌트는 애플리케이션의 서로 다른 경로 간에 링크를 생성하는 데 사용됩니다. 이는 전통적인 HTML `a` 태그와 유사하지만, React Router를 사용하는 React 애플리케이션 내에서 사용하도록 특별히 디자인되었습니다.\n\n일반적으로 `Link`를 사용하는 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cLink to=\"/about\"\u003eAbout\u003c/Link\u003e\n```\n\n클릭 가능한 링크를 만들기 위해 `Link`를 사용합니다. `to` 속성은 클릭했을 때 링크가 이동해야 하는 대상 URL을 지정합니다.\n\n`Link`를 클릭하면 React Router가 네비게이션 이벤트를 가로채고 전체 페이지 새로고침 없이 브라우저의 URL을 업데이트합니다. 이를 통해 React 애플리케이션 내에서 부드러운 클라이언트 측 네비게이션이 가능해집니다.\n\n라우트 매개변수와 동적 라우트\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라우트 매개변수는 URL 패턴 내 동적 값을 캡처하고 동적 경로를 생성할 수 있는 자리 표시자입니다. 이 매개변수들은 콜론(:)으로 시작하고 매개변수 이름이 따라온 루트 경로에 정의됩니다. 예를 들어, 루트 경로 /users/:id에서 :id는 라우트 매개변수입니다.\n\n예를 들어, 블로그 애플리케이션에서 각 블로그 게시물이 고유한 식별자(ID)를 가지는 경우를 생각해보세요. 개별 블로그 게시물마다 별도의 경로를 만드는 대신, 포스트 ID를 라우트 매개변수로 캡처하는 단일 동적 경로를 만들 수 있습니다:\n\n```js\n\u003cRoute path=\"/posts/:postId\" component={PostDetail} /\u003e\n```\n\n이 라우트에서 :postId는 블로그 게시물의 고유 식별자를 나타내는 라우트 매개변수입니다. 사용자가 /posts/123과 같은 URL로 이동할 때, React Router는 postId 매개변수로 값 123을 캡처합니다. 이 매개변수는 그런 다음 PostDetail 컴포넌트 내에서 액세스하여 해당 블로그 게시물 콘텐츠를 가져와 표시할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루트 매개변수를 사용하여 응용 프로그램에서 보다 유연하고 유지 관리 가능한 라우팅 로직을 만들 수 있습니다. 각 가능한 값에 대해 개별 라우트를 하드코딩할 필요 없이 동적 데이터를 처리할 수 있기 때문에 응용 프로그램이 성장함에 따라 더 확장 가능하고 유지 관리하기 쉬워집니다.\n\n루트 매개변수에 액세스하기\n\n루트 매개변수는 URL 경로에 정의된 루트 매개변수의 값을 액세스할 수 있습니다. 이러한 후크는 useParams 또는 match.params와 같은 React Router 후크를 사용하여 구성 요소 내에서 액세스할 수 있습니다.\n\n함수형 구성 요소에서 useParams 후크를 사용하세요 :\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { useParams } from \"react-router-dom\";\n\nconst ComponentName = () =\u003e {\n  const { parameterName } = useParams();\n  // parameterName에 접근\n};\n```\n\n에러 처리 및 모범 사례:\n\n모든 애플리케이션에서 라우팅 오류와 같은 404 오류 또는 잘못된 경로와 관련된 오류 처리를 고려하는 것이 중요합니다.\n\n에러 처리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 404 페이지 구현: 알 수 없는 경로가 발생했을 때 특정 컴포넌트를 디자인해주세요.\n- 기본 경로로 리다이렉트: 알려진 경로로 사용자를 리다이렉션하여 예비 메커니즘을 고려해주세요.\n- 명확한 오류 메시지 제공: 네비게이션 오류에서 복구하는 방법을 안내하기 위해 유용한 메시지를 사용해주세요.\n\n![이미지](/assets/img/2024-05-01-ReactRouterNavigateYourAppswithEase_0.png)\n\n효과적인 라우트 구성\n\n- 관련 라우트 그룹화: 논리적으로 연결된 라우트를 그룹화해주세요 (예: /products, /products/new, /products/:productId).\n- 라우트 파일 모듈화: 큰 애플리케이션의 경우 기능 또는 앱의 섹션에 따라 라우트 구성을 별도 파일로 분리해주세요.\n- 지연 로딩으로 코드 분할: 대규모 애플리케이션의 초기 로딩 시간을 개선하기 위해 요청에 따라 라우트를 로드해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n공식 문서\n\n더 많은 기능과 가능성에 대해 자세히 알아보려면 공식 리액트 라우터 문서를 확인해보세요: [링크](https://reactrouter.com/)\n","ogImage":{"url":"/assets/img/2024-05-01-ReactRouterNavigateYourAppswithEase_0.png"},"coverImage":"/assets/img/2024-05-01-ReactRouterNavigateYourAppswithEase_0.png","tag":["Tech"],"readingTime":5},{"title":"React 19 Beta 릴리스, 새로운 기능 소개 및 정리","description":"","date":"2024-05-01 17:45","slug":"2024-05-01-React19BetaReleasedWhatYouNeedtoKnow","content":"\n\n![이미지](/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png)\n\n지난 2022년 6월 React의 마지막 안정 버전 이후, 두 년 가까이 새 버전이 나오지 않았는데, 이제 npm에서 React 19 베타판이 안정 버전인 React 18.3.0과 함께 공개되었습니다. React 19 베타판에서 개발자들이 알아야 할 새로운 기능을 살펴보겠습니다.\n\n## 액션\n\n![이미지](/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 앱에서 흔히 발생하는 사용 사례는 데이터 변이를 수행한 다음 응답에 따라 상태를 업데이트하는 것입니다. 예를 들어, 사용자가 이름을 변경하기 위해 양식을 제출하면 API 요청을 만들고 그 다음 응답을 처리해야 합니다. 과거에는 보류 중인 상태, 오류, 낙관적 업데이트 및 순차 요청을 수동으로 처리해야 했습니다.\n\n예를 들어, useState로 대기 및 오류 상태를 처리할 수 있었습니다:\n\n```js\n// 액션 이전\nfunction UpdateName({}) {\n  const [name, setName] = useState(\"\");\n  const [error, setError] = useState(null);\n  const [isPending, setIsPending] = useState(false);\n\n  const handleSubmit = async () =\u003e {\n    setIsPending(true);\n    const error = await updateName(name);\n    setIsPending(false);\n    if (error) {\n      setError(error);\n      return;\n    } \n    redirect(\"/경로\");\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cinput value={name} onChange={(event) =\u003e setName(event.target.value)} /\u003e\n      \u003cbutton onClick={handleSubmit} disabled={isPending}\u003e\n        업데이트\n      \u003c/button\u003e\n      {error \u0026\u0026 \u003cp\u003e{error}\u003c/p\u003e}\n    \u003c/div\u003e\n  );\n}\n```\n\n리액트 19에서는 전이에 비동기 함수를 사용하여 대기 중인 상태, 오류, 양식 및 낙관적 업데이트를 자동으로 처리할 수 있는 지원이 추가되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, useTransition을 사용하여 대기 상태를 처리할 수 있습니다:\n\n```js\n// Actions에서 대기 상태 사용하기\nfunction UpdateName({}) {\n  const [name, setName] = useState(\"\");\n  const [error, setError] = useState(null);\n  const [isPending, startTransition] = useTransition();\n\n  const handleSubmit = async () =\u003e {\n    startTransition(async () =\u003e {\n      const error = await updateName(name);\n      if (error) {\n        setError(error);\n        return;\n      } \n      redirect(\"/path\");\n    })\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cinput value={name} onChange={(event) =\u003e setName(event.target.value)} /\u003e\n      \u003cbutton onClick={handleSubmit} disabled={isPending}\u003e\n        Update\n      \u003c/button\u003e\n      {error \u0026\u0026 \u003cp\u003e{error}\u003c/p\u003e}\n    \u003c/div\u003e\n  );\n}\n```\n\n비동기 전환은 즉시 isPending 상태를 true로 설정하고 비동기 요청을 수행한 다음 이전 전환 후에 isPending를 false로 전환합니다. 이렇게 하면 데이터가 변경되는 동안에도 현재 UI를 반응적이고 상호작용할 수 있게 유지할 수 있습니다.\n\n관례적으로, 비동기 전환을 사용하는 함수는 \"Actions\"라고 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n동작은 데이터 제출을 자동으로 처리해줍니다:\n\n- 보류 상태: 동작은 요청의 시작부터 시작되는 보류 상태를 제공하며, 최종 상태 업데이트가 완료될 때 자동으로 재설정됩니다.\n- 낙관적 업데이트: 동작은 새로운 useOptimistic 훅을 지원하여 요청이 제출되는 동안 사용자에게 즉시 피드백을 제공할 수 있습니다.\n- 오류 처리: 동작은 오류 처리를 제공하여 요청이 실패했을 때 오류 경계를 표시하고, 낙관적 업데이트를 자동으로 원래 값으로 되돌립니다.\n- 폼: 이제 `form` 요소는 동작과 formAction props에 함수를 전달할 수 있습니다. action props에 함수를 전달하면 기본적으로 동작을 사용하고 제출 후 자동으로 폼을 재설정합니다.\n\nReact 19에서 동작을 기반으로하면 낙관적 업데이트를 관리하는 useOptimistic 및 동작의 공통 사례를 처리하는 새로운 hook인 React.useActionState를 도입했습니다. react-dom에서는 `form` 동작을 사용하여 폼을 자동으로 처리하고, 동작의 공통 사례를 지원하는 useFormStatus를 추가했습니다.\n\nReact 19에서 위 예제는 간단하게 변경될 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// \u003cform\u003e 작업 및 useActionState 사용하기\nfunction ChangeName({ name, setName }) {\n  const [error, submitAction, isPending] = useActionState(\n    async (previousState, formData) =\u003e {\n      const error = await updateName(formData.get(\"name\"));\n      if (error) {\n        return error;\n      }\n      redirect(\"/path\");\n    }\n  );\n\n  return (\n    \u003cform action={submitAction}\u003e\n      \u003cinput type=\"text\" name=\"name\" /\u003e\n      \u003cbutton type=\"submit\" disabled={isPending}\u003e업데이트\u003c/button\u003e\n      {error \u0026\u0026 \u003cp\u003e{error}\u003c/p\u003e}\n    \u003c/form\u003e\n  );\n}\n```\n\n# 새로운 훅: useActionState\n\nReact 19에서 일반적인 케이스를 보다 쉽게 만들기 위해 useActionState라는 새로운 훅이 추가되었습니다:\n\n```js\nconst [error, submitAction, isPending] = useActionState(async (previousState, newName) =\u003e {\n  const error = await updateName(newName);\n  if (error) {\n    // 작업의 결과로 어떤 것이든 반환할 수 있습니다.\n    // 여기서는 오직 에러만 반환합니다.\n    return error;\n  }\n  \n  // 성공 처리\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`useActionState` 함수는 함수(액션)를 인수로 받아 감싼 액션을 호출합니다. 이는 액션이 조합되기 때문에 작동합니다. 감싼 액션이 호출되면 `useActionState`는 액션의 마지막 결과를 데이터로 반환하고 액션의 보류 상태를 보류로 반환합니다.\n\n# React DOM: form 액션\n\nReact 19의 새로운 `form` 기능에 액션도 통합되어 있습니다. `form`, `input`, 그리고 `button` 엘리먼트의 액션과 formAction 프롭으로 함수를 전달하여 액션과 함께 자동으로 폼을 제출할 수 있습니다:\n\n```js\n\u003cform action={actionFunction}\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`form`이 성공하면 React는 제어되지 않는 컴포넌트를 위해 자동으로 `form`을 재설정합니다. `form`을 수동으로 재설정해야 하는 경우, 새 요청 `form` 재설정 React DOM API를 호출할 수 있습니다.\n\n# React DOM: 새로운 훅: useFormStatus\n\n디자인 시스템에서 `form`에 대한 정보에 액세스해야 하는 디자인 컴포넌트를 작성하는 것이 일반적입니다. 그러나 컴포넌트로 속성을 전달 받지 않아도 되도록 하는 경우가 있습니다. 이 작업은 Context를 통해 수행할 수 있지만, 일반적인 경우를 쉽게 만들기 위해 React 19에 새로운 훅인 useFormStatus가 추가되었습니다:\n\n```js\nimport {useFormStatus} from 'react-dom';\n\nfunction DesignButton() {\n  const {pending} = useFormStatus();\n  return \u003cbutton type=\"submit\" disabled={pending} /\u003e\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`useFormStatus`는 부모 `form`의 상태를 읽어오는 것처럼 동작하여, 마치 form이 Context 제공자인 것처럼 사용할 수 있습니다.\n\n# 새로운 훅: useOptimistic\n\n데이터 변경 작업을 수행할 때 또 다른 일반적인 UI 패턴은 비동기 요청 진행 중에 최종 상태를 낙관적으로 표시하는 것입니다. React 19에서는 이를 쉽게 처리할 수 있도록 `useOptimistic`라는 새로운 훅이 추가되었습니다:\n\n```js\nfunction ChangeName({currentName, onUpdateName}) {\n  const [optimisticName, setOptimisticName] = useOptimistic(currentName);\n\n  const submitAction = async formData =\u003e {\n    const newName = formData.get(\"name\");\n    setOptimisticName(newName);\n    const updatedName = await updateName(newName);\n    onUpdateName(updatedName);\n  };\n\n  return (\n    \u003cform action={submitAction}\u003e\n      \u003cp\u003eYour name is: {optimisticName}\u003c/p\u003e\n      \u003cp\u003e\n        \u003clabel\u003eChange Name:\u003c/label\u003e\n        \u003cinput\n          type=\"text\"\n          name=\"name\"\n          disabled={currentName !== optimisticName}\n        /\u003e\n      \u003c/p\u003e\n    \u003c/form\u003e\n  );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`useOptimistic` 훅은 `updateName` 요청이 진행 중일 때 즉시 `optimisticName`을 렌더링합니다. 업데이트가 완료되거나 에러가 발생하면 React가 자동으로 `currentName` 값으로 전환됩니다.\n\n# 새 API: use\n\nReact 19에서 렌더링하는 동안 리소스를 읽기 위한 새로운 API가 추가되었습니다: `use`.\n\n예를 들어, `use`로 프로미스를 읽을 수 있으며, React가 프로미스가 해결될 때까지 일시 중단됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport {use} from 'react';\n\nfunction Comments({commentsPromise}) {\n  // `use`가 프로미스가 해결될 때까지 일시 중단됩니다.\n  const comments = use(commentsPromise);\n  return comments.map(comment =\u003e \u003cp key={comment.id}\u003e{comment}\u003c/p\u003e);\n}\n\nfunction Page({commentsPromise}) {\n  // Comments에서 `use`가 일시 중단되면\n  // 이 Suspense 경계가 표시됩니다.\n  return (\n    \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\n      \u003cComments commentsPromise={commentsPromise} /\u003e\n    \u003c/Suspense\u003e\n  )\n}\n```\n\n렌더링되는 동안 생성된 프로미스를 지원하지 않습니다.\n\n렌더링에서 만든 프로미스를 use에 전달하려고 하면 React에서 경고합니다:\n\n수정하려면, 프로미스 캐싱을 지원하는 suspense 기반 라이브러리나 프레임워크에서 프로미스를 전달해야 합니다. 미래에는 렌더링 중에 프로미스를 캐싱하기 쉽게 만드는 기능을 제공할 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한 일찍 반환한 후와 같이 조건부로 Context를 읽을 수도 있습니다:\n\n```js\nimport {use} from 'react';\nimport ThemeContext from './ThemeContext'\n\nfunction Heading({children}) {\n  if (children == null) {\n    return null;\n  }\n  \n  // 일찍 반환으로 인해 useContext로 동작하지 않습니다.\n  const theme = use(ThemeContext);\n  return (\n    \u003ch1 style={{color: theme.color}}\u003e\n      {children}\n    \u003c/h1\u003e\n  );\n}\n```\n\nuse API는 후크와 유사하게 렌더링 중에만 호출될 수 있습니다. 후크와는 다르게 use는 조건부로 호출할 수 있습니다.\n\n자세한 정보는 use에 대한 문서를 참조하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ref을 속성으로 사용하기\n\nReact 19부터 함수 컴포넌트에서 ref를 속성으로 접근할 수 있습니다:\n\n```js\nfunction MyInput({placeholder, ref}) {\n  return \u003cinput placeholder={placeholder} ref={ref} /\u003e\n}\n\n//...\n\u003cMyInput ref={ref} /\u003e\n```\n\n새로운 함수 컴포넌트는 더 이상 forwardRef가 필요하지 않습니다. 향후 버전에서 React는 forwardRef를 사용하지 않도록 하고 제거할 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 'Context'를 제공자로 렌더링하기\n\nReact 19에서 'Context.Provider' 대신 'Context'를 제공자로 렌더링할 수 있습니다:\n\n```js\nconst ThemeContext = createContext('');\n\nfunction App({children}) {\n  return (\n    \u003cThemeContext value=\"dark\"\u003e\n      {children}\n    \u003c/ThemeContext\u003e\n  );  \n}\n```\n\n나중에 React 버전에서는 'Context.Provider'를 사용하지 않도록 지원 중단될 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ref에 대한 정리 함수\n\n이제 React는 ref 콜백에서 정리 함수를 반환하는 것을 지원합니다:\n\n```js\n\u003cinput\n  ref={(ref) =\u003e {\n    // ref 생성\n\n    // 새로운 기능: 요소가 DOM에서 제거될 때 ref를 재설정하는 정리 함수를 반환합니다.\n    return () =\u003e {\n      // ref 정리\n    };\n  }\n/\u003e\n```\n\n컴포넌트가 언마운트될 때, React는 ref 콜백에서 반환된 정리 함수를 호출합니다. 이는 DOM ref, 클래스 컴포넌트에 대한 ref 및 useImperativeHandle에 대해 작동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리팩토링된 ref 정리 함수의 도입으로 인해 TypeScript에서 ref 콜백에서 다른 값을 반환하면 거부됩니다. 이 문제를 해결하는 방법은 일반적으로 암시적 반환을 사용하지 않도록 하는 것입니다. 예를 들어:\n\n```js\n- \u003cdiv ref={current =\u003e (instance = current)} /\u003e\n+ \u003cdiv ref={current =\u003e {instance = current} /\u003e\n```\n\n원본 코드는 HTMLDivElement의 인스턴스를 반환했으며 TypeScript는 이것이 정리 함수인지 아니면 정리 함수를 반환하고 싶지 않은 것인지를 알 수 없습니다.\n\n# useDeferredValue 초기 값\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact는 useDeferredValue에 initialValue 옵션을 추가했습니다:\n\n```js\nfunction Search({deferredValue}) {\n  // 초기 렌더링 시 값은 ''입니다.\n  // 그런 다음 다시 렌더링이 예약되고 deferredValue로 업데이트됩니다.\n  const value = useDeferredValue(deferredValue, '');\n  \n  return (\n    \u003cResults query={value} /\u003e\n  );\n}\n```\n\ninitialValue가 제공되면 useDeferredValue는 해당 값을 컴포넌트의 초기 렌더링에 반환하고, deferredValue를 사용하여 백그라운드에서 다시 렌더링을 예약합니다.\n\n# 문서 메타데이터 지원\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTML에서는 `title`, `link`, `meta`와 같은 문서 메타데이터 태그를 문서의 `head` 섹션에 배치하기 위해 예약되어 있어요. React에서는 앱에 적합한 메타데이터를 결정하는 컴포넌트가 `head`를 렌더링하는 곳과 매우 먼 곳에 있을 수 있거나 React가 `head`를 전혀 렌더링하지 않을 수도 있어요. 과거에는 이러한 요소들을 수동으로 삽입해야 했거나 react-helmet과 같은 라이브러리를 사용하여 효과적으로 처리해야 했던 것을 기억하시죠.\n\nReact 19는 컴포넌트에서 문서 메타데이터 태그를 네이티브로 렌더링하는 지원을 제공해요:\n\n```js\nfunction BlogPost({post}) {\n  return (\n    \u003carticle\u003e\n      \u003ch1\u003e{post.title}\u003c/h1\u003e\n      \u003ctitle\u003e{post.title}\u003c/title\u003e\n      \u003cmeta name=\"author\" content=\"Josh\" /\u003e\n      \u003clink rel=\"author\" href=\"https://twitter.com/joshcstory/\" /\u003e\n      \u003cmeta name=\"keywords\" content={post.keywords} /\u003e\n      \u003cp\u003e\n        Eee equals em-see-squared...\n      \u003c/p\u003e\n    \u003c/article\u003e\n  );\n}\n```\n\nReact가 이 컴포넌트를 렌더링할 때 `title`, `link`, `meta` 태그를 찾아서 자동으로 문서의 `head` 섹션으로 끌어올려 줘요. 이러한 메타데이터 태그를 네이티브로 지원함으로써 클라이언트 전용 앱, 스트리밍 SSR 및 서버 컴포넌트와 함께 작동하도록 보장할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact 19 업데이트 내용에 대한 의견이 궁금하신가요? React 19의 개선된 기능에 대한 자세한 내용은 React 공식 블로그의 원문을 참조해주세요.\n\n# 간단하게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작성자를 클랩하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png"},"coverImage":"/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png","tag":["Tech"],"readingTime":11}],"page":"156","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":17,"currentPageGroup":7},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"156"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>