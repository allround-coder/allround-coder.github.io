<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/130" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/130" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="리액트 타입스크립트 프로젝트에서 ESLint 설정하기 2022" href="/post/2024-05-12-SettingESLintonaReactTypescriptproject2022"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 타입스크립트 프로젝트에서 ESLint 설정하기 2022" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 타입스크립트 프로젝트에서 ESLint 설정하기 2022" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 타입스크립트 프로젝트에서 ESLint 설정하기 2022</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 네이티브 이미지 피커 구현에 대한 심층 탐구" href="/post/2024-05-12-DeepDiveintoImplementingreact-native-image-picker"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 네이티브 이미지 피커 구현에 대한 심층 탐구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-DeepDiveintoImplementingreact-native-image-picker_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 네이티브 이미지 피커 구현에 대한 심층 탐구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 네이티브 이미지 피커 구현에 대한 심층 탐구</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="함수 컴포넌트에서 React 고차 컴포넌트HOC 활용하기" href="/post/2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="함수 컴포넌트에서 React 고차 컴포넌트HOC 활용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="함수 컴포넌트에서 React 고차 컴포넌트HOC 활용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">함수 컴포넌트에서 React 고차 컴포넌트HOC 활용하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 네이티브에서 페이지와 함께 페이지네이션하기" href="/post/2024-05-12-PaginationinReactNativewithPage"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 네이티브에서 페이지와 함께 페이지네이션하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-PaginationinReactNativewithPage_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 네이티브에서 페이지와 함께 페이지네이션하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 네이티브에서 페이지와 함께 페이지네이션하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 19를 소개합니다 웹 개발의 다음 진화를 드러냅니다" href="/post/2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 19를 소개합니다 웹 개발의 다음 진화를 드러냅니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 19를 소개합니다 웹 개발의 다음 진화를 드러냅니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 19를 소개합니다 웹 개발의 다음 진화를 드러냅니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CI CD 마스터하기 GitHub Actions로 React 앱을 AWS S3에 배포하고 호스팅하기" href="/post/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CI CD 마스터하기 GitHub Actions로 React 앱을 AWS S3에 배포하고 호스팅하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CI CD 마스터하기 GitHub Actions로 React 앱을 AWS S3에 배포하고 호스팅하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">CI CD 마스터하기 GitHub Actions로 React 앱을 AWS S3에 배포하고 호스팅하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 프로젝트에서 ApexCharts를 사용하는 방법" href="/post/2024-05-12-HowToUseApexChartsinaNextjsProject"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 프로젝트에서 ApexCharts를 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 프로젝트에서 ApexCharts를 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nextjs 프로젝트에서 ApexCharts를 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트와 리덕스 툴킷으로 할 일 앱 만들기" href="/post/2024-05-12-BuildingaTodoAppwithReactandReduxToolkit"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트와 리덕스 툴킷으로 할 일 앱 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-BuildingaTodoAppwithReactandReduxToolkit_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트와 리덕스 툴킷으로 할 일 앱 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트와 리덕스 툴킷으로 할 일 앱 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 JS에서 리액트 폼 훅과 useFieldArray 훅을 함께 사용하는 방법" href="/post/2024-05-12-HowtoUsetheuseFieldArrayHookwithReactFormHookinReactJS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 JS에서 리액트 폼 훅과 useFieldArray 훅을 함께 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-HowtoUsetheuseFieldArrayHookwithReactFormHookinReactJS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 JS에서 리액트 폼 훅과 useFieldArray 훅을 함께 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 JS에서 리액트 폼 훅과 useFieldArray 훅을 함께 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코드 형태의 형상  코드 생성을 활용하여 개발자의 작업 흐름 최적화하기" href="/post/2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코드 형태의 형상  코드 생성을 활용하여 개발자의 작업 흐름 최적화하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코드 형태의 형상  코드 생성을 활용하여 개발자의 작업 흐름 최적화하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">코드 형태의 형상  코드 생성을 활용하여 개발자의 작업 흐름 최적화하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/121">121</a><a class="link" href="/posts/122">122</a><a class="link" href="/posts/123">123</a><a class="link" href="/posts/124">124</a><a class="link" href="/posts/125">125</a><a class="link" href="/posts/126">126</a><a class="link" href="/posts/127">127</a><a class="link" href="/posts/128">128</a><a class="link" href="/posts/129">129</a><a class="link posts_-active__YVJEi" href="/posts/130">130</a><a class="link" href="/posts/131">131</a><a class="link" href="/posts/132">132</a><a class="link" href="/posts/133">133</a><a class="link" href="/posts/134">134</a><a class="link" href="/posts/135">135</a><a class="link" href="/posts/136">136</a><a class="link" href="/posts/137">137</a><a class="link" href="/posts/138">138</a><a class="link" href="/posts/139">139</a><a class="link" href="/posts/140">140</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"리액트 타입스크립트 프로젝트에서 ESLint 설정하기 2022","description":"","date":"2024-05-12 22:17","slug":"2024-05-12-SettingESLintonaReactTypescriptproject2022","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_0.png\" /\u003e\n\n# 소개\n\n내 React Typescript 프로젝트에 ESLint를 설치하고 이해하려는 데 많은 어려움을 겪은 후, React Typescript 프로젝트에 ESLint를 설정하는 확정 가이드를 작성하기로 결정했습니다.\n\n이 튜토리얼의 주요 목표는 단계별로 설정하고 추가 또는 실행된 각 줄을 설명하는 것입니다. 단순히 여러 구성을 가진 많은 파일을 제공하고 무엇이 일어나고 있는지를 이해할 수 있기를 바랄 뿐인 대신 설명합니다.\n\n\n\n그럼 시작해볼까요!\n\n## 준비물\n\n참고: Node 버전 `= 10`이 설치되어 있어야 합니다. 설치되어 있지 않다면 NodeJS 웹사이트로 이동하여 로컬 머신에 다운로드하고 설치해 주세요. (https://nodejs.org/en/)\n\n## 단계 1: TypeScript로 React 프로젝트 생성\n\n\n\n다음 명령어는 my-app이라는 폴더 내에 프로젝트를 생성합니다.\n\n터미널에서 다음을 실행하세요:\n\n```js\nnpx create-react-app my-app --template typescript\n```\n\n# 단계 2: React 프로젝트에서 미리 설정된 ESLint 구성 제거하기\n\n\n\n래스크는 eslint 설정이 미리 설정되어 있어요. 이 설정을 제거해서 더 나은 설정을 할 수 있도록 해봐요. 이를 위해 'package.json' 파일에서 아래 코드를 제거해주세요.\n\n```js\n\"eslintConfig\": {\n   \"extends\":[\n      \"react-app\",\n      \"react-app/jest\"\n   ]\n}\n```\n\n# 단계 3: ESLint 패키지 설치하기\n\n프로젝트 디렉토리 안에서 터미널을 열어주세요.\n\n\n\n터미널에서 다음을 실행해 주세요:\n\n```js\nnpm install eslint --save-dev\n```\n\n위 명령을 실행하면 'package.json' 파일에서 \"eslint\"가 개발용 종속성으로 추가된 것을 확인할 수 있습니다.\n\n```js\n\"devDependencies\": {\n   \"eslint\": \"^7.20.0\"\n}\n```\n\n\n\n# 단계 4: ESLint 설정\n\n프로젝트 디렉토리 안에서 터미널을 열어주세요.\n\n터미널에서 다음을 실행하세요:\n\n\n\n```js\nnpx eslint --init\n```\n\n이 명령을 실행할 때 설정에 관한 몇 가지 질문에 답변해야합니다.\n\n이후, 설치해야 할 종속 항목을 확인한 다음 다음과 같이 물어볼 것입니다:\n\n그런 다음 필요한 모든 패키지를 설치합니다. 설치 프로세스가 완료되면 \"package.json\" 파일의 'devDependencies'는 다음과 같이 보여야 합니다:\n\n\n\n```js\n\"devDependencies\": {\n\"@typescript-eslint/eslint-plugin\": \"^4.15.1\",\n\"@typescript-eslint/parser\": \"^4.15.1\",\n\"eslint\": \"^7.20.0\",\n\"eslint-config-airbnb\": \"^18.2.1\",\n\"eslint-plugin-import\": \"^2.22.1\",\n\"eslint-plugin-jsx-a11y\": \"^6.4.1\",\n\"eslint-plugin-react\": \"^7.22.0\",\n\"eslint-plugin-react-hooks\": \"^4.2.0\"\n}\n```\n\nPS: 위 예시와 버전이 일치하지 않아도 괜찮아요.\n\n# Step 5: ESLint 실행하기\n\n프로젝트 디렉토리에서 터미널을 열어주세요.\n\n\n\nESLint를 실행하고 가리키는 오류를 확인하려면 다음을 실행하세요:\n\n```js\nnpx eslint \u003c대상파일\u003e\n```\n\n일부 오류를 자동으로 수정하려면 '--fix'를 사용할 수 있어요:\n\n```js\nnpx eslint \u003c대상파일\u003e --fix\n```\n\n\n\n만약 경고를 무시하고 싶다면 ‘--quiet’를 사용할 수 있어요.\n\n```js\nnpx eslint \u003c대상파일\u003e --quiet\n```\n\n# 단계 5.1: 실행해봅시다!\n\n만약 'src' 디렉토리 안의 모든 파일에 대해서 eslint를 실행하면 35개의 오류가 나타날 거예요. 와우!\n\n\n\n```js\nnpx eslint src/* \n```\n\nESLint 출력:\n\n\u003cimg src=\"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_1.png\" /\u003e\n\n자동 수정으로 실행하면 무서운 부분은 줄어들었지만 해결해야 할 오류가 여전히 22개 남아 있어요. 대박이에요!\n\n\n\n```bash\nnpx eslint src/* --fix\n```\n\nESLint의 출력:\n\n![Setting ESLint on a React Typescript project](/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_2.png)\n\n그래서 우리는 모든 단계를 거치고 Typescript로 ReactJS의 '안녕, 세계' 프로젝트를 수행했는데도 이 모든 오류가 발생했습니다. 대부분의 오류는 확장 파일 오류나 심지어 React 자체의 사용과 같은 무의미한 것들이었습니다.\n\n\n\n짜증나는 일이죠?\n\n좋은 소식은 이미 이 지옥을 겪어가며 이 문제들을 해결했고, 이제 ESLint를 제대로 사용할 수 있도록 모든 구성을 끝마칠 수 있습니다. 이 문제를 하나씩 살펴보고 어떻게 해결해야 하는지 알아보겠습니다!\n\n## 남은 문제 해결하기\n\n### 문제: \"'no-use-before-define'\"\n\n\n\n에러 샘플: 'React'가 정의되기 전에 사용되었습니다.\n\n## 해결 방법\n\n'eslintrc.json' 파일에서 \"rules\" 섹션 아래에 다음을 추가하십시오:\n\n```js\n\"rules\": {\n  \"no-use-before-define\": \"off\",\n  \"@typescript-eslint/no-use-before-define\": [\"error\"]\n}\n```\n\n\n\n위 설명은 이 스택 오버플로 포스트에 있어요 (https://stackoverflow.com/questions/63818415/react-was-used-before-it-was-defined/64024916#64024916)\n\n# 문제: \"'react/jsx-filename-extension\"\n\n에러 샘플: 확장자 '.tsx'를 가진 파일에서 JSX가 허용되지 않음\n\n## 해결책\n\n\n\n'eslintrc.json' 파일에서 \"rules\" 아래에 다음을 추가하세요:\n\n```js\n\"rules\": {\n...\n\"react/jsx-filename-extension\": [ \"warn\", {\"extensions\": [\".tsx\"]} ]\n}\n```\n\n# 문제: \"import/no-unresolved\"\n\n에러 샘플: './App' 모듈에 대한 경로를 해결할 수 없음\n\n\n\n## 해결 방법\n\n- 프로젝트 디렉토리 내에서 터미널을 열고 eslint-import-resolver-typescript 패키지를 설치하세요.\n\n```js\nnpm install eslint-import-resolver-typescript --save-dev\n```\n\n- 'eslintrc.json' 파일에 다음과 같이 새로운 \"settings\" 속성을 추가하세요:\n\n\n\n```json\n\"settings\": {\n    \"import/resolver\": {\n        \"typescript\": {}\n    }\n}\n```\n\n# 문제: \"import/extensions\"\n\n에러 샘플: './App'에 대한 'tsx' 파일 확장자 누락\n\n## 해결책\n\n\n\n'eslintrc.json' 파일에서 \"rules\" 아래에 다음을 추가해 주세요:\n\n```js\n\"rules\": {\n…\n\"import/extensions\": [\n\"error\",\n\"ignorePackages\",\n{\n\"ts\": \"never\",\n\"tsx\": \"never\"\n}\n]\n}\n```\n\n# 문제: \"no-undef\"\n\n에러 샘플: 'test'가 정의되지 않았습니다\n\n\n\n## 해결 방법\n\n'eslintrc.json' 파일에서 \"extends\" 항목에 \"plugin:@typescript-eslint/recommended\"를 추가하십시오:\n\n```js\n\"extends\": [\n…\n\"plugin:@typescript-eslint/recommended\"\n],\n```\n\n# 문제: \"no-shadow\"\n\n\n\n에러 샘플: 'Enum'이 이미 상위 스코프에서 선언되었습니다.\n\n## 해결 방법\n\n‘eslintrc.json’ 파일에서 \"rules\" 아래에 다음을 추가하십시오:\n\n```js\n\"rules\":{\n…\n\"no-shadow\": \"off\",\n\"@typescript-eslint/no-shadow\": [\"error\"]\n}\n```\n\n\n\n스택 오버플로우 게시물에 설명이 있습니다(https://stackoverflow.com/questions/63961803/eslint-says-all-enums-in-typescript-app-are-already-declared-in-the-upper-scope)\n\n# 문제: 'js', 'jsx', 'ts', 또는 'tsx' 확장자 파일이 아닌 파일에 대한 오류\n\n## 해결책:\n\n‘.eslintignore’ 파일에 추가하여 ESLint가 특정 파일을 무시하도록 할 수 있습니다.\n\n\n\n그럼,\n\n- 프로젝트 루트에 '.eslintignore' 파일을 만듭니다.\n- 다음 텍스트를 추가합니다:\n\n```js\n*.css\n*.svg\n```\n\n# 추가:\n\n\n\n# 적용해 볼 좋은 규칙들\n\n## 모든 함수에 명시적인 반환 유형을 강제로 적용하기\n\n‘eslintrc.json’ 파일에서 \"rules\" 아래에 다음을 추가해주세요:\n\n```js\n\"rules\":{\n...\n\"@typescript-eslint/explicit-function-return-type\": [\n\"error\",\n{\n\"allowExpressions\": true\n}\n]\n}\n```\n\n\n\n## 코드 라인의 최대 길이\n\n'.'eslintrc.json' 파일에 \"rules\" 항목 아래에 다음 코드를 추가해주세요:\n\n```js\n\"rules\":{\n…\n\"max-len\": [\"warn\", { \"code\": 80 }]\n}\n```\n\n## React Hooks 규칙\n\n\n\n'**eslintrc.json**' 파일에서 \"plugins\" 섹션에 다음을 추가해주세요:\n\n```js\n\"plugins\": [\n…\n\"react-hooks\"\n],\n```\n\n그리고 \"rules\" 섹션에도 다음을 추가해주세요:\n\n```js\n\"rules\":{\n…\n\"react-hooks/rules-of-hooks\": \"error\",\n\"react-hooks/exhaustive-deps\": \"warn\"\n}\n```\n\n\n\n# 무시할 몇 가지 규칙:\n\n## 기본 내보내기 사용 선호\n\n`eslintrc.json`에서 \"rules\" 아래에 다음을 추가해주세요:\n\n```js\n\"rules\":{\n…\n\"import/prefer-default-export\": \"off\"\n}\n```\n\n\n\n## 프롭 타입 규칙\n\n`eslintrc.json` 파일에서 \"rules\" 항목에 다음 내용을 추가해 주세요:\n\n```js\n\"rules\":{\n…\n\"react/prop-types\": \"off\"\n}\n```\n\n# 결론\n\n\n\n그래서 이러한 구성을 통해 ReactJS with Typescript 프로젝트의 코드 품질을 향상시킬 수 있습니다. 즐기세요! :)\n\n# VS Code: 저장할 때 파일에서 ESLint 자동 수정 실행\n\n게다가, VS Code에서 자동 수정을 구성하는 방법을 보여드리겠습니다. 그러나 이는 선택 사항입니다. 코드를 저장할 때마다 ESLint를 자동 수정하려면 다음 단계를 수행하실 수 있습니다.\n\n- 프로젝트 루트에 '.vscode' 폴더를 생성합니다.\n- '.vscode/' 폴더 안에 'settings.json' 파일을 생성하고 다음 코드를 삽입합니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_3.png\" /\u003e\n\n```js\n{\n\"editor.defaultFormatter\": \"dbaeumer.vscode-eslint\",\n\"editor.formatOnSave\": true,\n\"eslint.alwaysShowStatus\": true,\n\"editor.codeActionsOnSave\": {\n\"source.fixAll.eslint\": true\n}\n}\n```\n\n- VS Code ESLint 확장 프로그램 설치\n\nVS Code 'Extensions' 섹션으로 이동하여 수동으로 설치할 수 있습니다:\n\n\n\n![이미지](/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_4.png)\n\n또는 VS Code 빠른 열기(Ctrl+P)를 실행하고 다음 몤령어를 실행하세요:\n\n```js\next install dbaeumer.vscode-eslint\n```\n\n- VS Code에서 ESLint 익스텐션 사용 허용하기:\n\n\n\n처음 사용하는 경우 ESLint 확장 프로그램이 차단될 것입니다. 그럼에도 불구하고 허용해야 합니다:\n\n1. 상태 표시줄 아이콘을 클릭합니다.\n\n![이미지](/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_5.png)\n\n2. 팝업이 나타납니다. '허용' 옵션을 선택합니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_6.png\" /\u003e\n\n완료되었습니다! 이제 모든 파일을 저장할 때마다 ESLint 규칙을 자동으로 수정할 수 있습니다.\n\n# 참고","ogImage":{"url":"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_0.png"},"coverImage":"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_0.png","tag":["Tech"],"readingTime":7},{"title":"리액트 네이티브 이미지 피커 구현에 대한 심층 탐구","description":"","date":"2024-05-12 22:16","slug":"2024-05-12-DeepDiveintoImplementingreact-native-image-picker","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-DeepDiveintoImplementingreact-native-image-picker_0.png\" /\u003e\n\n현대 애플리케이션에서 사용자가 프로필에 사진을 업로드할 수 있는 기능을 제공하는 것은 표준입니다. 사용자들이 계속해서 앱을 방문할 수 있도록 최상의 경험을 제공하는 것이 매우 중요합니다.\n\nReact-Native로 모바일 앱을 개발 중이라면, react-native-image-picker 덕분에 이것을 아주 쉽게 구현할 수 있습니다.\n\n# 내 앱은 어떤 이미지 형식을 지원해야 할까요?\n\n\n\n첫 번째로 해야 할 질문은 \"내 앱이 지원해야 하는 이미지 유형은 무엇인가?\"입니다. 다양한 이미지 유형이 존재하며, 모든 종류의 사람들을 대상으로 하는 앱을 원한다면 특히 혼란스럽고 압도될 수 있습니다. React Native는 이를 우리에게 아주 쉽게 만들어줍니다.\n\n그래서 선택지를 좁힐 수 있습니다. 이 목록에 언급되지 않은 것 중 하나는 Base64입니다. Base64는 이진 데이터를 나타내는 이진-텍스트 인코딩 체계의 한 그룹입니다.\n\n# React-Native-Image-Picker\n\n## React Native Image Picker란 무엇인가요?\n\n\n\nReact-Native-Image-Picker은 React Native 모듈로, 기기 라이브러리에서 미디어를 선택하거나 직접 카메라에서 가져 올 수 있도록 네이티브 UI를 사용할 수 있게 해줍니다. 현재 약 60,000명의 개발자가 사용 중이며, 제공되는 기능이 매우 견고하기 때문에 많은 사람들이 사용하고 있습니다.\n\n## React-Native-Image-Picker 설치 및 설정하는 방법\n\n먼저 패키지를 프로젝트에 설치합니다:\n\nAndroid:\n\n\n\n```js\nyarn add react-native-image-picker\n```\n\niOS:\n\n```js\nnpx pod-install ios\n```\n\nreact-native-image-picker 레포지토리에는 몇 가지 추가 설치 단계에 대한 조언이 있습니다. 그 중 일부는 다음과 같습니다:\n사용자가 사진 또는 비디오를 선택할 수 있도록 하는 경우 NSPhotoLibraryUsageDescription을 추가하세요.\n\n\n\niOS\n\nAndroid\n\n`saveToPhotos` 속성을 `true`로 설정하지 않는 한 권한이 필요하지 않습니다.\n\niOS의 권한은 다음과 같이 test 폴더 내의 Info.plist 파일에 들어갑니다:\n\n\n\n```js\n\u003ckey\u003eNSPhotoLibraryUsageDescription\u003c/key\u003e\n \u003cstring\u003e$(PRODUCT_NAME)님의 사진 갤러리에 접근하려고 합니다\u003c/string\u003e\n\u003ckey\u003eNSCameraUsageDescription\u003c/key\u003e\n \u003cstring\u003e$(PRODUCT_NAME)님의 카메라를 사용하려고 합니다\u003c/string\u003e\r\n```\n\n## Android의 권한은 AndroidManifest.xml 파일에 작성해주세요 :\n\nReact-Native-Image-Picker 모듈은 사용자에게 작동을 위해 권한이 필요하지 않지만, 사용자가 앱에서 촬영한 이미지를 갤러리에 저장하는 옵션을 설정한 경우, 다음 권한이 필요합니다:\n\n```js\n\u003cuses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/\u003e\n```\n\n\n\n위에서 사용자에게 겔러리 접근 권한과 애플리케이션에서 캡처한 이미지를 사용자의 갤러리에 저장할 것인지에 대한 동의를 요청하는 것입니다.\n\n## React-Native-image-Picker 구현하기\n\n프로필 컴포넌트 Profile.js를 생성하십시오. react-native-image-picker에는 사용할 수 있는 두 가지 메서드가 있습니다. launchCamera()는 카메라를 실행하여 사진을 찍고, launchImageLibrary()는 갤러리를 실행하여 사진이나 비디오를 선택합니다. 이를 파일에 import할 것입니다.\n\nlaunchLibrary 메서드는 사용자의 갤러리를 열고 이미지 설정과 응답 두 가지 매개변수를 사용합니다.\n\n\n\n`launchCamera` 메소드는 사용자의 카메라를 실행하며 이미지의 구성 및 응답에 대한 두 개의 매개변수를 가져옵니다.\n\n`pickerResponse` 상태 변수는 이미지 피커에서의 응답을 저장하는 데 사용됩니다. `imageFromDB` 상태 변수는 데이터베이스에서 이미지를 저장하여 나중에 액세스할 수 있도록 합니다.\n\nImage 컴포넌트는 다음과 같이 사용됩니다:\n\n```js\n\u003cCard style=//카드 스타일, 특히 이미지에 고도를 원하는 경우\u003e\n    \u003cImage\n        source={\n          uri: `data:image/*;base64,${imageFromDB}`,\n          width: ..,\n          height: ...,\n        }\n        style=//추가 이미지 스타일\n    /\u003e\n\u003c/Card\u003e\n```\n\n\n\n이 코드 라인\n\n```js\nuri: `data:image/*;base64,${imageFromDB}`,\n```\n\n은 우리가 데이터베이스에서 이미지를 렌더링하는 데 `uri` 속성을 사용하고 `image/*`가 지정된 이미지 유형을 렌더링하도록 보장합니다.\n\n또한 사용자가 갤러리 또는 카메라에 액세스하여 이미지를 업로드할 수 있도록 모달을 활성화하는 프레서블 아이콘을 추가할 수도 있습니다.\n\n\n\n```js\n \u003cPressable\n    style={({ pressed }) =\u003e [\n        {\n            ...styles.cameraIconView,\n            opacity: pressed ? 0.5 : 1,\n        },\n    ]}\n    onPress={() =\u003e setVisible(true)}\n\u003e\n    \u003cIconComponent\n        source={icons.camera}\n        tintColor={themeColor.primaryWhite}\n    /\u003e\n\u003c/Pressable\u003e\r\n```\n\n저희는 프로필 컴포넌트에 모달을 넣고 필요한 모든 속성을 전달하고 싶어요.\n\n```js\r\n\u003cImagePickerModal\n    isVisible={visible}\n    onClose={() =\u003e setVisible(false)}\n    onImageLibraryPress={onImageGalleryPress}\n    onCameraPress={onCameraPress}\n/\u003e\r\n```\n\n마지막으로 ImagePickerModal 컴포넌트를 만들어야 할 것입니다.\n\n\n\n데이터베이스로 이미지를 그대로 보내기보다 base64 이미지를 사용하는 이유를 궁금해하는 분들을 위해, base64 인코딩을 사용하면 데이터 크기를 최대 33%까지 줄일 수 있으며 많은 프로그래밍 언어가 base64 인코딩을 내장 지원하고 있습니다.\n\n# 페이지 상태에 따라 이미지를 조건부로 렌더링하기\n\n이미지를 렌더링하기 위해 우리는 다음 3가지 경우를 살펴볼 것입니다:\n\n- 사용자가 로그인하지 않았을 때\n- 사용자가 로그인했지만 프로필 이미지가 없는 경우\n- 사용자가 로그인하고 프로필 이미지가 있는 경우\n- 사용자가 로그인하고 방금 프로필 이미지를 변경한 경우\n\n\n\n```js\nuserLoggedIn ? {\n  uri ? (\n    \u003cCard style={styles.userDBImageView}\u003e\n        \u003cImage\n            source={\n                uri: uri,\n                width: styles.userDBImage.width,\n                height: styles.userDBImage.height,\n            }\n            style={styles.userDBImage}\n        /\u003e\n    \u003c/Card\u003e\n) : imageFromDB ? (\n    \u003cCard style={styles.userDBImageView}\u003e\n        \u003cImage\n            source={\n                uri: `data:image/*;base64,${imageFromDB}`,\n                width: styles.userDBImage.width,\n                height: styles.userDBImage.height,\n            }\n            style={styles.userDBImage}\n            // tintColor={colors.primaryWhite}\n        /\u003e\n    \u003c/Card\u003e\n) : (\n    \u003cCard\n        style={\n            ...styles.userImageView,\n            marginTop: '8%',\n            width: '25%',\n        }\n    \u003e\n        \u003cImage\n            source={icons.profileImage}\n            style={styles.userImage}\n            tintColor={colors.primaryWhite}\n        /\u003e\n    \u003c/Card\u003e\n)\n) : (\n\u003cCard style={styles.userImageView}\u003e\n    \u003cImage\n        source={icons.profileImage}\n        style={styles.userImage}\n        tintColor={colors.primaryWhite}\n    /\u003e\n\u003c/Card\u003e\n         )\n}\n```\n\n## 사용자가 로그인하지 않은 경우\n\n마지막 컴포넌트는 사용자가 로그인하지 않았을 때 호출될 것이므로 해당 이미지의 소스는 기본/대체 이미지여야합니다.\n\n## 사용자는 로그인했지만 프로필 이미지가 없습니다\n\n\n\n사용자가 로그인했지만 프로필 이미지가 없는 경우, 코드에서 두 번째로 나타나는 그림과 동일한 이미지를 표시할 것입니다.\n\n## 사용자가 로그인하고 프로필 이미지가 있는 경우\n\n두 번째 구성 요소는 사용자가 로그인했는지와 데이터베이스에서 이미지를 가지고 있는지 확인한 후 렌더링됩니다.\n\n## 사용자가 로그인하고 방금 프로필 이미지를 변경한 경우\n\n\n\n이 코드 조각은 먼저 사용자가 uri 변수를 사용하여 새 이미지를 선택/캡처했는지 확인합니다. uri에 값이 있는 경우, 삼항 연산자에서 다른 변수들 보다 우선순위가 높기 때문에 즉시 표시됩니다.\n\n# 결론\n\nreact-native-image-picker를 사용하면 이미지 업로드 기능을 쉽게 구현할 수 있습니다. 사용자가 이미지와 비디오를 업로드할 수 있는 애플리케이션을 쉽게 구축할 수 있을 정도로 강력합니다. 사용자 경험을 즐겁게 만들어주지만, 더 중요한 점은 개발자 경험까지 더욱 즐겁게 만들어준다는 것입니다.","ogImage":{"url":"/assets/img/2024-05-12-DeepDiveintoImplementingreact-native-image-picker_0.png"},"coverImage":"/assets/img/2024-05-12-DeepDiveintoImplementingreact-native-image-picker_0.png","tag":["Tech"],"readingTime":6},{"title":"함수 컴포넌트에서 React 고차 컴포넌트HOC 활용하기","description":"","date":"2024-05-12 22:15","slug":"2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents_0.png\" /\u003e\n\nReact Higher Order Components (HOC)은 React 애플리케이션에서 코드 재사용, 로직 공유 및 추상화를 위한 강력한 패턴입니다. 보통 클래스 컴포넌트와 관련이 있지만, 고차 컴포넌트는 함수형 컴포넌트와 함께 효율적으로 활용할 수도 있습니다. 이 글에서는 함수형 컴포넌트에서 고차 컴포넌트를 구현하고 활용하는 방법에 대해 살펴보겠습니다.\n\n고차 컴포넌트 이해하기:\n\n고차 컴포넌트는 컴포넌트를 인수로 받아 향상된 기능을 갖춘 새로운 컴포넌트를 반환하는 함수입니다. 인증, 권한 부여, 로깅 및 상태 관리와 같은 교차 관심사를 여러 컴포넌트에서 캡슐화하고 공유할 수 있도록 합니다.\n\n\n\n함수형 컴포넌트에서 고차 컴포넌트 구현하기:\n\n함수형 컴포넌트에서는 고차 컴포넌트를 일반 JavaScript 함수로 구현하며, 이 함수는 컴포넌트를 인수로 받아 새로운 함수형 컴포넌트를 반환합니다.\n\n다음 예제를 살펴보겠습니다:\n\n```js\nimport React from 'react';\n\nconst withLogging = (WrappedComponent) =\u003e {\n  const WithLogging = (props) =\u003e {\n    console.log('Component rendered:', WrappedComponent.name);\n    return \u003cWrappedComponent {...props} /\u003e;\n  };\n\n  return WithLogging;\n};\n\nconst MyComponent = () =\u003e {\n  return \u003cdiv\u003eHello, World!\u003c/div\u003e;\n};\n\nconst EnhancedComponent = withLogging(MyComponent);\n\nexport default EnhancedComponent;\n```\n\n\n\n이 예시에서 withLogging은 렌더링된 컴포넌트의 이름을 콘솔에 로그하는 Higher Order Component입니다. 이는 컴포넌트(WrappedComponent)를 인수로 받아 원래 컴포넌트를 래핑하고 로깅 기능을 추가한 새로운 함수형 컴포넌트(WithLogging)를 반환합니다.\n\n함수형 컴포넌트에서 Higher Order Components 사용하기:\n\n한 번 Higher Order Component가 정의되면, 그것을 사용하여 함수형 컴포넌트를 래핑하여 향상시킬 수 있습니다. 다음은 withLogging Higher Order Component를 함수형 컴포넌트와 함께 사용하는 방법입니다.\n\n```js\nimport React from 'react';\n\nconst MyComponent = () =\u003e {\n  return \u003cdiv\u003e안녕, 세상!\u003c/div\u003e;\n};\n\nconst EnhancedComponent = withLogging(MyComponent);\n\nconst App = () =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003cEnhancedComponent /\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default App;\n```\n\n\n\n이 예시에서 MyComponent는 일반 함수형 컴포넌트이고, EnhancedComponent는 withLogging Higher Order Component를 MyComponent에 적용한 결과입니다. App 컴포넌트 내에서 EnhancedComponent를 렌더링하면 감싸진 컴포넌트의 이름(MyComponent)이 콘솔에 기록됩니다.\n\n함수형 컴포넌트와 Higher Order Components의 장점:\n\n- 코드 재사용을 촉진하고 교차 관심사의 캡슐화를 장려합니다.\n- 로직을 표현으로부터 분리하여 관심사의 분리를 가능하게 합니다.\n- 여러 Higher Order Components를 함께 조합할 수 있는 합성 기능을 향상시킵니다.\n- 컴포넌트를 보다 집중적이고 격리된 상태로 테스트할 수 있도록 돕습니다.\n\n결론\n\n\n\n리액트 고차 컴포넌트는 재사용 가능한 로직과 동작을 확장하는 강력한 방법을 제공합니다. 공통 기능을 고차 컴포넌트 내에 캡슐화함으로써, 개발자들은 리액트 애플리케이션에서 코드 구성, 유지 관리성, 그리고 재사용성을 향상시킬 수 있습니다. 인증, 로깅 또는 기타 교차 관심사를 구현하려는 경우, 고차 컴포넌트는 기능 컴포넌트 강화를 위한 유연하고 효과적인 해결책을 제공합니다.","ogImage":{"url":"/assets/img/2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents_0.png"},"coverImage":"/assets/img/2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 네이티브에서 페이지와 함께 페이지네이션하기","description":"","date":"2024-05-12 22:14","slug":"2024-05-12-PaginationinReactNativewithPage","content":"\n\n소개:\n\n페이지네이션은 React Native에서 대량의 데이터 목록을 효율적으로 관리하고 표시할 수 있게 해주는 강력한 기술입니다. 이 글에서는 FlatList와 페이지네이션 버튼을 사용하여 고급 페이지네이션을 구현하는 방법에 대해 알아볼 것입니다. 페이지네이션의 논리, 각 페이지별 데이터 검색 방법 및 렌더링 프로세스의 최적화에 대해 논의할 것입니다. 함께 React Native 페이지네이션을 마스터해봅시다!\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*Vj09FpPeRuOC7tDLGpBrsg.gif)\n\n```js\n..... 구성 요소 구조 ....\nconst handlePageClick = (p: number) =\u003e setCurrentPage(p);\n\n  const renderItem = ({item}: {item: ScoreCard}) =\u003e {\n    return \u003cCard item={item} key={item.id} /\u003e;\n  };\n\nreturn (\n\u003cSafeAreaView style={styles.container}\u003e      \n      \u003cFlatList\n        data={items}\n        renderItem={renderItem}\n        keyExtractor={item =\u003e item.id}\n        ListEmptyComponent={handleEmpty}\n        windowSize={10} // VirtualizedList의 기능 추가\n        refreshControl={\n          \u003cRefreshControl refreshing={refreshing} onRefresh={handleRefresh} /\u003e\n        }\n      /\u003e\n      \u003cView style={styles.paginationContainer}\u003e\n        {renderPaginationButtons()}\n      \u003c/View\u003e\n    \u003c/SafeAreaView\u003e\n)\n...\n```\n\n\n\n- 페이지네이션 로직\n\n저희 페이지네이션 구현의 핵심은 'Institution' 컴포넌트에 있습니다. 이 컴포넌트는 'useState'와 같은 React 훅을 사용하여 중요한 상태 변수를 관리합니다. 'currentPage' 상태는 현재 표시되는 페이지를 나타내고, 'totalPages'는 전체 목록에 대한 총 페이지 수를 저장합니다. 'itemsPerPage'를 설정하여 페이지 당 표시할 항목 수를 결정하여 로딩 프로세스를 최적화합니다.\n\n```js\nconst [totalPages, setTotalpages] = useState(0);\nconst [currentPage, setCurrentPage] = useState(0);\nconst [items, setItems] = useState([]);\nconst [refreshing, setRefreshing] = useState(false);\nconst itemsPerPage = 16;\n```\n\n2. 각 페이지의 데이터 가져오기\n\n\n\n'fetchData' 함수는 페이지네이션 로직의 중요한 부분입니다. 'Institution' 컴포넌트가 마운트되거나 'currentPage'가 변경될 때마다 해당 함수를 호출하여 현재 페이지의 데이터를 검색합니다. 우리는 데이터를 가져오는 작업을 처리하는 'fetcher' 유틸리티 함수를 사용합니다.\n\n```js\nuseEffect(() =\u003e {\n  fetchData();\n}, [currentPage]);\n\nasync function fetchData() {\n  setRefreshing(true);\n  try {\n    let response = await fetcher(currentPage, itemsPerPage);\n    setTotalpages(response.metadata.total / itemsPerPage);\n    let data: [] = response.results;\n    setItems(data);\n    setRefreshing(false);\n  } catch (error) {\n    setRefreshing(false);\n    console.log(error);\n  }\n}\n```\n\n3. 페이지네이션 버튼 처리\n\n사용자가 페이지별 목록을 탐색할 수 있도록 하기 위해, 페이지네이션 버튼을 렌더링할 때 TouchableOpacity 요소를 사용합니다. 'renderPaginationButtons' 함수는 'currentPage', 'totalPages', 그리고 표시할 최대 버튼 수('maxButtonsToShow')를 기반으로 표시할 페이지를 계산한 다음 적절한 버튼을 생성합니다.\n\n\n\n```js\nconst renderPaginationButtons = () =\u003e {\n  const maxButtonsToShow = 5;\n  let startPage = Math.max(0, currentPage - Math.floor(maxButtonsToShow / 2));\n  let endPage = Math.min(totalPages, startPage + maxButtonsToShow - 1);\n\n  if (endPage - startPage + 1 \u003c maxButtonsToShow) {\n    startPage = Math.max(0, endPage - maxButtonsToShow + 1);\n  }\n\n  const buttons = [];\n\n  for (let i = startPage; i \u003c= endPage; i++) {\n    buttons.push(\n      \u003cTouchableOpacity\n        key={i}\n        onPress={() =\u003e handlePageClick(i)}\n        style={[\n          styles.paginationButton,\n          i === currentPage ? styles.activeButton : null,\n        ]}\u003e\n        \u003cText style={{color: 'white'}}\u003e{i}\u003c/Text\u003e\n      \u003c/TouchableOpacity\u003e,\n    );\n  }\n\n  return buttons;\n};\n```\n\n4. Pull-to-Refresh 및 데이터 없음 처리\n\n더 나은 사용자 경험을 제공하기 위해 'RefreshControl'를 사용하여 pull-to-refresh 기능을 구현했습니다. 사용자는 필요할 때 목록을 수동으로 새로 고칠 수 있습니다. 추가로, 표시할 기관이 없는 시나리오를 처리하기 위해 '기관 없음' 메시지를 렌더링합니다.\n\n```js\nconst handleRefresh = () =\u003e {\n  setRefreshing(true);\n  setTimeout(() =\u003e setRefreshing(false), 1000);\n};\n\nconst handleEmpty = () =\u003e {\n  return \u003cText\u003e기관이 없습니다!\u003c/Text\u003e;\n};\n```\n\n\n\n5. 더 나은 사용자 경험을 위한 스타일링\n\n저희는 컴포넌트에 시각적 매력을 더하기 위해 StyleSheet를 활용합니다. 페이지네이션 버튼은 활성화될 때 색상과 크기가 변경되어 사용자에게 시각적 피드백을 제공하여 전체 앱 경험을 향상시킵니다.\n\n```js\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  paginationContainer: {\n    flexDirection: 'row',\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingVertical: 8,\n    backgroundColor: 'transparent',\n  },\n  paginationButton: {\n    justifyContent: 'center',\n    alignItems: 'center',\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    marginHorizontal: 4,\n    backgroundColor: 'gray',\n  },\n  activeButton: {\n    backgroundColor: '#22c55d',\n    width: 50,\n    height: 50,\n    borderRadius: 25,\n  },\n  buttonText: {\n    color: 'white',\n  },\n});\n```\n\n맺음말\n\n\n\n이 코드에 대한 링크는 여기에서 확인할 수 있습니다 - ` paginate. React Native pagination을 FlatList와 페이지 버튼으로 마스터하여 대량의 데이터 목록을 손쉽게 처리하여 부드러운 성능과 더 나은 사용자 경험을 보장할 수 있습니다. 페이지네이션은 렌더링을 크게 최적화하며 네트워크 리소스 부하를 줄이고 전반적인 앱 대응성을 향상시킵니다. React Native 애플리케이션에서 고급 페이지네이션을 구현하는 것은 고품질이고 성능이 우수한 모바일 앱을 제공하는 데 유용한 기술입니다.","ogImage":{"url":"/assets/img/2024-05-12-PaginationinReactNativewithPage_0.png"},"coverImage":"/assets/img/2024-05-12-PaginationinReactNativewithPage_0.png","tag":["Tech"],"readingTime":5},{"title":"React 19를 소개합니다 웹 개발의 다음 진화를 드러냅니다","description":"","date":"2024-05-12 22:13","slug":"2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment","content":"\n\n![이미지](/assets/img/2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment_0.png)\n\n페이스북에서 개발한 JavaScript 라이브러리인 React는 탄생 이후 현대 웹 개발의 최전선에 있었습니다. 각 버전마다 혁신적인 기능을 도입하여 견고한 사용자 인터페이스를 더 쉽고 효율적으로 구축할 수 있게 해 왔습니다. 이제 React 19가 출시되면서 커뮤니티는 최신 기능과 혁신에 대한 기대감으로 들뜹니다. 함께 React 19가 가져다주는 흥미로운 새로운 기능을 살펴보겠습니다.\n\n# 동시 렌더링\n\nReact 19의 가장 중요한 진보 중 하나는 동시 렌더링의 도입입니다. 이 혁신적인 기능을 통해 React는 여러 작업을 동시에 처리할 수 있어 응용 프로그램의 성능과 응답 시간을 크게 향상시킵니다. 동시 렌더링을 통해 React는 UI의 가장 중요한 부분을 렌더링하는 것을 우선시하고 덜 중요한 업데이트는 연기함으로써 더 부드러운 사용자 경험과 더 빠른 로드 시간을 제공할 수 있습니다.\n\n\n\n# 데이터 가져오기를 위한 Suspense\n\nReact 19에서는 이전 버전에서 소개된 suspense 개념을 발전시켜 데이터 가져오기에 특화된 suspense를 소개합니다. 이 강력한 메커니즘은 개발자가 로딩 상태와 오류 처리를 선언적으로 지정할 수 있도록 해줍니다. 이로써 API로부터 데이터를 가져오는 등의 비동기 작업을 간편하게 관리할 수 있습니다. React 생태계에 suspense를 원활하게 통합함으로써, 개발자는 복잡한 상태 관리 라이브러리를 사용하지 않고도 더 직관적이고 원활한 사용자 경험을 제공할 수 있습니다.\n\n# 개선된 서버 측 렌더링 (SSR)\n\n서버 측 렌더링은 빠른 초기 페이지 로드를 제공하고 SEO를 개선하는 데 필수적입니다. React 19에서는 SSR 능력에 상당한 향상이 이루어져 서버 렌더링된 애플리케이션을 구축하기가 더욱 쉬워졌습니다. 스트리밍 및 수분화 기능이 개선되어, React 19가 개발자에게 클라이언트 및 서버 환경 모두에 완벽하게 최적화된 동적 대화형 경험을 제공할 수 있게 되었습니다.\n\n\n\n# 더 나은 TypeScript 지원\n\nTypeScript는 초기에 오류를 미리 파악하고 코드 유지 관리를 개선하는 능력으로 React 커뮤니티에서 점차 인기를 얻고 있습니다. React 19는 TypeScript 지원을 한층 더 강화하여 더 나은 유형 추론, 인기 있는 TypeScript 기능과의 향상된 호환성, 향상된 개발자 도구를 제공합니다. 경험 많은 TypeScript 사용자이든 막 시작한 사용자이든, React 19를 통해 React 프로젝트에서 정적 유형의 혜택을 누리기가 이전보다 쉬워졌습니다.\n\n# 번들 크기 개선을 위한 선택적 기능\n\n번들 크기를 최적화하고 성능을 개선하기 위해 React 19는 선택적으로 필요한 컴포넌트와 기능만 포함할 수 있는 옵션 기능을 도입했습니다. 이러한 세부적인 번들링 접근법은 애플리케이션이 가볍고 효율적으로 유지되도록 보장하여 불필요한 오버헤드를 최소화하고 상호 작용 시간을 줄입니다. React 19가 개발자들에게 번들 크기를 더 많은 제어권을 부여함으로써 더 빠르고 더 스트리밍된 경험을 사용자에게 제공할 수 있도록 돕습니다.\n\n\n\n# 결론\n\nReact 19 버전을 통해 React 팀은 한 번 더 웹 개발의 기준을 높였으며, 사용자 인터페이스를 구축하는 방식을 바꿀 혁신적인 기능과 개선 사항을 제공했습니다. 병행 렌더링부터 향상된 TypeScript 지원까지, React 19는 개발자들에게 빠르고 기능이 풍부한 응용 프로그램을 만드는 데 필요한 도구를 제공합니다. React 생태계가 계속 발전함에 따라 확실한 것은 웹 개발의 미래가 이전보다 밝아졌다는 것입니다.","ogImage":{"url":"/assets/img/2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment_0.png"},"coverImage":"/assets/img/2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment_0.png","tag":["Tech"],"readingTime":2},{"title":"CI CD 마스터하기 GitHub Actions로 React 앱을 AWS S3에 배포하고 호스팅하기","description":"","date":"2024-05-12 22:12","slug":"2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt","content":"\n\n## AWS S3를 사용하여 GitHub Actions로 React.js 앱을 배포하고 호스팅하는 포괄적인 가이드\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_0.png)\n\nAWS S3와 GitHub Actions의 강력함을 느껴보세요. 이 포괄적인 가이드는 GitHub Actions를 사용하여 AWS S3에 React.js 앱을 배포하고 호스팅하는 간소화된 과정을 안내합니다. 워크플로우를 간소화하고 확장성을 확보하여 사용자에게 탁월한 경험을 제공하세요. AWS S3 및 GitHub Actions의 잠재력을 펼쳐보세요!\n\n# 목표:\n\n\n\n- React.js 애플리케이션의 배포 프로세스를 간단하게 만들어보세요.\n- GitHub Actions를 활용하여 배포 파이프라인을 자동화하세요.\n- AWS S3를 사용하여 React.js 앱을 확장 가능하게 호스팅하세요.\n- 신뢰할 수 있는 배포를 통해 사용자에게 뛰어난 경험을 제공하세요.\n- 효율적인 배포와 호스팅을 위한 지식과 도구로 개발자를 지원하세요.\n\n# 요구 사항 :\n\n- React.js에 대한 기본적인 이해\n- GitHub 계정으로 저장소 호스팅 및 GitHub Actions 사용\n- AWS S3 계정으로 React.js 애플리케이션 호스팅\n- GitHub 및 AWS S3에 대한 액세스 및 권한\n- YAML 설정에 익숙함\n- 명령 줄 인터페이스(CLI) 능숙함\n\n# 따라 할 단계:\n\n\n\n- IAM 사용자를 생성하고 AmazonS3FullAccess 정책을 연결하세요.\n- 비밀 액세스 키의 .csv 파일을 다운로드하세요.\n- S3 버킷을 생성하세요: ACL을 활성화하고 모든 공개 액세스 차단 옵션을 해제하세요.\n- GitHub으로 이동하여 공개 저장소를 만드세요.\n- 설정으로 이동하여 시크릿을 클릭하세요.\n- 다음을 저장할 새로운 리포지토리 시크릿 생성: 액세스 키 ID(AWS_ACCESS_KEY_ID), 비밀 액세스 키(AWS_SECRET_ACCESS_KEY) 및 버킷 이름(AWS_S3_BUCKET).\n- React 애플리케이션을 만들고 GitHub 워크플로우를 추가하세요.\n- GitHub에 푸시하세요.\n- 작업 섹션으로 이동하여 애플리케이션 빌드부터 S3로 업로드까지의 모든 단계를 확인하세요.\n- S3의 정적 파일 호스팅을 활성화하고 호스팅된 웹 앱을 볼 수 있는 엔드포인트를 열어보세요.\n\n## 단계 1: IAM 사용자 생성\n\n![이미지 제목](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_1.png)\n\n![이미지 제목](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_2.png)\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_3.png\" /\u003e\n\n## 단계 2: 새로 생성된 사용자의 보안 자격 증명 섹션에서 액세스 키 생성\n\n\u003cimg src=\"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_4.png\" /\u003e\n\n## 단계 3: S3 버킷 만들기\n\n\n\n버킷에 이름을 지어주시고 ACL을 활성화해주세요.\n\n\u003cimg src=\"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_5.png\" /\u003e\n\n모든 공개 액세스 차단 해제를 선택 해제하고 경고를 읽은 후에 선택하세요.\n\n\u003cimg src=\"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_6.png\" /\u003e\n\n\n\n위의 표를 Markdown 형식으로 변경해주세요.\n\n\n\n## 5단계: 레포지토리의 설정으로 이동하여 왼쪽 섹션에서 시크릿을 선택합니다.\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_8.png)\n\n## 6단계: 새로운 레포지토리 시크릿을 클릭하고 모든 세부 정보를 추가합니다.\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_9.png)\n\n\n\n\n![Image](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_10.png)\n\n![Image](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_11.png)\n\nAfter creating this, you can see like this\n\n![Image](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_12.png)\n\n\n\n## 단계 7: React 앱을 만들고 GitHub Actions 워크플로우 추가하기\n\n```js\nnpx create-react-app react-gh-action-s3\n```\n\nReact 앱을 만든 후에, \".github\\workflows\" 라는 폴더를 하나 추가하고 새 파일을 만들어 \"main.yaml\"이라고 이름 짓습니다. 아래 코드를 main.yaml 파일에 복사하세요:\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_13.png)\n\n\n\n\n```yaml\nname: 웹사이트 업로드\n\non:\n  push:\n    branches: [ \"main\" ]\n  pull_request:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: 코드 확인\n        uses: actions/checkout@v2\n\n      - name: Node.js 설정\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: 의존성 설치\n        run: npm install\n\n      - name: 앱 빌드\n        run: npm run build\n\n      - name: S3에 업로드\n        uses: jakejarvis/s3-sync-action@master\n        with:\n          args: --acl public-read\n        env:\n          SOURCE_DIR: build/\n          AWS_S3_BUCKET: ${ secrets.AWS_S3_BUCKET }\n          AWS_ACCESS_KEY_ID: ${ secrets.AWS_ACCESS_KEY_ID }\n          AWS_SECRET_ACCESS_KEY: ${ secrets.AWS_SECRET_ACCESS_KEY }\n```\n\n## 단계 8: GitHub에 추가하기\n\n\u003cimg src=\"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_14.png\" /\u003e\n\n## 단계 9: Action 섹션으로 이동하여 프로세스 보기하기\n\n\n\n코드를 업로드한 후 Action 섹션으로 이동하여 GitHub Actions가 코드를 빌드하고 S3로 업로드하는 과정을 확인해보세요. 처음에는 시간이 조금 걸릴 수 있지만 첫 번째 푸시 이후에는 변경 사항이 처음과 비교했을 때 적으므로 시간이 줄어들 것입니다.\n\n클릭한 후 최근 커밋을 볼 수 있습니다. 그리고 빌드를 클릭하세요. 진행 중인 모든 프로세스를 볼 수 있습니다. 모든 작업이 완료되면 다음을 볼 수 있습니다:\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_15.png)\n\n이것은 모든 프로세스가 완료되었고 빌드 파일이 aws에서 제공된 버킷 이름으로 업로드되었음을 의미합니다.\n\n\n\n## 단계 10: S3를 웹 호스팅으로 구성\n\nGitHub에서 업로드된 파일을 여기서 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_16.png)\n\n이제 프로퍼티 섹션으로 이동하여 맨 아래로 스크롤합니다. 정적 웹사이트 호스팅 옵션을 볼 수 있습니다. 편집을 클릭하고 활성화하고 index.html을 index 문서 섹션에 작성하십시오. 그런 다음 변경 사항을 저장하십시오.\n\n\n\n![Main image](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_17.png)\n\n이제 정적 웹사이트 호스팅 섹션에 링크가 보입니다. 새 탭에서 열어보세요.\n\n![Image 18](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_18.png)\n\n![Image 19](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_19.png)\n\n\n\nReact 애플리케이션이 이제 실시간으로 작동 중이에요. 코드를 변경하고 GitHub에 푸시하면, 여기서 몇 초 내에 새로운 변경 사항이 보입니다.\n\n이 게시물을 읽어주셔서 감사합니다! AWS S3에서 GitHub Actions를 사용하여 React.js 애플리케이션을 배포하고 호스팅하는 여정에서 도움이 되었기를 바랍니다. 질문, 피드백 또는 제안이 있으시면 언제든지 연락해주세요. 여러분의 의견은 소중하고 큰 도움이 됩니다.\n\n## 추가 읽을거리:","ogImage":{"url":"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_0.png"},"coverImage":"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_0.png","tag":["Tech"],"readingTime":6},{"title":"Nextjs 프로젝트에서 ApexCharts를 사용하는 방법","description":"","date":"2024-05-12 22:10","slug":"2024-05-12-HowToUseApexChartsinaNextjsProject","content":"\n\n![이미지](/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_0.png)\n\nNext.js는 확실히 프런트엔드 랜드스케이프에서 주요 메타 프레임워크 중 하나입니다. 그러나 인기 있는 차트 라이브러리인 ApexCharts를 Next.js와 함께 사용할 때 특정 문제가 발생하는 것 같습니다. 이 글에서는 그 문제가 무엇인지와 해결 방법에 대해 논의하겠습니다.\n\n# 새 프로젝트를 초기화하는 방법을 살펴봅시다\n\n다음은 새 Next.js 프로젝트를 초기화하는 명령 프롬프트입니다(이미 초기화하는 방법을 잘 알고 계실 것 같지만, 문서를 열 필요 없이 편리하게 확인하실 수 있도록 제공드립니다)\n\n\n\n```js\n#npm\nnpx create-next-app@latest\n\n#pnpm\npnpm create next-app\n```\n\nApexCharts를 위한 필요한 의존성을 모두 설치하는 것을 잊지 마세요. 리액트 래퍼를 포함하면 됩니다.\n\n```js\n#npm\nnpm i react-apexcharts apexcharts\n\n#pnpm\npnpm i react-apexcharts apexcharts\n```\n\n우리는 기존의 신뢰받는 페이지와 새롭고 반짝이는 앱 디렉토리를 함께 사용할 것입니다. 두 가지의 구현 차이는 크지 않으니 시작해 봅시다.\n\n\n\n두 가지 디렉토리 유형 중에서, 저는 개인적으로 폴더 구조를 이렇게 선호합니다 (특히 components 폴더 위치). 여러분은 자신의 구조 선호도에 맞게 조정하시면 됩니다.\n\n```js\nnextjs_project\n├── node_modules\n├── public\n└── src\n    ├── components\n    └── pages/app\n```\n\n# 그래프 컴포넌트 만들기\n\ncomponents 폴더 안에, charts.tsx/jsx 파일을 만들어 보겠습니다.\n\n\n\n```js\n// charts.tsx/jsx\n\n'use client' // 앱 디렉토리를 사용한다면, 이 줄을 빼먹지 마세요\n\nimport dynamic from \"next/dynamic\";\nconst ApexChart = dynamic(() =\u003e import(\"react-apexcharts\"), { ssr: false });\n\n\nexport function ExampleChart(){\n\n    const option = {\n        chart: {\n          id: 'apexchart-example'\n        },\n        xaxis: {\n          categories: [1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999]\n        }\n      }\n\n    const series = [{\n        name: 'series-1',\n        data: [30, 40, 35, 50, 49, 60, 70, 91, 125]\n      }]\n\n    return(\n        \u003c\u003e\n            \u003cApexChart type=\"line\" options={option} series={series} height={200} width={500} /\u003e\n        \u003c/\u003e\n    )\n    \n}\n```\n\n만약 react-apexcharts — npm (npmjs.com)에서 아래와 같이 가져오려고 한다면\n\n```js\nimport Chart from 'react-apexcharts'\n```\n\n아마도 이런 에러를 마주하게 될 것입니다\n\n\n\n마크다운 형식을 사용하면 더 좋을 것 같아요.\n\n![HowToUseApexChartsinaNextjsProject_1](/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_1.png)\n\n혹은 터미널에서는 이렇게 보일지도 몰라요.\n\n![HowToUseApexChartsinaNextjsProject_2](/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_2.png)\n\n이 에러는 Next.js의 자동 프리랜더링(렌더링: 자동 정적 최적화 | Next.js (nextjs.org)) 때문에 발생한 것 같아요. ApexChart 라이브러리는 클라이언트 쪽에 있는 window 인터페이스에 의존하기 때문에 본문 작성 시점에는 서버에서 프리랜더링할 수 없는 것으로 보입니다.\n\n\n\n그래서 Next.js가 이 경우를 해결하기 위해 제공한 솔루션은 내장된 next/dynamic을 사용하여 동적 가져오기를 수행하고 서버 측 사전 렌더링을 중지하도록 명시적으로 구성하는 것입니다.\n\n```js\n'use client' // 전체 파일을 클라이언트 측 컴포넌트로 표시하려면 앱 디렉터리를 사용하는 경우 이 부분을 잊지 마세요\n\nimport dynamic from \"next/dynamic\";\nconst Chart = dynamic(() =\u003e import(\"react-apexcharts\"), { ssr: false });\n```\n\n# 직접 해 보세요!\n\n이것은 페이지 디렉터리를 위한 것입니다.\n\n\n\n그리고 이것은 앱 디렉토리를 위한 것입니다.\n\n지금까지 제가 전달할 내용은 여기까지입니다. 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_0.png"},"coverImage":"/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트와 리덕스 툴킷으로 할 일 앱 만들기","description":"","date":"2024-05-12 22:09","slug":"2024-05-12-BuildingaTodoAppwithReactandReduxToolkit","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-BuildingaTodoAppwithReactandReduxToolkit_0.png\" /\u003e\n\n# 소개:\n\n이 튜토리얼에서는 React와 Redux Toolkit을 사용하여 간단한 할 일 앱을 구축할 것입니다. Redux Toolkit은 유틸리티 함수와 추상화를 제공하여 Redux에서 상태 관리를 간소화하는 강력한 라이브러리입니다. 이 튜토리얼을 마치면 React 애플리케이션에서 상태를 관리하는 데 Redux Toolkit을 사용하는 방법에 대해 확고한 이해를 얻을 것입니다.\n\n## 전제 조건:\n\n\n\n시작하기 전에 컴퓨터에 Node.js와 npm이 설치되어 있는지 확인해 주세요. React 기초 지식이 있다면 더 좋습니다.\n\n## 단계 1: 프로젝트 설정하기\n\n시작하려면 Create React App을 사용하여 새 React 프로젝트를 만들어야 합니다. 터미널을 열고 다음 명령어를 실행해주세요:\n\n```js\nnpx create-react-app todo-app\n```\n\n\n\n## 단계 2: 의존성 설치\n\n프로젝트 디렉토리로 이동하여 다음 명령어를 실행하여 필요한 의존성을 설치하세요:\n\n```js\ncd todo-app\nnpm install @reduxjs/toolkit react-redux\n```\n\n## 단계 3: Redux 슬라이스 이해하기\n\n\n\n코딩에 들어가기 전에 Redux 슬라이스 개념을 간단히 이해해 봅시다. 슬라이스는 애플리케이션의 상태와 연결된 리듀서의 논리적인 부분입니다. 초기 상태를 포함하고 상태가 액션에 응답하여 업데이트되는 방법을 정의합니다.\n\n## 단계 4: Redux 슬라이스 생성\n\n`src` 디렉토리에서 `todoSlice.js`라는 새 파일을 생성하세요. 이 파일은 할 일 관리를 위한 Redux 슬라이스를 담고 있을 것입니다. `todoSlice.js` 안에서 `@reduxjs/toolkit`에서 `createSlice` 함수를 가져와서 할 일 슬라이스의 초기 상태와 리듀서를 정의하세요.\n\n```js\nimport { createSlice } from \"@reduxjs/toolkit\";\n\nconst todoSlice = createSlice({\n  name: \"todos\",\n  initialState: [],\n  reducers: {\n    addTodo: (state, action) =\u003e {\n      const newTodo = {\n        id: Date.now(),\n        text: action.payload,\n        completed: false,\n      };\n      state.push(newTodo);\n    },\n    toggleComplete: (state, action) =\u003e {\n      const todo = state.find((todo) =\u003e todo.id === action.payload);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n    deleteTodo: (state, action) =\u003e {\n      const index = state.findIndex((todo) =\u003e todo.id === action.payload);\n      if (index !== -1) {\n        state.splice(index, 1);\n      }\n    },\n  },\n});\nexport const { addTodo, toggleComplete, deleteTodo } = todoSlice.actions;\nexport default todoSlice.reducer;\n```\n\n\n\n## 단계 5: Redux 스토어 구성하기\n\n이제 우리의 애플리케이션 상태를 보유할 Redux 스토어를 생성해 봅시다. `src` 디렉토리 내에 `store.js`라는 새 파일을 생성하세요. 이 파일 안에서 `@reduxjs/toolkit`에서 `configureStore` 함수와 `todoSlice` 리듀서를 import합니다. 그 후 `configureStore`를 사용하여 Redux 스토어를 생성하세요.\n\n```js\nimport { configureStore } from '@reduxjs/toolkit';\nimport todoReducer from './todoSlice';\n\nconst store = configureStore({\n reducer: {\n todos: todoReducer,\n },\n});\n\nexport default store;\n```\n\n## 단계 6: Todo 컴포넌트 구성하기\n\n\n\n이제 `src` 디렉토리에 `Todo.js` 파일을 만들어 봅시다. 이 파일에는 할 일 리스트의 표시 및 관리를 처리할 `Todo` 컴포넌트가 포함됩니다. `Todo.js` 내에서 React, `react-redux`에서 필요한 훅 및 컴포넌트, 그리고 `todoSlice`에서 액션을 import하세요.\n\n```js\nimport React, { useState } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { addTodo, toggleComplete, deleteTodo } from \"./todoSlice\";\n\nconst Todo = () =\u003e {\n  const [text, setText] = useState(\"\");\n  const todos = useSelector((state) =\u003e state.todos);\n  const dispatch = useDispatch();\n\n  const handleInputChange = (e) =\u003e {\n    setText(e.target.value);\n  };\n\n  const handleAddTodo = () =\u003e {\n    if (text) {\n      dispatch(addTodo(text));\n      setText(\"\");\n    }\n  };\n\n  const handleToggleComplete = (id) =\u003e {\n    dispatch(toggleComplete(id));\n  };\n\n  const handleDeleteTodo = (id) =\u003e {\n    dispatch(deleteTodo(id));\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cinput type=\"text\" value={text} onChange={handleInputChange} /\u003e{\" \"}\n      \u003cbutton onClick={handleAddTodo}\u003e 할 일 추가 \u003c/button\u003e{\" \"}\n      \u003cul\u003e\n        {\" \"}\n        {todos.map((todo) =\u003e (\n          \u003cli\n            key={todo.id}\n            style={{\n              textDecoration: todo.completed ? \"line-through\" : \"none\",\n            }}\n          \u003e\n            {todo.text}{\" \"}\n            \u003cbutton onClick={() =\u003e handleToggleComplete(todo.id)}\u003e\n              {\" \"}\n              {todo.completed ? \"미완료 처리\" : \"완료 처리\"}{\" \"}\n            \u003c/button\u003e{\" \"}\n            \u003cbutton onClick={() =\u003e handleDeleteTodo(todo.id)}\u003e 삭제 \u003c/button\u003e{\" \"}\n          \u003c/li\u003e\n        ))}{\" \"}\n      \u003c/ul\u003e{\" \"}\n    \u003c/div\u003e\n  );\n};\n\nexport default Todo;\n```\n\n## Step 7: App 컴포넌트 업데이트하기\n\n`Todo` 컴포넌트를 렌더링하려면 `App.js` 파일을 약간 수정해야 합니다. React, `react-redux`의 `Provider` 컴포넌트, 그리고 `store.js` 파일에서 `store`를 import하세요. 그런 다음, `Todo` 컴포넌트를 `Provider` 컴포넌트로 감싸고 store를 prop으로 전달하세요.\n\n\n\n```js\nimport React from \"react\";\nimport { Provider } from \"react-redux\";\nimport store from \"./store\";\nimport Todo from \"./Todo\";\n\nconst App = () =\u003e {\n  return (\n    \u003cProvider store={store}\u003e\n       \u003cTodo /\u003e \n    \u003c/Provider\u003e\n  );\n};\n\nexport default App;\n```\n\n## 단계 8: 앱 실행하기\n\n이제 할 일 앱을 실제로 실행해보는 시간입니다! 터미널에서 다음 명령어를 실행해주세요:\n\n```js\nnpm start\n```\n\n\n\n브라우저에서 http://localhost:3000을 방문하면 할 일 앱이 정상적으로 작동하는 것을 확인할 수 있습니다. 할 일을 추가하고 완료로 표시하거나 삭제할 수 있습니다. Redux Toolkit은 상태 관리를 효율적이고 쉽게 처리하게 해줍니다.\n\n![이미지](/assets/img/2024-05-12-BuildingaTodoAppwithReactandReduxToolkit_1.png)\n\n# 결론:\n\n이 튜토리얼에서 React와 Redux Toolkit을 사용하여 할 일 앱을 만드는 방법을 배웠습니다. Redux 슬라이스의 개념을 살펴보고 Redux Toolkit의 `createSlice` 함수를 사용하여 할 일을 관리하는 상태와 리듀서를 정의했습니다. 이 튜토리얼을 따라하면 Redux Toolkit을 사용해 React 애플리케이션의 상태를 관리하는 뛰어난 기초를 마련할 수 있을 것입니다.\n\n\n\n더 많은 기능을 추가하여 할 일을 편집하거나 완료 상태에 따라 필터링하는 등 앱을 사용자 정의하고 향상시키는 것에 자유롭게 도전해보세요. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-05-12-BuildingaTodoAppwithReactandReduxToolkit_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingaTodoAppwithReactandReduxToolkit_0.png","tag":["Tech"],"readingTime":5},{"title":"리액트 JS에서 리액트 폼 훅과 useFieldArray 훅을 함께 사용하는 방법","description":"","date":"2024-05-12 22:08","slug":"2024-05-12-HowtoUsetheuseFieldArrayHookwithReactFormHookinReactJS","content":"\n\n소프트웨어 개발자로서, React Form Hook에서 useFieldArray 훅을 사용하는 방법에 대해 여러분과 공유할 수 있어서 정말 기쁩니다. 이 훅은 동적으로 폼 필드를 추가하거나 제거할 수 있는 강력한 도구로, 다수의 입력 필드가 있는 복잡한 폼을 쉽게 관리할 수 있게 해줍니다.\n\n먼저, 필요한 종속성을 설치하는 방법부터 시작해보겠습니다. React Hook Form 라이브러리와 useFieldArray 훅을 설치해야 합니다. 터미널에서 다음 명령을 실행하여 이 작업을 수행할 수 있습니다:\n\n```js\nnpm install react-hook-form\n```\n\n의존성을 설치했다면, React 폼에서 useFieldArray 훅을 구현할 수 있습니다. 이 훅을 사용하는 예시를 보여드리겠습니다:\n\n\n\n```js\nimport React from 'react';\nimport { useForm, useFieldArray } from 'react-hook-form';\n\nfunction MyForm() {\n  const { register, control, handleSubmit } = useForm({\n    defaultValues: {\n      items: [{ name: 'item1' }, { name: 'item2' }],\n    },\n  });\n\n  const { fields, append, remove } = useFieldArray({\n    control,\n    name: 'items',\n  });\n\n  const onSubmit = (data) =\u003e console.log(data);\n\n  return (\n    \u003cform onSubmit={handleSubmit(onSubmit)}\u003e\n      {fields.map((field, index) =\u003e (\n        \u003cdiv key={field.id}\u003e\n          \u003cinput\n            {...register(`items.${index}.name`)}\n            defaultValue={field.name}\n          /\u003e\n          \u003cbutton type=\"button\" onClick={() =\u003e remove(index)}\u003e\n            Remove\n          \u003c/button\u003e\n        \u003c/div\u003e\n      ))}\n      \u003cbutton type=\"button\" onClick={() =\u003e append({ name: '' })}\u003e\n        Add Item\n      \u003c/button\u003e\n      \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\n    \u003c/form\u003e\n  );\n}\n\nexport default MyForm;\n```\n\n이 예제에서는 useForm 훅을 사용하여 기본값으로 form을 초기화했습니다. 또한 useFieldArray 훅을 사용하여 \"items\" 필드 배열을 관리했습니다. \"control\" 속성은 useForm 훅과 상호 작용할 수 있도록 useFieldArray 훅에 전달됩니다.\n\nfields.map 함수는 \"items\" 배열의 각 입력 필드를 렌더링하는 데 사용됩니다. \"Remove\" 버튼을 클릭하면 제거 함수가 호출되고, \"Add Item\" 버튼을 클릭하면 추가 함수가 호출됩니다.\n\nuseFieldArray 훅을 사용하면 form의 상태를 수동으로 관리하지 않고도 form에서 필드를 쉽게 추가하거나 제거할 수 있습니다. 이를 통해 동적 입력이 있는 복잡한 form을 쉽게 생성할 수 있습니다.\n\n\n\n\n하지만 \"items\" 배열에서 더 많은 필드를 사용하고 싶다면 어떻게 해야 할까요? 걱정하지 마세요! 단순히 양식에 더 많은 입력을 추가하면 됩니다. \"name\"과 \"quantity\" 두 필드를 \"items\" 배열에 포함한 예제를 보여드리겠습니다:\n\n```js\nimport React from 'react';\nimport { useForm, useFieldArray } from 'react-hook-form';\n\nfunction MyForm() {\n const { register, control, handleSubmit } = useForm({\n defaultValues: {\n items: [{ name: 'item1', quantity: 1 }, { name: 'item2', quantity: 2 }],\n },\n });\n \n const { fields, append, remove } = useFieldArray({\n control,\n name: 'items',\n });\n\n const onSubmit = (data) =\u003e console.log(data);\n\n return (\n \u003cform onSubmit={handleSubmit(onSubmit)}\u003e\n {fields.map((field, index) =\u003e (\n \u003cdiv key={field.id}\u003e\n \u003cinput\n {…register(`items.${index}.name`)}\n defaultValue={field.name}\n /\u003e\n \u003cinput\n {…register(`items.${index}.quantity`)}\n defaultValue={field.quantity}\n /\u003e\n \u003cbutton type=\"button\" onClick={() =\u003e remove(index)}\u003e\n Remove\n \u003c/button\u003e\n \u003c/div\u003e\n ))}\n \u003cbutton type=\"button\" onClick={() =\u003e append({ name: '', quantity: 0 })}\u003e\n Add Item\n \u003c/button\u003e\n \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\n \u003c/form\u003e\n );\n}\n\nexport default MyForm;\n```\n\n이 업데이트된 예제에서 \"quantity\"에 대한 두 번째 입력 필드가 추가되었습니다. 여전히 \"items\" 배열의 각 입력 필드를 렌더링하는 데 이전과 동일한 접근 방식을 사용하고 있습니다. \"Remove\" 버튼을 클릭하면 여전히 remove 함수가 호출되고, \"Add Item\" 버튼을 클릭하면 여전히 append 함수가 호출됩니다.\n\nuseForm 및 useFieldArray 훅을 함께 사용하면 React JS에서 여러 입력을 가진 복잡한 양식을 쉽게 관리할 수 있습니다. useFieldArray 훅은 폼에서 동적으로 필드를 추가하거나 제거할 수 있는 강력한 도구로, 동적이고 사용자 친화적인 양식을 만드는 데 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-05-12-HowtoUsetheuseFieldArrayHookwithReactFormHookinReactJS_0.png"},"coverImage":"/assets/img/2024-05-12-HowtoUsetheuseFieldArrayHookwithReactFormHookinReactJS_0.png","tag":["Tech"],"readingTime":4},{"title":"코드 형태의 형상  코드 생성을 활용하여 개발자의 작업 흐름 최적화하기","description":"","date":"2024-05-12 22:06","slug":"2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration","content":"\n\n스타터 템플릿과 코드 생성기는 개발자들이 새로운 언어나 프레임워크로 시작하는 인기 있는 방법입니다. 그러나 많은 경우 이들은 효율적이고 견고한 개발 워크플로우를 지원하지 못하는 것이 문제입니다. 대부분의 코드 생성기는 프로덕션 품질의 도구가 없으며 생성 능력이 제한되어 사용자 정의를 공유하기 어렵게 만듭니다.\n\n![Code Shape 사진](/assets/img/2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration_0.png)\n\n오늘은 이러한 문제를 해결하기 위해 전면부터 설계된 코드 생성 플랫폼인 Code Shaper를 소개하고 싶습니다. 여기 몇 가지 주요 기능을 소개합니다:\n\n- 모듈식이므로 프로덕션 품질의 도구 추가 가능\n- React, Next.js, Remix와 같은 인기있는 프레임워크용 사전 제공 생성기 포함\n- 린팅, 테스팅, 컴포넌트 개발, API 모킹에 대한 의견이 분분한 선택 제공\n- 워크플로우 사용자 정의가 필요한 경우 사용자 정의 생성기 빌드 가능\n- npm 등의 레지스트리를 사용하여 팀과 생성기 공유 가능\n\n\n\nCode Shaper은 작업 흐름을 신속하고 일관되게 그리고 표준화된 방식으로 만들어줍니다. Code Shaper가 어떻게 여러분의 작업 흐름을 최적화할 수 있는지 느껴보기 위해 간단한 Next.js 앱을 만들어보겠습니다.\n\n아래는 Code Shaper 사이트의 전체 설명서를 요약한 것입니다. 여러분은 전체 연습을 직접 경험하거나 다른 프레임워크를 시도해볼 수 있는 곳으로 바로 이동할 수 있습니다.\n\n# 시작하기\n\nCode Shaper를 사용하면 단일 저장소에서 여러 아티팩트를 생성할 수 있습니다. 이는 웹 애플리케이션, 재사용 가능한 라이브러리, 코드 생성기 또는 상상할 수 있는 모든 것일 수 있습니다. 각 아티팩트에는 자체 워크스페이스가 있습니다. 워크스페이스는 저장소의 구성 요소로 생각할 수 있습니다.\n\n\n\n코드 쉐이퍼를 설정하는 것은 두 단계로 이루어져요:\n\n- 새로운 레포지토리 생성하기\n- 그 안에 하나 이상의 아티팩트 추가하기\n\n단계 2는 서로 다른 언어와 프레임워크를 사용하는 아티팩트를 추가하기 위해 여러 번 반복할 수 있어요.\n\n그럼 이제 새로운 레포지토리를 만들어 시작해볼까요?\n\n\n\n## 새로운 레포지토리 만들기\n\n먼저, 앱과 라이브러리와 같은 다양한 아티팩트를 추가할 기반으로 사용할 새로운 레포지토리를 만들겠습니다. 계속하기 전에 가져야 할 몇 가지 전제 조건이 있습니다:\n\n- 머신에 Node Version Manager (NVM)가 설치되어 있는지 확인하세요. NVM을 통해 명령 줄을 통해 다양한 노드 버전을 사용할 수 있습니다. NVM을 설치하려면 아래 지침을 따르세요:\n  NVM for MacOS\n  NVM for Windows\n- TypeScript를 이해하는 IDE가 설치되어 있는지 확인하세요. Visual Studio Code (무료)와 WebStorm (유료) 모두 좋은 선택지입니다.\n\n```js\n# 보통 새 프로젝트를 만드는 위치(예: ~/projects)로 디렉터리 변경\ncd ~/projects\n\n# 레포지토리용으로 빈 디렉터리를 만들고 해당 디렉터리로 이동합니다.\n# 레포지토리는 일반적으로 케밥 케이스로 명명됩니다.\nmkdir movie-magic\ncd movie-magic\n\n# 빈 package.json 파일 생성\nnpm init -y\n\n# Code Shaper 및 해당 레포지토리 플러그인 설치\nnpm install code-shaper @code-shaper/repo\n\n# Code Shaper 실행하고 프롬프트에 따라 turborepo를 초기화합니다.\nnpx shaper\n? 어떤 플러그인을 실행하시겠습니까? Repo\n? 어떤 생성기를 실행하시겠습니까? turborepo\n? 이 생성기는 레포지토리의 일부 파일을 덮어쓸 것입니다. 계속 하시겠습니까? y\n```\n\n\n\nCode Shaper가 Turborepo와 새로운 package.json 파일을 사용하여 저장소를 초기화했습니다. 아래 명령을 실행하여 새로운 종속성을 설치한 후 첫 번째 커밋을 만들어보세요:\n\n```js\n# 현재 디렉토리에 git 저장소를 초기화합니다\ngit init\n\n# 필요한 Node.js 버전을 사용합니다.\n# 필요한 Node.js 버전이 설치되어 있지 않으면\n# 설치하라는 프롬프트가 표시됩니다.\nnvm use\n\n# 새로 생성된 package.json 파일로 초기 설치를 수행합니다\nrm -rf package-lock.json node_modules\nnpm install\n\n# 첫 번째 커밋을 만듭니다\n# 매 단계가 끝날 때마다 커밋하여 완료된 단계를 표시합니다.\n# 커밋 메시지에는 일반적인 규약을 따르는 것에 주의하세요.\n# `npm run commit` 명령을 사용하여 프롬프트를 통해 도와줍니다.\n# 다음 git 명령을 직접 실행하는 것과 동일합니다:\n#   git commit -m \"chore: initial commit\"\ngit add .\nnpm run commit\n ? 이 변경 내용의 유형을 선택하세요 (필수): chore\n ? 이 변경 내용의 범위를 선택하세요 (선택사항) (Enter를 눌러 건너뛰기): \u003cEnter 키\u003e\n ? 이 짧은 문장을 완료하세요 (필수): \"이 커밋을 적용하면...\": (최대 100자)\n initial commit\n ? 변경 사항에 대한 자세한 설명을 제공하세요 (선택사항): (Enter를 눌러 건너뛰기): \u003cEnter 키\u003e\n ? 파손되는 변경 사항이 있나요?: 아니요\n [master (root-commit)] chore: initial commit\n```\n\n이제 저장소가 모두 설정되었으니, 첫 번째 아티팩트를 추가해봅시다. 우리는 Next.js 앱으로 시작할 것입니다.\n\n## Next.js 앱 만들기\n\n\n\nCode Shaper 플러그인을 Next.js에 설치해보세요.\n\n```js\nnpm install @code-shaper/nextjs\n```\n\n이제 Next.js 애플리케이션을 생성해봅시다. 관례적으로 애플리케이션은 apps 디렉토리에 만들어집니다. 거기에 하나를 만들어볼까요?\n\n```js\nnpx shaper\n? 어떤 플러그인을 실행하고 싶으신가요? Next.js\n? 어떤 생성기를 실행하고 싶으신가요? app\n? 애플리케이션 이름은? movie-magic-nextjs\n? 상위 디렉토리는? apps\n? 패키지 이름(게시용)? @movie-magic/movie-magic-nextjs\n? Tailwind CSS를 사용하시겠습니까? Yes\n```\n\n\n\n다음 명령어를 실행하여 추가 설정을 하고 모든 변경 사항을 커밋하세요:\n\n```js\n# 영화 매직을 위한 로컬 환경 파일 생성\ncp apps/movie-magic-nextjs/.env.example apps/movie-magic-nextjs/.env.local\n\n# 의존성 설치:\nnpm install\n\n# 앱 빌드 및 실행하여 작동 확인\nnpm run build\nnpm run dev\n\n# 브라우저를 http://localhost:3000/ 로 이동하세요.\n# 실행 중인 앱을 볼 수 있어야 합니다.\n\n# Storybook 실행하여 작동 확인\nnpm run storybook\n\n# 브라우저를 http://localhost:6006/ 로 이동하세요.\n# 실행 중인 Storybook을 볼 수 있어야 합니다.\n\n# 커밋\ngit add .\ngit commit -m \"chore: add movie-magic-nextjs app\"\n```\n\n이제 우리는 스타터 앱을 확장할 준비가 되었습니다. 앱 이름에서 짐작하실 수 있듯이, 세계에서 가장 놀라운 최고 10개의 영화를 보여주는 앱을 만들 것입니다. 🎬\n\n\u003cimg src=\"/assets/img/2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration_1.png\" /\u003e\n\n\n\n## 앱 확장하기\n\n이 예제에서 사용할 라이브러리를 설치하려면 레포지토리의 루트 디렉토리에서 다음 명령을 실행하세요.\n\n```js\nnpm install clsx axios @tanstack/react-query --workspace @movie-magic/movie-magic-nextjs\n```\n\nTypeScript 정의 생성\n우리 앱에서 필요한 데이터 구조에 대한 TypeScript 정의를 생성해봅시다. 완료된 예제에서 다음 4개의 파일을 복사하여 앱의 movie-magic-nextjs/src/models 폴더에 붙여넣어주세요.\n\n\n\n- index.ts\n- Movie.ts\n- PaginationInfo.ts\n- QueryParams.ts\n\n영화 목록 컴포넌트 만들기\n이제 우리는 영화 목록을 받아와서 보여주는 MovieList 컴포넌트를 생성할 것입니다. 이러한 컴포넌트들은 presentational components라고 불립니다 - 데이터를 어떻게 얻었는지에 대해 걱정하지 않고, 단순히 렌더링하는 것이 그들의 일입니다.\n\nNext.js 플러그인이 제공하는 컴포넌트 생성기를 사용하여 `MovieList` 컴포넌트를 생성할 것입니다. 아래 단계를 따라주세요:\n\n```js\nnpx shaper\n? 어떤 플러그인을 실행하시겠습니까? Next.js\n? 어떤 생성기를 실행하시겠습니까? component\n? 컴포넌트 이름은? MovieList\n? 이 작업은 어느 워크스페이스에 속하나요? apps/movie-magic-nextjs\n? 워크스페이스 내 어느 디렉토리에 위치시키시겠습니까? src/components/MovieList\n```\n\n\n\n예를 위해 MovieList 컴포넌트를 위한 플레이스홀더가 생성되었습니다. 또한 Storybook 스토리를 위한 플레이스홀더가 생성되었습니다. 이제 Storybook를 사용하여 MovieList를 인터랙티브하게 구현해 봅시다.\n\n```js\nnpm run storybook\n```\n\n브라우저를 http://localhost:6006 주소로 연결하세요. Storybook은 MovieList의 플레이스홀더 구현을 보여줍니다.\n\nMovieList 컴포넌트 구현하기\n이제 우리는 실제 MovieList를 구현할 준비가 되었습니다.\n\n\n\n- 영화 데이터를 렌더링할 데이터를 만드세요. 완료된 예제에서 movies.ts 파일을 앱/movie-magic-nextjs/src/mocks 폴더로 복사하세요.\n- 완료된 예제에서 MovieList 컴포넌트의 placeholder 구현을 덮어쓰세요. 앱/movie-magic-nextjs/src/components/MovieList/MovieList.tsx에 있습니다.\n- 완료된 예제에서 MovieList의 placeholder 스토리를 덮어쓰세요. 앱/movie-magic-nextjs/src/components/MovieList/MovieList.stories.tsx에 있습니다.\n\n다음은 최종 Storybook 스토리의 스냅샷입니다.\n\n![코드 형태 최적화를 통해 개발자 워크플로우를 개선하는 2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration_2.png](/assets/img/2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration_2.png)\n\n## MovieList 컴포넌트를 테스트하세요\n\n\n\n컴포넌트에 대한 유닛 테스트를 작성하면 다음을 보장할 수 있어요:\n\n- 정상적으로 작동하는지 확인할 수 있고,\n- 리포지토리의 어떤 코드가 변경되더라도 계속해서 정상적으로 작동하는지 확인할 수 있어요.\n\nMovieList 컴포넌트에 대한 유닛 테스트를 작성해봅시다. 이 테스트는 올바른 영화 수를 렌더링하는지 확인할 거에요. React Testing Techniques에서 더 많은 유닛 테스트에 대한 모범 사례를 찾을 수 있어요.\n\n완성된 예시에서 apps/movie-magic-nextjs/src/components/MovieList/MovieList.test.tsx의 플레이스홀더 테스트를 덮어씌워주세요.\n\n\n\n루트 디렉토리에서 테스트를 실행하세요. 모든 테스트가 통과해야 해요.\n\n```js\nnpm test\n```\n\nMovieList가 이제 완전히 구현되었습니다. 코드를 커밋합시다:\n\n```js\n# 커밋\ngit add .\ngit commit -m \"feat: MovieList 추가\"\n```\n\n\n\n# 요약\n\n이 연습을 통해 코드 생성을 통해 작업 흐름을 최적화 할 수 있는 Code Shaper가 어떻게 도움이 될 수 있는지 감을 잡았을 것입니다. 이제 샘플 앱을 만들었으니, 품질 좋은 코드 생성 플랫폼이 어떻게 빠르게 견고한 응용프로그램을 개발하는 데 도움이 될 수 있는지 보실 수 있을 것입니다.\n\n다음은 추가로 살펴볼 수 있는 자료입니다:\n\n- 시작하기 — Code Shaper의 더 많은 기능을 다루는 심층 튜토리얼\n- Off-the-shelf 플러그인\n- 자체 사용자 정의 생성기 만들기\n- Movie Magic — 다양한 프레임워크를 사용하여 응용프로그램을 생성하는 방법의 예제\n\n\n\n이 기사는 원문을 참조하여 작성되었습니다: [https://www.nareshbhatia.dev/articles/code-shaper-optimizing-developer-workflows](https://www.nareshbhatia.dev/articles/code-shaper-optimizing-developer-workflows)","ogImage":{"url":"/assets/img/2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration_0.png"},"coverImage":"/assets/img/2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration_0.png","tag":["Tech"],"readingTime":7}],"page":"130","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"130"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>