<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/11" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/11" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="2024 최신 Python Flask와 Nodejs Express 비교" href="/post/2024-06-23-PythonFlaskvsNodejsExpress"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024 최신 Python Flask와 Nodejs Express 비교" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-PythonFlaskvsNodejsExpress_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024 최신 Python Flask와 Nodejs Express 비교" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024 최신 Python Flask와 Nodejs Express 비교</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="이미지에서 표를 JSON으로 추출하는 GPT-4 사용 방법" href="/post/2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="이미지에서 표를 JSON으로 추출하는 GPT-4 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="이미지에서 표를 JSON으로 추출하는 GPT-4 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">이미지에서 표를 JSON으로 추출하는 GPT-4 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs에서 SSO Single Sign-On 이해하기 구현 방법과 사례 설명" href="/post/2024-06-23-UnderstandingSSOSingleSignOninNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs에서 SSO Single Sign-On 이해하기 구현 방법과 사례 설명" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UnderstandingSSOSingleSignOninNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs에서 SSO Single Sign-On 이해하기 구현 방법과 사례 설명" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs에서 SSO Single Sign-On 이해하기 구현 방법과 사례 설명</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="사용하지 않을 때에도 웹 서비스 활동 유지하는 방법" href="/post/2024-06-23-HackforRenderWebservicesspindownduetoinactivity"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="사용하지 않을 때에도 웹 서비스 활동 유지하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HackforRenderWebservicesspindownduetoinactivity_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="사용하지 않을 때에도 웹 서비스 활동 유지하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">사용하지 않을 때에도 웹 서비스 활동 유지하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Native CICD GitHub Actions와 App Center 사용하는 방법" href="/post/2024-06-23-ReactNativeCICDGitHubActionsAppCenter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Native CICD GitHub Actions와 App Center 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ReactNativeCICDGitHubActionsAppCenter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Native CICD GitHub Actions와 App Center 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Native CICD GitHub Actions와 App Center 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트를 이제 그만 사용해야 하는 이유 5가지" href="/post/2024-06-23-StopusingJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트를 이제 그만 사용해야 하는 이유 5가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-StopusingJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트를 이제 그만 사용해야 하는 이유 5가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트를 이제 그만 사용해야 하는 이유 5가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="협업 편집 기능 추가 우리 뉴스룸 CMS 구축 과정 공개" href="/post/2024-06-23-WeBuiltCollaborativeEditingforOurNewsroomsCMSHeresHow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="협업 편집 기능 추가 우리 뉴스룸 CMS 구축 과정 공개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-WeBuiltCollaborativeEditingforOurNewsroomsCMSHeresHow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="협업 편집 기능 추가 우리 뉴스룸 CMS 구축 과정 공개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">협업 편집 기능 추가 우리 뉴스룸 CMS 구축 과정 공개</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript 프로미스 이해하기 BMW 이야기" href="/post/2024-06-23-UnderstandingJavaScriptPromisesTheBMWStory"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript 프로미스 이해하기 BMW 이야기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UnderstandingJavaScriptPromisesTheBMWStory_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript 프로미스 이해하기 BMW 이야기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript 프로미스 이해하기 BMW 이야기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="실무에서 바로 써먹는 10가지 자바스크립트 꿀팁" href="/post/2024-06-23-10PracticalJavaScriptTips"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="실무에서 바로 써먹는 10가지 자바스크립트 꿀팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-10PracticalJavaScriptTips_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="실무에서 바로 써먹는 10가지 자바스크립트 꿀팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">실무에서 바로 써먹는 10가지 자바스크립트 꿀팁</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Dangerjs를 사용한 코드 리뷰 작업 자동화 방법" href="/post/2024-06-23-AutomatingCodeReviewChoresUsingDangerjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Dangerjs를 사용한 코드 리뷰 작업 자동화 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AutomatingCodeReviewChoresUsingDangerjs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Dangerjs를 사용한 코드 리뷰 작업 자동화 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Dangerjs를 사용한 코드 리뷰 작업 자동화 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link posts_-active__YVJEi" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"2024 최신 Python Flask와 Nodejs Express 비교","description":"","date":"2024-06-23 13:19","slug":"2024-06-23-PythonFlaskvsNodejsExpress","content":"\n\n웹 애플리케이션을 개발할 때, 성능과 확장성을 위해 올바른 프레임워크를 선택하는 것이 중요합니다. Python의 Flask와 Node.js의 Express는 프로젝트 요구 사항에 따라 각각 고유한 장단점을 제공하는 인기 있는 옵션입니다.\n\n![Python Flask vs Node.js Express](/assets/img/2024-06-23-PythonFlaskvsNodejsExpress_0.png)\n\n# 성능\n\n성능 측면에서 Node.js(Express)와 Flask는 각자의 강점과 약점을 가지고 있습니다. Chrome의 V8 JavaScript 엔진 위에 구축된 Node.js는 비동기 I/O 모델과 이벤트 기반 아키텍처 덕분에 우수한 성능으로 알려져 있습니다. 이로 인해 Node.js는 다량의 동시 요청을 효율적으로 처리하며 실행을 지연시키지 않거나 다른 작업을 차단하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한편, 파이썬 기반의 프레임워크인 플라스크는 특정 시나리오에서 노드.js의 원시 성능과 부합하지 않을 수 있습니다. 파이썬의 Global Interpreter Lock (GIL)은 멀티 스레드 환경에서 CPU 바운드 작업의 성능을 제한할 수 있습니다. 그러나 플라스크의 가벼운 성격과 한 번에 처리할 수 있는 요청 수가 적다는 점은 중간 규모의 트래픽이 발생하고 성능 요구 사항이 덜한 애플리케이션에 적합합니다.\n\n노드.js(익스프레스)와 플라스크를 비교한 벤치마크 결과에 따르면, 일반적으로 노드.js가 처리량과 응답 시간 측면에서 플라스크보다 뛰어나며 특히 높은 동시성 환경에서 더 우수한 성능을 보입니다. TechEmpower에 따른 벤치마크에 따르면, 노드.js(익스프레스)는 플라스크에 비해 더 많은 초당 요청을 처리할 수 있었습니다. 그러나 성능은 특정 사용 사례, 애플리케이션 아키텍처, 그리고 적용된 최적화에 따라 다를 수 있습니다. 플라스크의 성능은 캐싱, 라이브러리인 지벤트와 같은 비동기 처리, 그리고 건코른과 같은 WSGI 서버를 사용하는 기술을 통해 개선할 수 있습니다.\n\n최종적으로, 노드.js(익스프레스)와 플라스크 간의 성능 차이는 대부분의 애플리케이션에 있어 결정적인 요소가 되지 않을 수 있습니다. 선택은 프로젝트의 구체적 요구 사항, 개발 팀의 전문성, 그리고 각 프레임워크에 제공되는 라이브러리와 도구 생태계에 기반해야 합니다.\n\n \u003cimg src=\"/assets/img/2024-06-23-PythonFlaskvsNodejsExpress_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 확장성\n\n확장성을 고려할 때 Node.js(Express)는 Flask보다 명확한 장점을 지니고 있어요. Node.js의 이벤트 주도 및 비차단 I/O 모델은 성능 문제 없이 많은 동시 연결을 처리할 수 있게 해줘요. 이 확장성은 Node.js가 시스템 자원을 효율적으로 활용하고 오버헤드를 최소화하여 동시 요청을 처리하는 능력에 기인합니다.\n\n숫자적으로는 Node.js의 단일 인스턴스가 수천 개의 동시 연결을 처리할 수 있는 반면, Flask의 단일 인스턴스는 약 10개 정도의 동시 연결을 처리하는 것으로 제한됩니다. 이 확연한 확장성의 차이로 인해, 높은 트래픽을 예상하고 많은 동시 사용자를 처리해야 하는 애플리케이션에는 Node.js가 더 적합한 선택이 되어요.\n\n파이썬 기반 프레임워크인 Flask는 Python의 Global Interpreter Lock (GIL)에 제약을 받아 진정한 병렬성을 멀티스레드 환경에서 제한받고 있습니다. 특히 CPU 바운드 작업을 다룰 때 Flask 애플리케이션의 확장성에 영향을 미칠 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 중요한 점은 확장성이 프레임워크 자체로만 결정되는 것은 아니라는 점입니다. 적절한 아키텍처 디자인, 효율적인 데이터베이스 관리, 캐싱 전략 및 부하 분산 기술은 Node.js 및 Flask 애플리케이션의 확장성을 크게 향상시킬 수 있습니다.\n\nNode.js의 내장 클러스터링 지원은 애플리케이션이 다중 코어 시스템을 활용하여 여러 CPU 코어를 사용하여 수직으로 확장할 수 있게 합니다. 이 기능을 통해 외부 도구나 복잡한 구성 없이 Node.js 애플리케이션을 확장하는 것이 더 쉬워집니다.\n\n한편 Flask는 로드 밸런서 뒤에 애플리케이션의 여러 인스턴스를 배포함으로써 수평 확장성을 달성할 수 있습니다. 이 접근 방식을 통해 Flask 애플리케이션은 여러 서버에 부하를 분산시켜 트래픽 증가를 처리할 수 있습니다. 간단히 말해, Node.js(Express)는 대규모 동시 연결을 효율적으로 처리할 수 있는 이벤트 주도형, 비차단 아키텍처로 인해 확장성 측면에서 내재적인 우위를 가지고 있습니다. Flask는 기본적으로는 그렇게 확장성이 좋지는 않지만 적절한 아키텍처 및 배포 전략을 통해 수평 확장이 가능합니다. 이 두 프레임워크 중 어떤 것을 선택할지는 애플리케이션의 예상 확장성 요구사항과 개발 팀의 성능 및 확장성 최적화 능력에 기반해 결정되어야 합니다.\n\n![이미지](/assets/img/2024-06-23-PythonFlaskvsNodejsExpress_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 가장 적합한 응용프로그램 유형\n\nNode.js (Express)와 Flask는 각각의 장점과 특성에 따라 다른 유형의 응용프로그램에 적합합니다. Node.js (Express)는 다음과 같은 것들을 구축하는 데에 우수한 선택지입니다:\n\n- 실시간 응용프로그램: Node.js의 이벤트 기반 및 비차단 I/O 모델은 채팅 애플리케이션, 협업 도구, 그리고 게임 플랫폼과 같이 실시간 통신이 필요한 응용프로그램들을 개발하는 데에 이상적입니다.\n- 마이크로서비스 아키텍처: Node.js의 가벼운 모듈화된 성격은 마이크로서비스 아키텍처와 잘 맞습니다. 개발자들은 쉽게 확장하고 유지보수할 수 있는 작고 독립된 서비스를 만들 수 있습니다.\n- 단일 페이지 응용프로그램 (SPA): Node.js는 Angular, React, 그리고 Vue.js 같은 프론트엔드 기술과 시드 나게 통합되어 있어, 원활하고 상호작용적인 사용자 경험을 제공하는 SPA를 구축하는 데에 인기가 있습니다.\n- 데이터 집중형 응용프로그램: Node.js는 대량의 동시 연결 처리 능력과 효율적인 I/O 작업을 다룰 수 있는 능력으로, 스트리밍 플랫폼이나 데이터 처리 파이프라인과 같이 대량의 데이터를 다루는 응용프로그램에 적합합니다.\n\n반면에, Flask는 다음과 같은 용도에 적합합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작은 및 중간 규모의 웹 애플리케이션: Flask의 가벼우면서 미니멀한 특성 덕분에 작고 중간 규모의 웹 애플리케이션을 빠르고 효율적으로 개발하기에 이상적입니다.\n- 프로토타이핑 및 MVP 개발: Flask의 간결함과 유연성으로 인해 개발자들은 빠르게 아이디어를 프로토타입화하고 최소 실현 가능 제품(MVP)을 만들 수 있습니다. 이 과정에서 별다른 복잡한 프레임워크 없이 개발이 가능합니다.\n- RESTful API: Flask는 RESTful API를 쉽고 직관적으로 만들 수 있는 기능을 제공하여 백엔드 서비스 및 마이크로 서비스를 구축하는 데 인기가 있습니다.\n- 머신 러닝 및 데이터 과학 애플리케이션: Flask는 Python의 풍부한 과학 라이브러리와 도구(예: NumPy, Pandas, scikit-learn)와 잘 통합되어 있어 머신 러닝 및 데이터 과학 기능을 활용하는 웹 애플리케이션을 구축하는 데 적합합니다.\n- 신속한 개발: Flask의 간단함과 확장성을 통해 개발자들은 웹 애플리케이션을 빠르게 구축하고 배포할 수 있으며, 프로젝트 기한이 촉박하거나 신속한 반복이 필요한 경우에 좋은 선택지입니다.\n\n# Node.js 또는 Flask 선택하기\n\n![Python Flask vs Node.js Express](/assets/img/2024-06-23-PythonFlaskvsNodejsExpress_3.png)\n\n- 성능 요구사항: 애플리케이션이 뛰어난 성능을 요구하고 큰 수의 동시 요청을 처리해야 하는 경우, 이벤트 기반 및 논블로킹 아키텍처로 인해 Node.js(Express)가 더 나은 선택일 수 있습니다. 그러나 애플리케이션이 중간 성능을 필요로 하는 경우에도 Flask는 여전히 유효한 옵션이 될 수 있습니다.\n- 확장성 기대치: Node.js(Express)는 많은 동시 접속을 다룰 때 특히 잘 확장되는 능력으로 알려져 있습니다. 애플리케이션이 상당한 성장을 예상하고 증가하는 트래픽을 처리해야 하는 경우 Node.js가 더 적합할 수 있습니다. 반면, Flask는 본래 확장성이 떨어지지만 적절한 아키텍처와 배포 전략으로 가로 방향 스케일링이 가능합니다.\n- 개발팀의 전문성: 개발팀의 기술과 경험을 고려하세요. JavaScript에 능숙하고 Node.js 경험이 있는 팀인 경우 Express를 선택하면 기존 지식을 활용하고 학습 곡선을 줄일 수 있습니다. 반면, Python에 더 익숙한 팀이라면 Flask가 더 자연스러울 수 있습니다.\n- 생태계 및 라이브러리: 각 프레임워크에 대한 생태계 및 라이브러리의 가용성을 평가하세요. Node.js는 npm(노드 패키지 매니저)를 통해 다양한 패키지와 모듈이 제공되는 방대한 생태계를 가지고 있습니다. Python 프레임워크인 Flask는 데이터 과학 및 머신 러닝과 같은 분야에서 특히 Python의 풍부한 라이브러리와 도구로 이점을 가집니다.\n- 프로젝트 복잡도 및 규모: Flask의 간단함과 가벼운 특성으로 인해 작고 중간 규모의 프로젝트나 신속한 개발이 필요한 경우에 적합합니다. Node.js(Express)는 실시간 기능이나 마이크로서비스 아키텍처가 포함된 복잡하고 대규모 애플리케이션을 처리할 수 있습니다.\n- 다른 기술과의 통합: 사용할 다른 기술과 얼마나 잘 통합되는지 고려하세요. Node.js는 Angular, React, Vue.js와 같은 프론트엔드 기술과 원활하게 통합되어 있어 전체 스택 JavaScript 애플리케이션을 구축하는 데 좋은 선택입니다. Python 프레임워크인 Flask는 데이터 분석이나 머신 러닝과 관련된 애플리케이션에 적합하도록 Python의 과학적 라이브러리와 도구와 잘 통합됩니다.\n- 커뮤니티 지원 및 자원: 각 프레임워크의 커뮤니티 지원 및 자원을 살펴보세요. Node.js와 Flask는 활발한 커뮤니티와 포괄적인 문서, 자습서 및 온라인 자원을 보유하고 있습니다. 그러나 Node.js는 보급이 더 잘 되어 있기 때문에 더 많은 사용자 지원 및 제3자 패키지가 제공될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 기술적인 결정과 마찬가지로, Node.js(Express)와 Flask 사이의 선택은 특정 프로젝트 요구 사항, 성능 요구사항, 확장성 기대치, 팀 전문성, 그리고 필요한 도구와 라이브러리의 생태계에 따라 다릅니다. 이러한 요소를 신중하게 평가하고 프로젝트의 목표와 제한 사항과 가장 잘 부합하는 것을 기반으로 알찬 결정을 내리는 것이 중요합니다.","ogImage":{"url":"/assets/img/2024-06-23-PythonFlaskvsNodejsExpress_0.png"},"coverImage":"/assets/img/2024-06-23-PythonFlaskvsNodejsExpress_0.png","tag":["Tech"],"readingTime":6},{"title":"이미지에서 표를 JSON으로 추출하는 GPT-4 사용 방법","description":"","date":"2024-06-23 13:17","slug":"2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4_0.png\" /\u003e\n\nOpenAI는 모든 인류에 이익을 제공하는 인공 일반 지능(AGI)을 보장하기 위해 헌신하는 선구적인 인공 지능 연구 기관입니다. 2015년 12월 일론 머스크, 샘 알트만, 그리고 다른 유명한 기술 리더들에 의해 설립된 OpenAI는 안전하고 높은 능력을 가진 AI 시스템을 만드는 것을 목표로 합니다.\n\nGPT(생성 사전 학습 트랜스포머)는 OpenAI가 개발한 일련의 언어 모델로, 인간과 유사한 텍스트를 이해하고 생성하는 데 사용됩니다. GPT-1부터 시작해 각 버전은 규모, 정확도, 성능 면에서 점진적으로 개선되었습니다. GPT-2는 더 긴 단락을 통해 일관된 및 맥락에 맞는 텍스트를 생성할 수 있는 능력을 보여주었으며, GPT-3는 1750억 개의 매개변수로 이를 크게 확장하여 극소량의 훈련으로 여러 언어 작업을 수행할 수 있는 능력을 가졌습니다.\n\n최신 버전인 GPT-4는 더 높은 정확도, 일관성, 다재다능성을 가진 이러한 능력을 더욱 향상시킵니다. 이는 콘텐츠 생성부터 고객 서비스, 복잡한 문제 해결까지 다양한 응용 분야에서 뛰어난 성과를 내며, AI 기술의 주요 발전을 대표합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 실제 시나리오\n\n우리의 목표는 이미지에서 테이블 데이터를 읽어와 Node.js를 사용하여 JSON으로 변환하는 것입니다.\n\n입력:\n\n![이미지](/assets/img/2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이상적인 결과는\n\n```js\n message: {\n      role: 'assistant',\n      content: \"이미지에서 인간이 읽을 수 있는 JSON 형식으로 상세 정보를 보여드립니다:\\n\" +\n        '\\n' +\n        'json\\n' +\n        '{\\n' +\n        '  \"transactions\": [\\n' +\n        '    {\\n' +\n        '      \"date\": \"01-04-2023\",\\n' +\n        '      \"particulars\": \"B/F\",\\n' +\n        '      \"cheque_no\": \"\",\\n' +\n        '      \"withdrawals\": 0.00,\\n' +\n        '      \"deposits\": 0.00,\\n' +\n        '      \"autosweep\": 0.00,\\n' +\n        '      \"reverse_sweep\": 0.00,\\n' +\n        '      \"balance\": \"35,024.54 잔액\"\\n' +\n        '    },\\n' +\n        ...\n        '    {\\n' +\n        '      \"date\": \"29-04-2023\",\\n' +\n        '      \"particulars\": \"UPI/311976583935/Net Bank/8460615089@ybI/Karur Vysya\",\\n' +\n        '      \"cheque_no\": \"\",\\n' +\n        '      \"withdrawals\": 0.00,\\n' +\n        '      \"deposits\": 5,000.00,\\n' +\n        '      \"autosweep\": 0.00,\\n' +\n        '      \"reverse_sweep\": 0.00,\\n' +\n        '      \"balance\": \"21,104.54 잔액\"\\n' +\n        '    }\\n' +\n        '  ],\\n' +\n        '  \"totals\": {\\n' +\n        '    \"withdrawals\": 27600.00,\\n' +\n        '    \"deposits\": 13680.00,\\n' +\n        '    \"autosweep\": 0.00,\\n' +\n        '    \"reverse_sweep\": 0.00,\\n' +\n        '    \"balance\": \"21,104.54 잔액\"\\n' +\n        '  }\\n' +\n        '}\\n' +\n        ''\n    },\n```\n\n단계별로 진행해 봅시다:\n\n단계 1: 시스템에 Node.js를 설치하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nStep 2: 새 디렉토리를 만들고 프로젝트를 설정하십시오.\n\n```js\nmkdir image-analysis\ncd image-analysis\nnpm init -y\nnpm install openai\n```\n\nStep 3: 새 파일 index.js를 만드세요.\n\n```js\nconst fs = require(\"fs\");\nconst OpenAI = require(\"openai\");\n//더 나은 보안을 위해 API 키는 .env 파일에 보관하십시오.\nconst OPENAI_API_KEY = \"your-api-key\";\nconst openai = new OpenAI({\n  apiKey: OPENAI_API_KEY,\n});\n\n// 이미지를 base64 문자열로 읽는 함수\nfunction encodeImage(imagePath) {\n  const imageData = fs.readFileSync(imagePath);\n  return imageData.toString('base64');\n}\n\nasync function main() {\n  const imagePath = \"path-of-your-image\";\n  const base64Image = encodeImage(imagePath);\n\n  const response = await openai.chat.completions.create({\n    model: \"gpt-4o\", \n    messages: [\n      {\n        role: \"system\",\n        content: \"이미지의 각 행과 열의 자세한 정보를 인간이 읽기 쉬운 형식의 멋진 JSON 형식으로 공유해 주세요.\",\n      },\n      {\n        role: \"user\",\n        content: [\n          { type: \"text\", text: \"이 이미지를 분석해 주세요:\" },\n          { type: \"image_url\", image_url: { url: `data:image/png;base64,${base64Image}` } },\n        ],\n      },\n    ],\n  });\n\n  console.log(response.choices);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4단계: 스크립트 실행하기\n\n```js\nnode index.js\n```\n\n출력:\n\n\u003cimg src=\"/assets/img/2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최종 솔루션에 도달하기 전 직면한 문제들:\n\n문제 1 - openai.createImage이(가) 함수가 아닙니다\n이 문제는 GPT-4에서 createImage 메서드가 사용되지 않기 때문에 발생합니다. OpenAI API에서는 더 이상 이미지를 처리하거나 생성하기 위해 이 메서드를 지원하지 않습니다. 대신, createCompletion 또는 createChatCompletion과 같은 다른 메서드를 사용하여 GPT-4 모델과 상호 작용할 수 있습니다. 이러한 메서드를 사용하면 이미지 데이터를 base64 문자열로 인코딩하여 텍스트 프롬프트 내에서 전달할 수 있습니다.\n\n```js\nconst response = await openai.createImage({\n^\n\nTypeError: openai.createImage is not a function\n```\n\n문제 2: openai 버전 4 변환.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오픈AI의 버전 4 변환 문제와 이전 버전 방법이 작동하지 않는 문제는 버전 간의 기반이 되는 아키텍처 및 API 기능에 중요한 변화가 있기 때문에 발생합니다. 이러한 변화로 인해 호환성 문제가 발생할 수 있으며, 이전 버전과 작동했던 기존 방법 및 통합이 버전 4에서 작동하지 않을 수 있습니다. 결과적으로 개발자들은 기존 방법을 사용하려고 할 때 오류나 예상치 못한 동작을 만날 수 있으며, 이에 대응하기 위해 코드를 업데이트하고 새 버전의 사양 및 모범 사례에 적응해야 할 수도 있습니다.\n\n```js\nconst { Configuration, OpenAIApi } = require(\"openai\");\n\n// const readline = require(\"readline\");\n\nconst configuration = new Configuration({\napiKey: \"API_KEY\",\n});\n\nTypeError: Configuration is not a constructor\nat Object. (D:\\nodeJS-chatBot\\index.cjs:5:23)\nat Module._compile (node:internal/modules/cjs/loader:1226:14)\nat Module._extensions…js (node:internal/modules/cjs/loader:1280:10)\nat Module.load (node:internal/modules/cjs/loader:1089:32)\nat Module._load (node:internal/modules/cjs/loader:930:12)\nat Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\nat node:internal/main/run_main_module:23:47\n```\n\n이 문제에 대한 해결책을 오픈AI 커뮤니티에서 찾았습니다\nhttps://chatgpt.com/share/b175130a-0d77-465e-8187-59b92590df8b\n\n문제점 3- gpt-4-vision-preview 모델이 더 이상 사용되지 않습니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지 추출 표](/assets/img/2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4_3.png)\n\n문제 4 - GPT-4로 이미지를 직접 업로드할 수 없어 GPT-3.5-turbo로 전환해야 하는 이유는, GPT-4가 이미지 데이터 입력을 처리하는 현재 능력 부족 때문입니다. 이 제한으로 인해 GPT-4를 통해 포괄적인 데이터 처리에 의존하는 개발자는 직접 이미지 업로드가 필요한 작업에는 모델을 전환해야 합니다. 이러한 전환은 작업 흐름을 복잡하게 만들고 개발 복잡성을 증가시키며 두 모델 간 데이터 처리 및 응답 생성에 불일치 가능성을 가져올 수 있습니다. 이러한 중단은 지연을 유발하고 원활한 사용자 경험을 유지하는 데 노력이 더 필요할 수 있습니다.\n\n```js\nreturn new BadRequestError(status, error, message, headers); ^ BadRequestError: 400 'image'가 잘못된 값입니다. 지원되는 값은 'text', 'image_url', 'audio_url'입니다.\nconst fs = require(\"fs\"); const OpenAI = require(\"openai\");\nconst OPENAI_API_KEY = \"\"; const openai = new OpenAI({ apiKey: OPENAI_API_KEY, });\nasync function main() { const imageData = fs.readFileSync(\"/home/akash/Downloads/test.png\");\nconst response = await openai.chat.completions.create({ model: \"gpt-4o\", instructions: \"이미지의 각 행과 열에 대한 자세한 정보를 아름답게 JSON 형식으로 공유해주세요.\", messages: [ { role: \"user\", content: [ { type: \"text\", text: \"이 이미지를 분석해주세요:\" }, { type: \"image\", image: imageData }, ], }, ], });\nconsole.log(response.data.result); }\nmain();\n경로 대신 이미지 URL을 제공하십시오: https://www.perfectxl.com/wp-content/uploads/2020/07/pivot-table-excel-source-data.png.webp\n```\n\n문제 5: 이미지에서 JSON으로 변환하기 위해 GPT-3.5-turbo를 사용하는 것은 여러 문제를 발생시킬 수 있습니다. 이미지 데이터 처리에 대한 이 모델의 본래 한계로 인해 변환 과정에서 정확성 문제가 발생할 수 있어 JSON 출력물이 불완전하거나 잘못될 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5 문제 1 해결책\n\n**L’Oreal Paris❌**\n\n**gpt-4o✅**\n\nGPT-4은 로컬 이미지를 효율적으로 Base64 인코딩으로 변환한 다음 데이터를 구문 분석하여 이미지를 JSON으로 변환하는 도구입니다. Base64 인코딩을 사용함으로써 GPT-4은 이미지 데이터가 텍스트 친화적 형식으로 정확하게 표현되어 후속 처리 단계가 간단해지도록 보장합니다. 이 방법을 통해 다른 모델 간 전환을 줄이고 개발 워크플로우를 최적화하여 일관성을 향상시킵니다. 또한 GPT-4의 강건성은 변환 프로세스의 신뢰성과 정확성을 향상시켜 보다 정확한 JSON 출력물을 제공합니다. 이 방식은 코드 유지보수를 간편화할 뿐만 아니라 응용 프로그램 내에서 이미지 데이터를 처리하는 효율성과 효과성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGitHub에서 예제 프로젝트를 찾을 수 있어요.\n\n제 글을 읽어 주셔서 감사합니다. 추가로 더 얘기 나 질문이 있으시면 언제든지 연락해 주세요!","ogImage":{"url":"/assets/img/2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4_0.png"},"coverImage":"/assets/img/2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4_0.png","tag":["Tech"],"readingTime":8},{"title":"Nodejs에서 SSO Single Sign-On 이해하기 구현 방법과 사례 설명","description":"","date":"2024-06-23 13:16","slug":"2024-06-23-UnderstandingSSOSingleSignOninNodejs","content":"\n\n싱글 사인온(SSO)은 현대 웹 애플리케이션에서 핵심 구성 요소로 사용되며 사용자 인증을 간소화하고 보안을 향상시킵니다. 이 블로그 포스트에서는 OAuth 2.0 및 OpenID Connect와 같은 인기있는 인증 프로토콜을 활용하여 Node.js 애플리케이션에 SSO를 구현하는 방법을 살펴보겠습니다.\n\n![UnderstandingSSOSingleSignOninNodejs](/assets/img/2024-06-23-UnderstandingSSOSingleSignOninNodejs_0.png)\n\n## 싱글 사인온(SSO)이란?\n\n싱글 사인온은 사용자가 한 번 인증하면 각각의 애플리케이션이나 서비스에 다시 로그인할 필요 없이 여러 애플리케이션 또는 서비스에 접근할 수 있는 기능을 말합니다. 이는 사용자 경험을 향상시키는 데에 그치지 않고 조직이 인증과 권한 부여를 중앙 집중화하여 관리를 간소화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSSO가 어떻게 동작하는지 단계별로 이해해 봅시다:\n\n- 사용자가 보호된 리소스에 액세스하고 서비스 제공자(SP)에 의해 신원 공급자(IdP)로 리디렉션됩니다.\n- 사용자는 자격 증명을 사용하여 IdP에서 인증합니다.\n- IdP는 사용자의 신원을 확인하는 보안 토큰 또는 주장을 발급합니다.\n- 사용자는 토큰을 가지고 SP로 돌아갑니다.\n- SP는 토큰의 진위 및 무결성을 확인합니다.\n- 유효한 경우, 리소스에 대한 액세스가 허용됩니다.\n- 선택 사항: SP 도메인 내에서 사용자를 위한 세션이 설정됩니다.\n- 신속한 인증을 통해 사용자는 자격 증명을 다시 입력하지 않고 여러 리소스에 액세스할 수 있습니다.\n- 동시 로그아웃을 위해 모든 서비스에서 로그아웃하는 단일 로그아웃이 제공될 수 있습니다.\n- SSO는 사용자 경험을 향상시키고, 마찰을 줄이며, 응용 프로그램 간에 보안을 유지합니다.\n\n![이미지](/assets/img/2024-06-23-UnderstandingSSOSingleSignOninNodejs_1.png)\n\n# SSO 전략이란?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSingle Sign-On (SSO) 전략은 적절한 인증 프로토콜 및 신원 제공자(IdP) 선택, SSO 기능을 애플리케이션에 통합, 사용자 교육 및 훈련, 강력한 보안 조치 구현, 지속적인 모니터링 및 유지보수, 확장 가능성 계획, 사용자 경험 최적화, 규정 준수 및 거버넌스 요구 사항 준수를 포함합니다. 요구 사항을 평가하고 적합한 프로토콜과 IdP를 선택하며 매끄럽게 통합하고 사용자를 교육하고 보안을 보장하며 성능을 모니터링하고 확장 가능성을 계획하고 사용자 경험을 최적화하고 규정 준수를 유지함으로써 기관은 통합된 SSO 전략을 수립할 수 있습니다. 이를 통해 인증 프로세스를 강화하고 보안을 강화하며 애플리케이션 생태계 전반에서 사용자 만족도를 향상시킬 수 있습니다.\n\n# 왜 SSO가 중요한가\n\nSSO를 구현하면 여러 가지 이점이 있습니다:\n\n- 향상된 사용자 경험: 사용자는 여러 세트의 자격 증명을 기억할 필요가 없어서 마찰을 줄이고 사용 용이성을 향상시킵니다.\n- 향상된 보안: 중앙화된 인증은 암호 관련 보안 위반 위험을 줄이고 사용자 액세스에 대한 더 나은 제어를 가능케 합니다.\n- 효율적인 관리: 조직은 정책을 중앙에서 강제하고 관리 오버헤드를 줄이는 방식으로 사용자 액세스를 더 효과적으로 관리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Node.js에서 SSO 구현하기\n\nNode.js 애플리케이션에서 SSO 구현 세부사항을 살펴보겠습니다.\n\n## 1. SSO 제공 업체 선택\n\nGoogle, Facebook과 같은 OAuth 2.0 제공 업체 또는 passport.js와 같은 라이브러리를 사용하여 사용자 정의 솔루션과 같은 여러 SSO 제공 업체가 있습니다. 이 예제에서는 SSO 제공자로 Google을 사용하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 인증 서버 설정하기\n\n먼저, Node.js와 Express를 사용하여 인증 서버를 설정해 봅시다:\n\n```js\nconst express = require('express');\nconst passport = require('passport');\nconst GoogleStrategy = require('passport-google-oauth20').Strategy;\n\nconst app = express();\n\npassport.use(new GoogleStrategy({\n    clientID: '********your-client-id********',\n    clientSecret: '********your-client-secret********',\n    callbackURL: '/auth/google/callback'\n  },\n  (accessToken, refreshToken, profile, done) =\u003e {\n    return done(null, profile);\n  }\n));\n\napp.get('/auth/google',\n  passport.authenticate('google', { scope: ['profile', 'email'] }));\n\napp.get('/auth/google/callback',\n  passport.authenticate('google', { failureRedirect: '/login' }),\n  (req, res) =\u003e {\n    res.redirect('/');\n  }\n);\n\napp.listen(3000, () =\u003e {\n  console.log('서버가 3000번 포트에서 실행 중입니다');\n});\n```\n\n위 코드에서:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Passport.js를 GoogleStrategy와 함께 구성합니다.\n- 인증을 시작하고 콜백을 처리하는 라우트를 정의합니다.\n\n## 3. SSO 공급자와 통합\n\n다음으로, Node.js 애플리케이션을 SSO 공급자의 적절한 자격 증명으로 구성해야 합니다. Google의 경우 Google 개발자 콘솔에서 프로젝트를 생성하여 클라이언트 ID와 클라이언트 비밀을 획득할 수 있습니다.\n\n## 4. 라우트 보안화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인증이 필요한 경로를 보호하기 위해 사용자가 인증되었는지 확인하는 미들웨어를 만들 수 있습니다:\n\n```js\nfunction ensureAuthenticated(req, res, next) {\n  if (req.isAuthenticated()) {\n    return next();\n  }\n  res.redirect('/login');\n}\n\napp.get('/profile', ensureAuthenticated, (req, res) =\u003e {\n  res.render('profile', { user: req.user });\n});\n```\n\n이 코드에서:\n\n- ensureAuthenticated 미들웨어는 Passport.js의 isAuthenticated 메서드를 사용하여 사용자가 인증되었는지 확인합니다.\n- 사용자가 인증되었으면 다음 미들웨어 또는 경로 핸들러로 진행하고, 그렇지 않으면 로그인 페이지로 리다이렉트됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 5. 사용자 세션 관리\n\n사용자 세션을 관리하기 위해 express-session 미들웨어를 Passport.js와 함께 사용할 수 있습니다:\n\n```js\nconst session = require('express-session');\n\napp.use(session({\n  secret: 'your-secret-key',\n  resave: false,\n  saveUninitialized: false\n}));\n\napp.use(passport.initialize());\napp.use(passport.session());\n\npassport.serializeUser((user, done) =\u003e {\n  done(null, user);\n});\n\npassport.deserializeUser((obj, done) =\u003e {\n  done(null, obj);\n});\n```\n\n# SSO에서의 안전성 (SSO는 안전한가요?)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSingle Sign-On (SSO)은 올바르게 구현될 때 안전한 인증 방법이 될 수 있어요. SSO의 안전은 선택된 인증 프로토콜과 Identity Provider (IdP)의 신뢰성을 포함한 여러 요소에 달려 있어요. OAuth 2.0 또는 OpenID Connect와 같은 인증 프로토콜은 보안 기능과 기존 시스템과의 호환성을 고려하여 신중하게 선택돼야 해요. 또한 사용자를 인증하고 보안 토큰을 발급하는 IdP는 신뢰할 수 있어야 하며, 암호화 및 다중 인증 (MFA)과 같은 견고한 보안 조치를 채택해야 해요. 토큰의 안전한 전송, 저장 및 유효성 검사는 무단 액세스를 방지하기 위해 핵심적인 역할을 해요. 적절한 세션 관리, 안전한 구현 관행 준수, 그리고 보안 위협 인식 및 회피에 대한 사용자 교육은 SSO의 보안 수준에 추가적으로 기여해요.\n\n하지만 SSO는 편의성과 효율성을 제공하는 반면, 조직이 대처해야 할 잠재적인 보안 위험을 도입하기도 해요. 세션 탈취나 피싱 공격과 같은 취약점은 SSO 시스템을 침해할 수 있어요. 지속적인 모니터링, 감사 및 사용자 인식 훈련은 보안 사고를 신속하게 감지하고 대응하는 데 필수적이에요. 올바른 보안 조치를 채택함으로써, 조직은 SSO의 혜택을 활용하면서 보안 위험을 효과적으로 완화할 수 있어요. 사용자 및 조직을 위해 시스템과 데이터의 기밀성, 무결성 및 가용성을 유지하는 것은 사용자와 조직 모두에게 안전한 SSO 환경을 보장하는 데 중요해요.\n\n# 결론\n\nNode.js 애플리케이션에 Single Sign-On을 구현하면 보안이 강화되며 사용자 인증이 간단해지고 전반적인 사용자 경험이 향상됩니다. Passport.js와 같은 인기있는 인증 프로토콜 및 라이브러리를 활용함으로써, 개발자들은 SSO 기능을 애플리케이션에 원활하게 통합할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 추가 자료\n\n- Passport.js 문서\n- Google OAuth 2.0 문서","ogImage":{"url":"/assets/img/2024-06-23-UnderstandingSSOSingleSignOninNodejs_0.png"},"coverImage":"/assets/img/2024-06-23-UnderstandingSSOSingleSignOninNodejs_0.png","tag":["Tech"],"readingTime":6},{"title":"사용하지 않을 때에도 웹 서비스 활동 유지하는 방법","description":"","date":"2024-06-23 13:15","slug":"2024-06-23-HackforRenderWebservicesspindownduetoinactivity","content":"\n\n백엔드 응용 프로그램을 취미로 배포할 때, Render는 간편성과 기능 세트로 인해 인기 있는 선택지입니다. 그러나 Render의 일반적인 문제 중 하나는 사용되지 않을 경우 무료 인스턴스가 중단될 수 있다는 것입니다. 이는 인스턴스를 다시 배포해야 할 때 최대 1분까지 응답이 지연되는 결과를 가져옵니다. Render에서 이러한 동작에 대해 명확히 설명되어 있습니다:\n\n![image](/assets/img/2024-06-23-HackforRenderWebservicesspindownduetoinactivity_0.png)\n\n**문제점**\n사용되지 않을 때 Render 인스턴스가 중단되어 서버가 일정 시간 후에 액세스될 때 지연이 발생합니다. 이는 응답 시간이 느려지면 사용자 경험에 영향을 미칠 수 있어 특히 거슬리는 문제일 수 있습니다.\n\n**해결책**\n사이트를 사용하지 않는 경우에도 인스턴스를 활성 상태로 유지하려면 app.js 또는 index.js 파일에 자체 참조 리로더를 추가할 수 있습니다. 이를 통해 정기적으로 서버에 핑을 보내 인스턴스가 중단되지 않도록 할 수 있습니다.\n\n다음은 이 작업을 수행하는 간단한 코드 스니펫입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst url = `https://yourappname.onrender.com/`; // 사용 중인 Render URL로 변경\nconst interval = 30000; // 간격을 밀리초 단위로 지정 (30초)\n\nfunction reloadWebsite() {\n  axios.get(url)\n    .then(response =\u003e {\n      console.log(`새로고침 시간: ${new Date().toISOString()}: 상태 코드 ${response.status}`);\n    })\n    .catch(error =\u003e {\n      console.error(`새로 고침 에러 시간: ${new Date().toISOString()}:`, error.message);\n    });\n}\n\n\nsetInterval(reloadWebsite, interval);\r\n```\n\n작동 방식\n\n- 자체 참조 새로 고침: 이 코드 스니펫은 서버에 매 30초마다 핑을 보내는 간격을 설정합니다.\n- 유지 및 활성 상태 유지: 서버에 지속적으로 핑을 보내면 활성 상태를 유지하고 중단되지 않도록 합니다.\n- 로그: 주기적인 확인을 볼 수 있고 서버가 활성 상태인지 확인할 수 있는 로그를 모니터링할 수 있습니다.\n\n구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 코드 추가: 위 코드를 app.js 또는 index.js 파일에 추가합니다.\n- 서버 시작: 앱을 Render에 배포하세요.\n- 모니터링: Render 대시보드의 로그를 확인하여 서버가 정기적으로 핑되는지 확인하세요.\n\n장점\n\n- 다운타임 없음: 서버가 활성 상태로 유지되어 빠른 응답을 제공합니다.\n- 간편한 솔루션: 복잡한 설정 없이 쉽게 구현할 수 있습니다.\n- 확장성: 소규모에서 중규모의 취미 프로젝트에 잘 작동합니다.\n\n다중 백엔드 관리\n다중 백엔드가 있는 프로젝트의 경우, 리로더를 단일 백엔드로 통합할 수 있습니다. 이 접근 방식은 각 백엔드가 자체 리로더를 필요로하지 않고 모든 인스턴스가 활성 상태로 유지되도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결론\n백엔드에 간단한 다시로더 스크립트를 추가함으로써, Render 인스턴스가 비활성화로 인해 종료되는 것을 방지할 수 있습니다. 이를 통해 서버가 반응성을 유지하여 취미 프로젝트에 더 나은 사용자 경험을 제공할 수 있습니다. 이 해결책은 소규모부터 중규모 프로젝트에 효과적이며 서버의 활동을 지속적으로 유지하는 데 도움이 됩니다.\n\n참고:\n\n- Github\n\n도움이 되셨기를 바랍니다! 즐거운 배포되길 바랍니다.","ogImage":{"url":"/assets/img/2024-06-23-HackforRenderWebservicesspindownduetoinactivity_0.png"},"coverImage":"/assets/img/2024-06-23-HackforRenderWebservicesspindownduetoinactivity_0.png","tag":["Tech"],"readingTime":2},{"title":"React Native CICD GitHub Actions와 App Center 사용하는 방법","description":"","date":"2024-06-23 13:14","slug":"2024-06-23-ReactNativeCICDGitHubActionsAppCenter","content":"\n\nReact Native 프로젝트에 대한 Continuous Integration 및 Continuous Deployment (CI/CD) 설정은 빌드, 테스트 및 배포 프로세스 자동화를 포함합니다. 이렇게 React Native 프로젝트를 CI/CD하려면 인기 있는 도구인 CI용 GitHub Actions 및 CD용 App Center를 사용하는 기본 예제가 있습니다:\n\n![React Native CI/CD](/assets/img/2024-06-23-ReactNativeCICDGitHubActionsAppCenter_0.png)\n\n1. GitHub 저장소 설정:\n- 이미 하지 않았다면 React Native 프로젝트용 GitHub 저장소를 만듭니다.\n- React Native 프로젝트 코드를 이 저장소에 푸시합니다.\n\n2. CI용 GitHub Workflow 만들기:\n- 저장소에 `.github/workflows/ci.yml` 파일을 만듭니다.\n- GitHub Actions를 사용하여 CI 워크플로우를 정의하기 위해 이 파일을 구성합니다. 다음은 기본 예제입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\n이름: CI\n\n활성화:\n  푸시:\n    브랜치: [main]\n\n작업:\n  빌드:\n    실행: ubuntu-latest\n\n    단계:\n      - 이름: 코드 체크아웃\n        사용: actions/checkout@v2\n\n      - 이름: Node.js 설정\n        사용: actions/setup-node@v1\n        with:\n          node-version: '14.x'\n\n      - 이름: 종속성 설치\n        실행: npm install\n\n      - 이름: 빌드\n        실행: npm run build\n\n      - 이름: 테스트\n        실행: npm test\n```\n\n3. CD를 위해 앱 센터 설정:\n- 이미 Microsoft 앱 센터에 계정이 없다면 계정을 설정하세요.\n- React Native 프로젝트에 대응하는 앱 센터에서 앱을 생성하세요.\n\n4. App Center와 CD 통합:\n- 개발 환경에서 App Center CLI를 설치하세요.\n- CLI를 App Center와 인증하세요.\n- React Native 프로젝트에 App Center를 통합하세요:\n\n```bash\nappcenter login\nappcenter apps create -d \"Your React Native App\" -o \"React Native\" -p React-Native\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n— App Center에서 제공하는 지침에 따라 React Native 프로젝트에 SDK를 통합하여 충돌 보고, 분석 및 배포 기능을 활성화하세요.\n\n5. CD 파이프라인 구성:\n— 자동 배포를 위해 App Center에 릴리스 파이프라인을 생성하세요.\n— 새 빌드 아티팩트가 생성된 경우(예: CI 성공 후) 파이프라인을 트리거하도록 구성하세요.\n\n6. CD 트리거를 위한 GitHub Workflow 업데이트:\n— 성공한 빌드 후 App Center CD를 트리거하도록 GitHub Actions workflow를 수정하세요:\n\n```js\n...\njobs:\n  build:\n    ...\n    steps:\n      ...\n\n  deploy:\n    needs: build\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Trigger App Center Release\n        run: appcenter codepush release-react -a \u003cownerName\u003e/\u003cappName\u003e -d \u003cdeploymentName\u003e\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n7. 변경 내용 커밋 및 푸시하기:\n- `.github/workflows/ci.yml` 및 다른 관련 파일에 변경 내용을 커밋합니다.\n- 변경 사항을 GitHub 저장소에 푸시합니다.\n\n위 단계를 통해 React Native 프로젝트를 위한 기본 CI/CD 파이프라인을 설정했습니다. 저장소에 변경 사항을 푸시할 때마다 GitHub Actions가 자동으로 빌드하고 테스트를 실행합니다. 성공적으로 완료되면, App Center가 앱을 지정된 배포 환경으로 배포합니다. 해당 설정을 프로젝트 요구사항과 선호에 맞게 조정하고 확장해보세요.","ogImage":{"url":"/assets/img/2024-06-23-ReactNativeCICDGitHubActionsAppCenter_0.png"},"coverImage":"/assets/img/2024-06-23-ReactNativeCICDGitHubActionsAppCenter_0.png","tag":["Tech"],"readingTime":3},{"title":"자바스크립트를 이제 그만 사용해야 하는 이유 5가지","description":"","date":"2024-06-23 13:14","slug":"2024-06-23-StopusingJavaScript","content":"\n\n![Table](/assets/img/2024-06-23-StopusingJavaScript_0.png)\n\n웹 개발을 시작한 이후로 JavaScript를 열광하는 팬이었어요. 하지만 JavaScript의 결함을 깨닫게 되었던 것은 글쓰기와 잠재적 책을 집필하기 시작한 이후였어요.\n\n마이크로소프트의 TypeScript가 그 결함을 해결하려고 노력했지만, 각자의 단점이 있었죠. 양 언어의 일반적인 차이점을 표로 보여드리고, 다음 프로젝트에 어떤 언어를 선택해야 하는지에 대해 깊이 알아보겠어요.\n\n# 일반적인 차이점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기초부터 시작해보죠. 많이 읽기 귀찮은 사람들을 위한 표도 준비했어요. 이 중 일부는 글의 후반부에서 해당 내용과 같은 설명을 이해해야 합니다.\n\n![JavaScript Table](/assets/img/2024-06-23-StopusingJavaScript_1.png)\n\n# JavaScript\n\n인터넷이 1990년대에 형성되기 시작할 때 JavaScript가 탄생했어요. 이는 Java의 성공에서 영감을 얻은 후 1995년에 나왔어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n넷스케이프, 모직라의 전신,는 상호 작용형 웹 애플리케이션을 위해 JavaScript를 만들었습니다. 브렌단 아이크는 많은 결함이 있는 JavaScript를 몇 일 안에 완성했습니다.\n\n![이미지](/assets/img/2024-06-23-StopusingJavaScript_2.png)\n\n지금으로부터 빠르게 전진하면 TypeScript가 나옵니다. 그 결함들? 예, 누군가 그것들을 고쳐야 한다고 판단했습니다. 하지만 JavaScript가 도움이 되는 경우도 있습니다.\n\n## TypeScript보다 좋은 이유\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- TypeScript은 작은 프로젝트에 적합하지 않습니다. 이때 JavaScript가 빛을 발합니다. 이는 Microsoft 개발자들이 그런 식으로 설계했기 때문입니다. 사이드 프로젝트에서는 정적 유형, 인터페이스 등이 필요하지 않습니다.\n- TypeScript 기반 프로젝트에는 시간 비용이 들어간다는 것이 JavaScript보다 더 나은 이유입니다. TS는 브라우저가 이해할 수 있게 TS 코드를 JS 코드로 변환하는 데 꽤 많은 시간이 걸립니다. 이러한 추가 비용은 작은 프로젝트에 값어치가 없습니다.\n- 작은 코드 스니펫에서는 JavaScript가 네이티브 브라우저에서 디버깅하기 쉽습니다.\n- 프로토타입에는 JavaScript가 더 나은데, TS나 기타 추가 비용에 드는 시간을 감당할 수 없는 작은 프로젝트와 같습니다.\n- 현재 JavaScript를 사용하고 있는 대규모 프로젝트에 대해서는 계속하여 JavaScript를 사용할 수 있습니다. 코드를 TypeScript로 리팩토링하는 비용이 그렇게 가치 있는 것은 아닐 수도 있습니다.\n\n이제 JavaScript가 머리아픈 일의 원인이 되는 경우를 설명해보겠습니다.\n\n# TypeScript\n\n만약 여러분이 인터넷에서 JavaScript를 없애는 해결책이 없는 이유에 궁금해 한다면, 그 이유는 JavaScript가 모든 웹 브라우저의 핵심이기 때문입니다. 웹 애플리케이션을 구축하는 데 필요한 세 가지 기술(HTML, CSS 및 JS) 중 하나입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-StopusingJavaScript_3.png\" /\u003e\n\n그것을 대체하는 대신, 개발자들은 그것을 개선하는 데 집중했습니다. 그 결과 TypeScript가 탄생했습니다. JavaScript의 창시자 인 Brendan Eich도 TypeScript를 JavaScript에 유익한 부가 기능으로 간주합니다.\n\n## JavaScript보다 나은 이유\n\n- JavaScript는 호환성 문제를 가지고 있습니다. 여러 브라우저에서 ECMA 표준의 구현이 다르며, JS 코드를 파싱하기 위해 여러 해석기가 사용됩니다. 일부 브라우저는 여전히 이전 버전의 ECMAScript를 사용하고 있습니다. TypeScript를 사용하면 새로운 JavaScript 기능을 사용하여 이전 브라우저와 NodeJS 버전과 함께 사용할 수 있습니다.\n- TypeScript는 JavaScript의 상위 집합입니다. TypeScript의 기능을 사용하지 않더라도 기술적으로 JavaScript 코드는 TypeScript 코드가 되고 그 반대도 성립합니다. TypeScript에는 브라우저를 위해 TS 코드를 JS로 변환해주는 컴파일러가 있습니다.\n- JavaScript는 동적으로 유형이 지정되지 않아 예상치 못한 오류가 발생할 수 있습니다. 이는 데이터의 유형을 정의할 필요가 없다는 뜻입니다. TypeScript는 JavaScript에 정적 유형을 추가하여 변수, 함수 매개변수 및 반환 값의 데이터 유형을 지정할 수 있도록 하여 개발자가 개발 과정 초기에 유형 관련 오류를 미연에 방지할 수 있습니다.\n- TypeScript를 사용하면 코드를 ES3 또는 그 이하의 이전 JavaScript 버전으로 변환할 수 있습니다. WebPack과 함께 사용하면 레거시 브라우저를 지원하는 데 도움이 됩니다.\n- TypeScript는 인터페이스, 상속 기능, 캡슐화 능력 및 클래스를 제공합니다. 객체 지향 배경을 가진 개발자들에게 JavaScript로 전환하기가 더 쉽습니다. 새로운 환경을 배울 필요가 없고 기존의 습관을 유지할 수 있습니다.\n- TypeScript를 사용하면 함수의 선택적 매개변수와 해당 선택적 또는 필수 매개변수의 기본 값을 설정할 수 있습니다.\n- TypeScript에는 데코레이터가 있습니다. 클래스, 메서드 및 속성에 메타데이터를 첨부할 수 있습니다. 이는 의존성 주입 및 관점 지향 프로그래밍에 도움이 됩니다.\n- TypeScript에는 제네릭이 있습니다. 구성 요소가 하나뿐만 아니라 여러 데이터 유형을 지원할 수 있습니다. Java와 같은 언어는 이미 제네릭을 지원합니다. 이를 통해 개발자는 기존 및 미래에 사용할 수 있는 구성 요소를 작성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypeScript은 유연성과 확장성을 제공합니다. 이 차별화로 보아 미래를 향해 나아가면서도 역호환성을 생각하고 있음을 알 수 있습니다. JavaScript가 실패하는 부분에서 TypeScript가 잘 해내고 있는 것이죠.\n\n의견을 나누고 싶다면 댓글을 달아주세요. 다른 사항을 변경해야 한다면 알려주세요. 이메일 director@afankhan.com (Afan Khan LLC) 으로 언제든지 연락할 수 있습니다. 그렇지 않으면 트위터(@whyafan)를 통해서 가장 쉽게 연락할 수 있습니다.\n\n# 쉬운 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작가를 박수로 응원하고 팔로우하기 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-23-StopusingJavaScript_0.png"},"coverImage":"/assets/img/2024-06-23-StopusingJavaScript_0.png","tag":["Tech"],"readingTime":4},{"title":"협업 편집 기능 추가 우리 뉴스룸 CMS 구축 과정 공개","description":"","date":"2024-06-23 13:12","slug":"2024-06-23-WeBuiltCollaborativeEditingforOurNewsroomsCMSHeresHow","content":"\n\nSophia Ciocca와 Jeff Sisson\n\n뉴욕 타임스 기사를 게시하려면 많은 사람이 필요하고 때로는 상황이 복잡해질 수 있습니다. 여러 기자와 편집자가 한 편의 이야기를 쓰고 개정하고 발표하는 데 참여할 수 있으며, 이 협업은 종종 비선형적이며, 서로의 발을 짓게할 수 있습니다.\n\n특히 많은 유형의 협력자(사진 편집자, 복사 편집자, 기자, 프로듀서)가 동시에 문서를 편집해야 하는 긴급 상황에서 이는 특히 사실입니다. 뉴욕 타임스의 차세대 기사 편집 인터페이스인 Oak을 처음 개발할 때 한 번에 한 사람만 문서를 작업할 수 있었습니다. Oak은 \"필드 잠금\"을 사용하여 서로 다른 사람들이 별도의 메타데이터 필드를 편집하도록 허용하는 것과 같은 일부 동시 협업 기능을 용이하게 했지만, 한 번에 한 사람만 기사 내용을 편집할 수 있었습니다.\n\n협업 편집 기능이 필요했던 Oak에서 협력자가 동시에 자연스럽게 문서에서 작업할 수있는 더 완벽한 기사 편집기가 필요했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 협업 편집은 해결하기 어려운 문제입니다. 실시간 업데이트를 통합하는 방법, 충돌하는 편집에 대처하는 방법, 불안정한 와이파이로 인한 오류를 처리하는 방법 등 많은 새로운 수수께끼를 제시합니다. Google Docs와 같은 제품은 대규모로 이러한 문제를 해결하기 위해 막대한 팀과 자원을 투입하고 있습니다. 저희 팀은 The Times의 편집 작업 흐름에 적합한 방식으로 이러한 수수께끼를 해결할 시간이 몇 달밖에 없었습니다. 다행히도 이러한 종류의 기술적 도전에 대한 지원이 Oak의 기술 기반으로 ProseMirror를 선택한 초기 이유 중 하나였습니다.\n\n# 모든 사람이 단계들이 필요합니다\n\nOak 글이 협업적이 되기 위해서는 글에 접근 권한이 있는 모든 사람이 실시간으로 가장 최신 버전을 가지고 있어야 합니다. 이는 편집이 이루어질 때마다, 해당 편집이 협업자의 컴퓨터에서 보이도록 해야 한다는 것을 의미합니다. 개별 편집을 인터넷으로 전송할 수 있는 형태로 변환하는 것은 ProseMirror가 낮은 수준에서 수행하는 작업입니다. 각각의 편집을 \"단계\"라고 부릅니다. 사용자가 글자를 입력할 때, 그것이 단계입니다. 새 줄로 이동하기 위해 엔터 키를 누르는 것도 단계입니다. 문서를 조작하는 모든 것 - 이미지 추가, 제목 편집, 단락 삭제 - 모두 단계로 간주됩니다.\n\n정확히 어떻게 단계의 데이터가 표현되는 걸까요? 우리는 단계를 문서를 어떻게 변경하는지에 대한 지시사항으로 작동하는 JSON 객체로 나타냅니다. 문서의 두 번째 위치에 글자 \"H\"를 넣는 것이 어떻게 보이는지 여기에 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n  “단계ID”: 1,\n  “단계”: {\n    “단계유형”:”대체”,\n    ”출발지”: 2,\n    ”도착지”: 2,\n    ”슬라이스”: {\n      “내용”:[{\n        “종류”:”텍스트”,\n        ”텍스트”:”h”\n      }]\n    }\n  },\n  “클라이언트ID”: “1111–42783748297342”,\n  “타임스탬프”: “Sun Feb 10 2019 12:31:32 GMT-0500 (Eastern Standard Time)”\n}\n```\n\n사용자가 단어를 입력하거나 이미지를 변경하거나 코멘트를 추가할 때, 해당 동작의 단계는 사용자의 로컬 문서에 추가됩니다. 그러나 이러한 단계는 아직 다른 사람에게 전송되지 않았습니다. 다른 사람의 컴퓨터에서 이러한 단계가 표시되려면 이를 원격 서버, 즉 “권한 서버”로 보내야 하며 원격 서버에서 확인을 받아야 합니다.\n\n권한 서버는 클럽의 용병처럼 작동합니다. 사용자로부터 단계를 받으면 그 단계를 데이터베이스에 저장할지 여부를 결정해야 합니다. 사용자의 브라우저가 마지막으로 권한 서버와 통신한 후에 저장된 단계가 없다면, 권한 서버는 해당 단계를 저장합니다. 그렇지 않으면 사용자의 브라우저에 아직 보지 못한 단계를 가져오라고 알려줍니다.\n\n로컬 문서와 원격 권한 서버 간의 전형적인 대화는 다음과 같을 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n1. 로컬: \"안녕하세요, 한, 둘, 셋 단계를 가지고 있어요.\"\n2. 원격: \"좋아요, 한, 둘, 셋 단계를 저장했습니다.\"\n3. 로컬: \"다시 안녕하세요... 넷, 다섯, 여섯 단계를 가지고 있어요.\"\n4. 원격: \"아! 다른 사람이 넷과 다섯 단계를 삽입했어요. 가져와주세요.\"\n5. *로컬이 넷과 다섯 단계를 가져오고, 이전의 넷, 다섯, 여섯 단계를 새로운 것으로 바꿔 여섯, 일곱, 여덟 단계로 반영합니다.*\n6. 로컬: \"안녕하세요... 이제 여섯, 일곱, 여덟 단계를 가지고 있어요.\"\n7. 원격: \"멋져요, 여섯, 일곱, 여덟 단계를 저장했습니다.\"\n```\n\n선 네 번째 줄에서 로컬 문서가 네, 다섯, 여섯 단계를 전송하려 시도하지만, 원격 서버는 이미 해당 단계가 존재한다고 브라우저에 알립니다. 브라우저는 해당 단계를 가져와 다시 전송하려고 합니다. 여기에서 무슨 일이 벌어지나요?\n\n리베이스는 동일한 시기에 두 사용자가 단계를 삽입했을 때 발생하는 프로세스입니다. 코드가 어떻게 조정되는지를 결정해야 하는 중요한 부분 중 하나인 ProseMirror의 협업 편집 지원의 핵심인 Operational Transformation이라는 알고리즘이 관여합니다.\n\n# 단계가 있는 곳이 집이다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nProseMirror은 협업 편집 서버를 구현하기 위한 매우 훌륭한 구성 요소(그리고 완벽히 작동하는 데모)를 제공하지만, 데이터베이스에 단계를 저장하는 방법을 명시하지 않습니다. 우리는 우리의 특정 요구 사항에 맞는 솔루션을 설계하고 구현해야 했습니다. 저희는 프로토타이핑 단계에서 고려한 몇 가지 질문은 다음과 같습니다. 권한 있는 서버를 어떻게 확장하여 많은 수정을 허용할 수 있을까요? (기사 당 최대 25,000회) 협업 문서의 편집 기록을 어떻게 보존할 수 있을까요? 마지막으로, 최신 문서를 인쇄 생산 시스템에 전달하는 등, 우리 뉴스룸의 고유한 필요에 맞는 다양한 기능을 지원하는 방법은 무엇일까요?\n\n다양한 프로토타입을 스케치한 후, 우리는 실시간 데이터베이스 Firestore를 사용하여 단계를 저장하고 들어오는 단계를 거르는 데 이를 사용하기로 결정했습니다. Firestore는 데이터베이스 트랜잭션을 지원하므로 여러 사람으로부터 제출된 단계가 Firestore 라이브러리에 의해 여러 번 시도되어 한 사람의 삽입이 \"이기고\" 데이터베이스에 기록될 때까지 다시 시도됩니다. 이러한 방식으로 여러 사람의 단계를 정렬함으로써 Firestore를 권한 있는 서버로서 좋은 선택으로 만듭니다.\n\n데이터베이스로의 쓰기 작업이 성공하면 Firestore는 원격 사용자에게 새로운 단계가 데이터베이스에 추가되었음을 알리며, 이로 인해 앱이 새로 확인된 단계를 가져와서 문서의 복사본을 최신 상태로 가져오게 됩니다.\n\n# 여러 사람이 입력 중입니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n협업 문서를 최신 상태로 유지하는 것은 중요하지만, 문서를 지켜보고 있는 다른 사람이 누구인지 알아내는 것도 중요합니다. 문서에 있는 모든 사람이 협업자의 커서 위치를 볼 수 있거나, 협업자가 마우스로 특정 부분을 강조한 것을 볼 수 있기를 원했습니다. ProseMirror와 Firebase API (Firestore의 동생)를 활용하여 Oak에 추가한 기능은 문서에 누가 있고 그들이 커서를 둔 위치를 보여주는 것입니다.\n\n![image](/assets/img/2024-06-23-WeBuiltCollaborativeEditingforOurNewsroomsCMSHeresHow_0.png)\n\n사용자가 Oak 편집기 내에서 타이핑, 클릭 또는 끌기를 통해 선택을 변경할 때마다, ProseMirror는 브라우저 선택의 현재 상태의 변경을 관찰하고 해당 정보로 Selection 데이터 구조를 만듭니다. 이 데이터는 사용자의 커서가 텍스트에서 어디에 있는지에 대한 정보를 반영하며, 시작 위치(머리) 및 끝 위치(앵커)를 포함합니다.\n\n사용자가 문서에서 선택을 만들면, 해당 선택이 문서를 열어둔 모든 컴퓨터에 렌더링되고 그 옆에 사용자의 이름이 표시됩니다. 사용자가 브라우저에서 선택을 변경할 때, 해당 변경 사항이 문서에 반영되어야 하므로 업데이트된 선택 데이터(머리 + 앵커 위치)를 Firebase로 푸시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 선택 사항을 처리하기 위해 가끔은 미래를 예측해야 합니다. 선택 데이터와 문서 변경 사항이 별도의 서버로 전송되기 때문에 Oak 앱은 브라우저가 아직 수신하지 않은 문서 버전의 선택 변경을 수신할 수 있습니다. Oak 앱이 문서 편집에 대응하는 선택 변경을 받기 전에 문서 편집을 수신하면 해당 선택이 어떻게 변경될 지 시뮬레이션해야 합니다. 마찬가지로, 아직 도착하지 않은 편집에 관련된 선택 변경을 수신하면 앱은 해당 편집이 도착할 때까지 선택 변경을 렌더링하기 전까지 기다려야 합니다. 이를 위해 미래에서 선택 업데이트를 기다렸다가 적용하기 위해 Redux Saga를 사용합니다.\n\n우리는 선택 사항을 저장하기 위해 Firestore(단계 저장에 사용 중) 대신 Firebase를 선택했음을 언급할 가치가 있습니다. 왜냐하면 Firebase는 onDisconnect 후크를 사용할 수 있게 해줍니다. 이로써 사용자가 탭을 닫더라도 실행이 보장된 데이터베이스 수정을 수행할 수 있습니다. 이는 Oak 편집기를 떠나는 사용자의 커서가 그들을 따라 깔끔하게 정리되도록 도와줍니다.\n\n# 게시하거나 소멸하라\n\n모든 기사 편집물 또는 단계가 Firestore에 삽입되면 해당 기사를 열어둔 모든 브라우저 창이 최신 단계로 업데이트됩니다. 기사를 게시할 준비가 되면, 게시를 처리하는 백엔드 서비스는 최신 기사 데이터도 가져와 사이트와 앱이 기사를 렌더링하기 위해 사용자 끝단에 제공하는 게시 파이프라인으로 전송합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 협업 편집을 구현하기 전에는 이 흐름이 더 간단했습니다: 백엔드 서비스는 기사 내용과 메타데이터가 저장된 MySQL 데이터베이스로 직접 이동할 수 있었습니다. 그러나 협업 편집 기사의 경우에는 Firestore에서 기사 내용을 퍼블리싱 서비스로 이동시키는 앱 엔진 서비스(우리가 “협업 서비스”라고 명명했습니다)를 만들었습니다. 사용자가 게시 버튼을 클릭하면 브라우저가 이 협업 서비스에 요청을 보내고, 해당 서비스는 Firestore로부터 데이터를 퍼블리싱 파이프라인으로 복사합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-WeBuiltCollaborativeEditingforOurNewsroomsCMSHeresHow_1.png\" /\u003e\n\n협업 편집된 기사가 디지털로 게시된 후 인쇄를 위해 세부 조정이 필요할 수 있습니다. 기사가 인쇄 공장으로 보내기 전에 뉴스룸의 편집자들이 하이퍼링크와 삽입 콘텐츠를 제거하거나 기사를 줄여야 할 수 있습니다.\n\n이러한 인쇄 편집을 수행하는 인터페이스는 기존 MySQL 데이터베이스에 의존합니다. 협업 기사는 Firestore에 저장되어 이 인쇄 데이터베이스와 연결이 끊겨 있기 때문에, 기사의 협업 상태가 정기적 간격으로 주요 MySQL 데이터베이스로 복사되는 시스템을 개발했습니다. 이 시스템에는 Google Cloud Functions와 Google Cloud Tasks가 포함되어 있으며, 최소 한끗 차이로 콜라보레이티브 변경 사항을 신문에 인쇄될 것과 동일하게 미리 볼 수 있게 해줍니다. 이는 우리의 인쇄 편집자들에게 유용한 기능입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n공동으로 편집된 Oak 기사가 게시되고 인쇄되었을 때, 드디어 결승선에 오르게 되었습니다! 게시 후에 수정 사항이 있는 경우 일부 기사는 변경 사항을 추적하기 위해 Firestore에 저장되며, 그 단계는 디지털 게시를 마침으로 우리 기사와 해당 단계의 이야기는 끝납니다. 우리는 이제 뉴스룸 전체의 협력자들에게 대대적으로 향상된 사용자 경험을 제공하는 기존 뉴스 워크플로우와 매끈하게 작동하는 공동 편집자를 보유하고 있습니다.\n\n이것은 거대한 다수의 팀이 노력한 결과입니다. Oak 및 CMS 팀의 많은 멤버들이 지난 및 현재에 우리를 기고유로 편집이 가능한 상태로 이끌었습니다. 특히 Oak 팀 - Minerva Archer, Sophia Ciocca, Tom Holcolmb, Dmitriy Matveev, Shane Moore, Dylan Nelson, Thomas Rhiel, Alexandra Shaheen, Jeff Sisson 및 Matthew Stake -은 2016년 이후 이 문제에 대한 놀라운 작업을 해왔습니다.\n\n또한 PubPub의 Travis Rich에게 ProseMirror와 Firebase를 사용하는 데 대한 첫 인사이트를 제공해 준 것에 감사를 표합니다. 그리고 이 프로젝트에 유용한 조언을 제공해준 ProseMirror의 저자인 Marijn Haverbeke에게도 감사를 표합니다.\n\nSophia Ciocca는 뉴욕 타임즈 출판팀 소프트웨어 엔지니어로 Oak에서 일하고 있습니다. 그녀의 Medium을 팔로우하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제프 시슨은 뉴욕타임스의 퍼블리싱 팀에서 리드 소프트웨어 엔지니어로 일하며 Oak에 참여하고 있습니다. 트위터에서 그를 팔로우하거나 그의 개인 홈페이지를 방문해보세요.","ogImage":{"url":"/assets/img/2024-06-23-WeBuiltCollaborativeEditingforOurNewsroomsCMSHeresHow_0.png"},"coverImage":"/assets/img/2024-06-23-WeBuiltCollaborativeEditingforOurNewsroomsCMSHeresHow_0.png","tag":["Tech"],"readingTime":7},{"title":"JavaScript 프로미스 이해하기 BMW 이야기","description":"","date":"2024-06-23 13:11","slug":"2024-06-23-UnderstandingJavaScriptPromisesTheBMWStory","content":"\n\n![이미지](/assets/img/2024-06-23-UnderstandingJavaScriptPromisesTheBMWStory_0.png)\n\n자바스크립트에서 Promise는 기본 개념이지만 이해하기 어려울 수 있습니다. 이 글을 읽은 후에는 이 개념을 완전히 이해할 거에요. 친숙한 현실적인 비유를 사용해 설명해 보겠습니다.\n\n아버지가 새 BMW를 사주겠다고 약속한다고 상상해보세요. 이 약속은 보거나 만질 수 없지만, 여러분의 생각과 아버지의 생각 속에 존재합니다. 마찬가지로 자바스크립트에서 Promise는 비동기 작업의 결과를 나타내는 객체입니다.\n\n간단히 말해, 자바스크립트의 Promise는 아버지의 약속과 비슷합니다. 미래의 결과를 위한 자리 표시자인 것이죠. 하지만 우리의 머릿속에만 존재하는 게 아니라 컴퓨터 메모리에 있고 코드를 통해 조작할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에서 유사성을 살펴보겠습니다:\n\n약속하기: 아빠가 BMW를 약속해줄 때, 즉시 차를 주지 않는다. 마찬가지로, JavaScript 함수가 약속을 반환할 때도 즉시 결과를 제공하지 않습니다.\n\n대기 상태: BMW를 기다리는 동안 당신은 일상생활을 하며 다른 일을 합니다. 이것은 JavaScript 약속의 '대기 중' 상태와 유사합니다. 해당 작업이 아직 완료되지 않았지만 다른 작업은 여전히 동시에 실행될 수 있습니다. 이것이 비동기 프로그래밍이라고도 하며, 주 스레드를 블로킹하지 않고 작업이 수행되는 방식입니다.\n\n성공: 아빠가 결국 BMW를 사주면, 약속이 이행됩니다. JavaScript에서는 약속이 성공적으로 해결되어 예상한 결과를 제공하는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n거절: 아버지가 BMW을 사지 않으면 약속이 깨집니다. JavaScript 용어로 말하면 이 약속은 거부되어 작업이 실패했음을 나타냅니다.\n\n# Promise의 라이프사이클\n\n자바스크립트 Promise의 상태에 대해 좀 더 자세히 살펴보겠습니다:\n\n1. 대기 중: 이것은 초기 상태입니다. 이 Promise은 충족되지도 거절되지도 않았으며 결과를 기다리고 있습니다. 이는 아버지가 \"잠깐만 기다려, 좀 더 시간을 주세요\"라고 말할 때 상황과 대응됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 이행됨: 약속이 성공적으로 완료되었습니다. 우리의 비유에서는 BMW를 수령할 때입니다. JavaScript에서는 약속이 값으로 해결됩니다.\n\n3. 거부됨: 약속이 실패했습니다. 이는 BMW를 받지 못하는 것과 같습니다. JavaScript에서는 약속이 이유(에러)와 함께 거부됩니다.\n\n# JavaScript에서 약속(Promises) 생성 및 처리하기\n\n다음은 JavaScript에서 약속을 생성하고 처리하는 간단한 예제입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Promise 생성\nlet promise = new Promise((resolve, reject) =\u003e {\n  let isPromiseKept = true; // 약속을 지키는지를 시뮬레이션\n  if (isPromiseKept) {\n    resolve('BMW를 받았어요!');\n  } \n  else {\n    reject('약속을 어겼네요, BMW가 없어요.');\n  }\n });\n```\n\n```js\n// Promise 처리\npromise\n .then((message) =\u003e {\n   console.log(message); // 출력: BMW를 받았어요!\n })\n .catch((error) =\u003e {\n   console.log(error); // 출력: 약속을 어겼네요, BMW가 없어요.\n });\n```\n\n# 코드 설명하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet promise = new Promise((resolve, reject) =\u003e {....});\n```\n\n위 코드는 'Promise' 생성자를 사용하여 프로미스를 생성합니다. 생성자는 인수로 함수(콜백)를 취합니다. 이 콜백 함수는 resolve 및 reject라는 두 개의 매개변수를 사용합니다.\n\n프로미스 결과 시뮬레이션:\n\nlet isPromiseKept = true;: 이 변수는 프로미스가 유지될지 여부를 시뮬레이션합니다. 시연 목적을 위해 간단한 boolean 값입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPromise 해결 또는 거부:\n\n```js\nif (isPromiseKept) {\n    resolve('BMW를 받았습니다!');\n} else {\n    reject('약속이 깨졌습니다, BMW가 없어요.');\n}\n```\n\n위 조건은 isPromiseKept의 값을 확인합니다. 만약 true이면, 'BMW를 받았습니다!' 메시지와 함께 resolve 함수가 호출됩니다. 만약 false이면, '약속이 깨졌습니다, BMW가 없어요.' 메시지와 함께 reject 함수가 호출됩니다.\n\nPromise 결과 처리하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\npromise\n .then((message) =\u003e {\n   console.log(message); // Output: BMW received!\n })\n .catch((error) =\u003e {\n   console.log(error); // Output: Promise broken, no BMW.\n });\r\n```\r\n\r\n프로미스가 처리된 후 — 성공적으로 해결되거나 거부된 경우 — 프로미스 객체의 .then() 또는 .catch() 메서드를 사용하여 결과를 가져옵니다. 이러한 메서드는 콜백 함수를 매개변수로 사용합니다. 이러한 콜백은 resolve 또는 reject에서 반환된 데이터를받습니다. 프로미스가 해결되거나 거부되는 경우 결과를 처리하기 위해 .then() 또는 .catch() 중 하나가 실행됩니다.\r\n\r\n.then() 메서드는 해결된 상태를 처리하고 해결된 데이터(일반적으로 message로 지칭)를 콜백 함수로 전달합니다. 반대로 프로미스가 거부되면 .catch() 메서드가 거부 이유(일반적으로 error로 표시)를 처리합니다. .then()은 원칙적으로 해결된 상태와 거부된 결과를 모두 처리할 수 있지만 두 개의 매개변수(첫 번째 콜백은 해결된 상태, 두 번째는 거부된 상태)를 제공함으로써기 때문에 성공적인 결과에 대해 .then()을 사용하고 오류 처리에는 .catch()을 사용하는 것이 일반적으로 더 명확합니다.\r\n\r\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트의 Promise는 비동기 작업을 효과적으로 관리할 수 있는 강력한 도구입니다. 이를 통해 코드가 결과를 기다리는 동안 멈추지 않고 작업을 처리할 수 있습니다. 약속을 아빠가 BMW를 사주겠다고 하는 것처럼 생각하면, Promise가 가질 수 있는 다양한 상태인 보류 중(pending), 이행됨(fulfilled), 거부됨(rejected)을 더 잘 이해할 수 있습니다. 당신이 아빠가 약속을 이행할 때까지 기다리는 동안 다른 작업을 병행하는 것처럼, JavaScript는 Promise가 해결되거나 거부될 때까지 다른 작업을 수행할 수 있게 해줍니다. 이 개념을 받아들이면 코드를 더 효율적으로 만들고 관리하기 쉽게 할 수 있으며, 더 부드럽고 반응성이 높은 애플리케이션을 구축할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-UnderstandingJavaScriptPromisesTheBMWStory_0.png"},"coverImage":"/assets/img/2024-06-23-UnderstandingJavaScriptPromisesTheBMWStory_0.png","tag":["Tech"],"readingTime":4},{"title":"실무에서 바로 써먹는 10가지 자바스크립트 꿀팁","description":"","date":"2024-06-23 13:10","slug":"2024-06-23-10PracticalJavaScriptTips","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-10PracticalJavaScriptTips_0.png\" /\u003e\n\n1. 매개변수 객체를 배열로 변환해보세요.\n\n매개변수 객체는 함수 내에서 접근할 수 있는 배열과 유사한 객체로, 해당 함수에 전달된 매개변수 값들을 포함합니다. 그러나 배열 메소드를 가지고 있지 않습니다. 다행히도 이를 일반 배열로 변환할 수 있습니다:\n\n```js\nvar argArray = Array.prototype.slice.call(arguments);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 배열 안의 모든 값을 합산해보세요.\n\n루프를 사용하는 대신 reduce 메소드를 사용할 수 있어요:\n\n```js\nvar numbers = [3, 5, 7, 2];\nvar sum = numbers.reduce((x, y) =\u003e x + y);\nconsole.log(sum); // 결과는 17이 나옵니다\n```\n\n3. 조건부 단축 평가.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n명시적인 if 문 대신에 짧게 작성할 수 있어요:\n\n```js\nif (hungry) {\n   goToFridge();\n}\n```\n\n\u0026\u0026 연산자를 사용해 더 짧게 쓸 수 있어요:\n\n```js\nhungry \u0026\u0026 goToFridge();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 조건문과 논리 OR를 함께 사용하세요.\n\nundefined를 얻지 않도록 불필요한 변수를 선언하지 마세요:\n\n```js\nfunction doSomething(arg1){ \n    arg1 = arg1 || 32; // arg1이 이미 설정되지 않았다면 32로 설정\n}\n```\n\n5. 쉼표 연산자.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쉼표 연산자는 각 피연산자를 왼쪽에서 오른쪽으로 평가하고 마지막 피연산자의 값 반환합니다:\n\n```js\nlet x = 1;\nx = (x++, x);\nconsole.log(x); // 예상 결과: 2\nx = (2, 3);\nconsole.log(x); // 예상 결과: 3\n```\n\n6. length를 사용하여 배열의 크기를 조정합니다.\n\n크기 조정 또는 배열 비우기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvar array = [11, 12, 13, 14, 15];  \nconsole.log(array.length); // 5   \narray.length = 3;   \nconsole.log(array.length); // 3   \nconsole.log(array); // [11, 12, 13]\narray.length = 0;   \nconsole.log(array.length); // 0   \nconsole.log(array); // []\n\n7. Swap values using array destructuring.\n\nSwap values without using a temporary variable:\n\nlet a = 1, b = 2;\n[a, b] = [b, a];\nconsole.log(a); // -\u003e 2\nconsole.log(b); // -\u003e 1\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n배열의 요소들을 섞어보세요.\n\n배열 요소들을 무작위로 섞어보세요:\n\nvar list = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconsole.log(list.sort(function() {\n    return Math.random() - 0.5;\n}));\n// [4, 8, 2, 9, 1, 3, 6, 5, 7]\n\n9. 동적 속성 이름.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n객체를 선언하기 전에 동적 속성을 할당해 보세요:\n\nconst dynamic = 'color';\nvar item = {\n    brand: 'Ford',\n    [dynamic]: 'Blue'\n}\nconsole.log(item);\n// { brand: \"Ford\", color: \"Blue\" }\n\n10. 고유한 값을 필터링하세요.\n\nES6를 즐기는 분들을 위해, Spread 연산자를 사용하여 Set 객체를 활용해 새로운 배열을 만들어 보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst my_array = [1, 2, 2, 3, 3, 4, 5, 5];\nconst unique_array = [...new Set(my_array)];\nconsole.log(unique_array); // [1, 2, 3, 4, 5]\n\n- 인수 객체는 함수 내에서 액세스할 수 있는 유사 배열 객체이며, 해당 함수에 전달된 매개변수의 값을 포함합니다. 그러나 배열 메서드가 없습니다. 다행히도 일반 배열로 변환할 수 있습니다:","ogImage":{"url":"/assets/img/2024-06-23-10PracticalJavaScriptTips_0.png"},"coverImage":"/assets/img/2024-06-23-10PracticalJavaScriptTips_0.png","tag":["Tech"],"readingTime":3},{"title":"Dangerjs를 사용한 코드 리뷰 작업 자동화 방법","description":"","date":"2024-06-23 13:09","slug":"2024-06-23-AutomatingCodeReviewChoresUsingDangerjs","content":"\n\n![이미지](/assets/img/2024-06-23-AutomatingCodeReviewChoresUsingDangerjs_0.png)\n\n우리 소프트웨어 엔지니어들은 코드 리뷰에 상당한 시간을 투자합니다. 그리고 그것이 중요한 활동인 이유는:\n\n- 코드를 릴리스하기 전에 잠재적인 버그를 감지할 수 있습니다.\n- 코드가 의도한 대로 작동하는지 확인할 수 있습니다.\n- 코드가 유지 관리 가능한지 확인할 수 있습니다.\n- 코드 품질, 단위 테스트 등과 같은 일관된 코딩 규칙을 유지할 수 있습니다.\n\n그러나 일부 코드 리뷰 부분은 자동화되지 않는 한 지루할 수 있습니다. 이러한 부분을 \"코드 리뷰 일\"로 분류할 수 있습니다. 몇 가지 예는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 만든 자가 풀 리퀘스트의 일부로 파일을 업데이트했는지 확인해주세요. 예: CHANGELOG.md와 package.json 파일들.\n- 새로 만든 함수에 테스트를 추가했는지 확인해주세요.\n- 풀 리퀘스트(PR)가 너무 큰지 확인해주세요.\n- 오타가 있는지 확인해주세요.\n\n우리는 풀 리퀘스트(PR) 크기를 작게 유지하거나 package.json 파일을 최신 상태로 유지하라고 계속 상기시키는 개발자가 되고 싶지 않아요. 동일한 PR 피드백을 반복할 때 코드 리뷰 일이 뚜렷해져요.\n\n우리는 PR이 해결하려는 실제 문제를 리뷰하는 데 더 많은 시간을 할애해야 해요. 그래서 코드 리뷰 일에 소비하는 시간을 최소화할 수 있어요.\n\n일상적인 작업들을 자동화하면 코드의 품질과 팀의 효율성이 향상될 거예요. 일상적인 일을 걱정할 필요가 적어지면, 비즈니스 로직과 잠재적 버그와 같은 중요한 부분을 리뷰하는 데 더 많은 시간을 쓸 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 위험 JS\n\n다행히도, 코드 리뷰를 자동화해 주는 무료 도구인 Danger가 있어요. Danger에는 루비용 Danger와 자바스크립트용 Danger(JS)와 같이 여러 버전이 있어요. 두 버전 모두 동일한 일을 처리해요. 당신이 선호하는 프로그래밍 언어를 선택해서 Danger 규칙을 작성할 수 있는 거에요. 이 글에서는 Danger JS를 사용할 거예요.\n\n이전 블로그 게시물에 있는 \"Danger란?\" 섹션을 읽어보면 Danger에 대한 간단한 소개를 볼 수 있어요.\n\n다음 섹션에서 Danger JS를 사용하여 자동화할 수 있는 몇 가지 일상적인 작업의 예시를 공유할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-AutomatingCodeReviewChoresUsingDangerjs_1.png\" /\u003e\n\n# PR에서 특정 파일 업데이트\n\n예를 들어, PR에서 CHANGELOG.md 및 package.json 파일을 업데이트하는지 확인합니다. JavaScript 라이브러리를 공유하는 경우, 해당 라이브러리의 변경 로그와 버전을 추적하는 것이 좋은 관행입니다.\n\n다음은 당신이 Danger 함수에서 수행할 수 있는 작업입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 당신의 PR에 변경 사항이 있는지 변경 로그 파일과 package.json 파일을 확인하세요.\n- 변경 사항이 없는 경우, 파일을 업데이트해야 함을 나타내는 코멘트를 PR에 남기세요.\n\n다음은 danger.systems/js에서 일부 샘플 코드입니다:\n\n```js\n// 앱 변경 사항에 대한 CHANGELOG 항목 추가\nconst hasChangelog = danger.git.modified_files.includes(\"changelog.md\")\nconst isTrivial = (danger.github.pr.body + danger.github.pr.title).includes(\"#trivial\")\r\n```\n\n```js\nif (!hasChangelog \u0026\u0026 !isTrivial) {\n  warn(\"변경 사항에 대한 변경 로그 항목을 추가해주세요.\")\n}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n차단 JS 확장 프로그램에는 변경 로그 파일을 추적하는 Danger JS 확장 프로그램 (danger-plugin-keepachangelog)도 있습니다. 이 확장 프로그램을 직접 사용할 수 있으므로 처음부터 기능을 작성할 필요가 없습니다.\n\n## 의도하지 않은 인쇄 문장\n\n로컬에서 변경 사항을 디버그하거나 테스트하기 위해 인쇄 문장을 사용합니다. 불행하게도 이러한 문장을 가끔 우리의 브랜치에 의도치 않게 커밋할 수 있습니다.\n\n메인 브랜치에서 불필요한 인쇄 문장을 제외하는 것이 좋은 실천 방법입니다. 중복되는 인쇄 문장은 앱이나 서비스를 실행할 때 소음을 더해 코드베이스가 디버깅하기 어렵게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 경우, 작성자나 검토자가 문제를 발견합니다. 그러나 불가피하게 몇 가지 문제는 여전히 누락될 수 있습니다. Danger JS를 사용하여 이 확인을 자동화해야 합니다.\n\n참고용 의사코드는 다음과 같습니다:\n\n```js\n// DangerJS를 사용하여 수정된 파일을 가져옵니다\nmodifiedFiles = getModifiedFiles()\nfor (modifiedFile in modifiedFiles) {\n    // 각 파일에 대해 추가된 diff를 가져옵니다\n    diffAddedForFile = getDiffAdded(modifiedFile)\n    // 각 diff 문자열에 print 문이 포함되어 있는지 확인합니다 (예: Go의 fmt.print 또는 JS의 console.log)\n    if (diffAddedForFile.includes('fmt.print')) {\n        warn('fmt.print가 감지되었습니다')\n    }    \n}\n```\n\nJavaScript를 사용하는 경우, 다른 대안적인 솔루션을 사용할 수 있어서 Danger 규칙을 처음부터 작성할 필요가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Danger JS 확장 기능: danger-plugin-noconsole.\n- ESLint의 no-console.\n\n## PR이 너무 큰지 확인하기\n\n우리는 PR을 가능한 한 작게 유지하고 싶습니다. 큰 PR은 인지 부담을 증가시킵니다. 작은 PR은 더 관리하기 쉬우며 리뷰하기도 쉽습니다. 때로는 PR 작성자에게 PR을 작은 조각들로 나누도록 상기해야 할 수도 있습니다.\n\n우리는 Danger JS 규칙을 작성하여 PR에서 변경된 라인 수를 세어볼 수 있습니다. 숫자가 지정된 \"크게 PR 임계값\"을 초과하면 PR을 작은 PR로 나누도록 의견을 남길 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n변경 라인 수 = 삭제된 라인 수 + 추가된 라인 수\n\n팀 전체에서 수용할 수 있는 큰 PR 임계값에 대해 합의해야 합니다. 팀이 처음에 충분히 좋다고 느끼는 임의의 임계값으로 시작하십시오. 제 경험상 500에서 600 값을 사용하는 것이 일반적입니다. 그런 다음 시간이 지남에 따라 세부 조정할 수 있습니다.\n\n다음은 https://danger.systems/js/에서 샘플 코드입니다:\n\n```js\nvar bigPRThreshold = 600;\nif (danger.github.pr.additions + danger.github.pr.deletions \u003e bigPRThreshold) {\n  warn(':exclamation: 큰 PR (' + ++errorCount + ')');\n  markdown('\u003e (' + errorCount + ') : 풀 리퀘스트 크기가 비교적 크게 보입니다. 여러 변경 사항이 포함된 경우 각각을 별도의 PR로 분리하면 더 빠르고 쉬운 검토를 할 수 있습니다.');\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신이 원하는 대로, 빅 PR 임계값에 대한 계산에 카운트되기를 원치 않는 파일을 제외할 수도 있어요. 예를들어, mock 파일을 제외하고 싶다면:\n\n```js\nconst linesCount = await danger.git.linesOfCode(\"**/*\");\n// mock 파일을 제외합니다\nconst excludeLinesCount = await danger.git.linesOfCode(\"**/*mock*\");\nconst totalLinesCount = linesCount - excludeLinesCount;\n```\n\n```js\nif (totalLinesCount \u003e bigPRThreshold) {\n  warn(\"대규모 PR입니다. 작은 PR로 분할해 보세요.\");\n}\n```\n\n## 마크다운 오타 확인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문서의 오타는 코드베이스에서 \"깨진 창문\"으로 이어질 수 있어요. 그것들을 무시해서는 안 돼요. 다행히도 오타를 확인하는 데 유용한 Danger JS 확장 프로그램이 이미 있어요: danger-plugin-spellcheck.\n\nGitHub 리포지토리에서의 샘플 사용법은 다음과 같아요:\n\n```js\n// dangerfile.js\nimport spellcheck from 'danger-plugin-spellcheck'\n```\n\n```js\nspellcheck({\n  ignore: ['Nachoz', 'Tacoz'],\n  ignoreFiles: ['README.md']\n})\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 긍정적인 규칙, 예를 들어 PR 작성자 칭찬\n\nDanger JS는 \"이것을 잊었어\" 타입의 규칙만 있는 것은 아닙니다. 당신은 dangerfile에 긍정적인 규칙을 추가하여 PR에서 동료들을 칭찬할 수 있습니다.\n\n예를 들어: 작성자가 추가한 코드보다 더 많은 코드를 제거했을 때, 칭찬을 해주는 것입니다. 이는 여러분의 팀이 코드 추가를 피해야 한다는 것이 아닙니다. 중복 코드를 제거할 수 있도록 팀을 격려하는 방법입니다. 덜한 코드, 덜한 유지 보수.\n\n간단한 if 블록을 사용하여 Danger JS에서 이를 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nif (danger.github.pr.deletions \u003e danger.github.pr.additions) {\n  message(`:thumbsup: 더 많은 코드를 삭제했군요!`);\n}\n```\n\n우리는 Danger JS의 긍정적 규칙에 대한 자세한 설명을 확인할 수 있습니다.\n\n## 누락된 테스트 확인\n\n얼마나 자주 이런 PR 피드백을 작성하고 받을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아마도 많이 할 것 같아요. 다시 한 번 하지 않아도 돼요.\n\n저희가 PR에서 테스트를 검토할 때 필요한 단계들이에요:\n\n- 새로운 기능 또는 메소드에 테스트가 필요한지 확인해요.\n- 테스트가 이미 존재하는지 확인해요 — 패턴 매칭.\n- 테스트가 우리가 테스트해야 하는 경로들을 커버하고 있는지 확인해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위험 JS를 사용하여 단계 2를 자동화할 수 있어요. 단계 1과 3을 자동화할 필요조차 없어요. 단계 2를 자동화하는 것이 더 직관적이고 많은 시간을 절약할 수 있어요.\n\n테스트 누락을 확인하는 것은 테스트 커버리지를 계산하는 것과 같지 않아요. 테스트 커버리지를 계산할 때, 빌드가 지정된 커버리지 임계값을 충족하지 못하면 실패해요.\n\n코드 리뷰 중에 테스트를 확인할 때 테스트 커버리지를 직접 계산하지 않아요. 대신 패턴을 찾아요. 예를 들어, Golang의 PR을 리뷰할 때:\n\n- 새로운 함수 GetUsers()가 있는 경우 Test_GetUsers()라는 연관된 테스트가 있는지 확인해봐요.\n- Test_GetUsers()가 누락된 경우, \"누락된 테스트를 추가하세요\"라는 피드백을 남겨주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 패턴 매칭 로직을 Danger JS를 사용하여 프로그래밍적으로 실행할 수 있어요. 그러려면 특정 명명 규칙을 따라야 해요.\n\n우리 Danger JS 코드에서 PR 내의 테스트를 찾는 단계는 아래와 같아요:\n\n- PR diff를 가져와요.\n- 새로 추가된 함수가 있는지 확인해요. 여기에는 정규식을 사용할 수 있어요.\n- 새로운 함수가 있다면, 해당 함수에 대한 테스트가 있는지 찾아요. 예를 들어, PR에서 새로 추가된 함수 GetUsers()를 발견했다면, 해당 함수에 대한 테스트 Test_GetUsers()를 찾아야 해요.\n- Test_GetUsers()가 존재하지 않는다면, PR에 주석을 남겨요.\n\n의사 코드는 다음과 같을 거에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// PR에 추가된 함수에서 누락된 테스트를 확인합니다:\naddedFunctionNames = []\ndiffs = []\nmodifiedFiles = getModifiedFiles()\nmodifiedTestFiles = getModifiedTestFiles()\ndiffs = modifiedFiles.map(m =\u003e getDiffAdded(m))\ntestDiffs = modifiedTestFiles.map(m =\u003e getDiffAdded(m))\nfor (diff in diffs) {\n    parsedFunctionName = parseFunctionNames(diff) \n    // 패턴이 일치하는지 확인합니다\n    testsFound = testDiffs.filter(diff =\u003e diff.includes(`test_${parsedFunctionName}`))\n    if (testsFound.length === 0) {\n        warn(`테스트 누락: ${parsedFunctionName}`)\n   }\n}\n```\n\nGoogle CloudBuild에서 Danger JS를 설정하는 것은 간단합니다. 자세한 내용은 이전 블로그 포스트를 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-23-AutomatingCodeReviewChoresUsingDangerjs_0.png"},"coverImage":"/assets/img/2024-06-23-AutomatingCodeReviewChoresUsingDangerjs_0.png","tag":["Tech"],"readingTime":7}],"page":"11","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"11"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>