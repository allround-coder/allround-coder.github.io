<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/11" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/11" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="협업 편집 기능 추가 우리 뉴스룸 CMS 구축 과정 공개" href="/post/2024-06-23-WeBuiltCollaborativeEditingforOurNewsroomsCMSHeresHow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="협업 편집 기능 추가 우리 뉴스룸 CMS 구축 과정 공개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-WeBuiltCollaborativeEditingforOurNewsroomsCMSHeresHow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="협업 편집 기능 추가 우리 뉴스룸 CMS 구축 과정 공개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">협업 편집 기능 추가 우리 뉴스룸 CMS 구축 과정 공개</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript 프로미스 이해하기 BMW 이야기" href="/post/2024-06-23-UnderstandingJavaScriptPromisesTheBMWStory"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript 프로미스 이해하기 BMW 이야기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UnderstandingJavaScriptPromisesTheBMWStory_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript 프로미스 이해하기 BMW 이야기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript 프로미스 이해하기 BMW 이야기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="실무에서 바로 써먹는 10가지 자바스크립트 꿀팁" href="/post/2024-06-23-10PracticalJavaScriptTips"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="실무에서 바로 써먹는 10가지 자바스크립트 꿀팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-10PracticalJavaScriptTips_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="실무에서 바로 써먹는 10가지 자바스크립트 꿀팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">실무에서 바로 써먹는 10가지 자바스크립트 꿀팁</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Dangerjs를 사용한 코드 리뷰 작업 자동화 방법" href="/post/2024-06-23-AutomatingCodeReviewChoresUsingDangerjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Dangerjs를 사용한 코드 리뷰 작업 자동화 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AutomatingCodeReviewChoresUsingDangerjs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Dangerjs를 사용한 코드 리뷰 작업 자동화 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Dangerjs를 사용한 코드 리뷰 작업 자동화 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript로 정의되지 않은 객체에 속성을 자동으로 추가하는 방법" href="/post/2024-06-23-HowtoAutomaticallyAddPropertiestoanObjectthatisUndefinedwithJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript로 정의되지 않은 객체에 속성을 자동으로 추가하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtoAutomaticallyAddPropertiestoanObjectthatisUndefinedwithJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript로 정의되지 않은 객체에 속성을 자동으로 추가하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript로 정의되지 않은 객체에 속성을 자동으로 추가하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="env 파일 이제는 그만 둘 때  더 나은 대안 찾기" href="/post/2024-06-23-Itstimetodeprecatetheenvfile"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="env 파일 이제는 그만 둘 때  더 나은 대안 찾기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Itstimetodeprecatetheenvfile_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="env 파일 이제는 그만 둘 때  더 나은 대안 찾기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">env 파일 이제는 그만 둘 때  더 나은 대안 찾기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 컴포넌트에서 커스텀 상태의 숨겨진 힘" href="/post/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 컴포넌트에서 커스텀 상태의 숨겨진 힘" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 컴포넌트에서 커스텀 상태의 숨겨진 힘" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 컴포넌트에서 커스텀 상태의 숨겨진 힘</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="상위 1 웹 개발자가 되기 위해 꼭 가져야 할 10가지 기술" href="/post/2024-06-23-10must-haveskillstobecomeatop1webdeveloper"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="상위 1 웹 개발자가 되기 위해 꼭 가져야 할 10가지 기술" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="상위 1 웹 개발자가 되기 위해 꼭 가져야 할 10가지 기술" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">상위 1 웹 개발자가 되기 위해 꼭 가져야 할 10가지 기술</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React로 카운트다운 타이머 만드는 방법" href="/post/2024-06-22-BuildingaCountdownTimerinReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React로 카운트다운 타이머 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-BuildingaCountdownTimerinReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React로 카운트다운 타이머 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React로 카운트다운 타이머 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="실전 HTML과 CSS 빠른 실력 향상을 위한 10개 프로젝트" href="/post/2024-06-22-Hands-OnHTMLandCSS10ProjectsforRapidSkillImprovement"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="실전 HTML과 CSS 빠른 실력 향상을 위한 10개 프로젝트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Hands-OnHTMLandCSS10ProjectsforRapidSkillImprovement_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="실전 HTML과 CSS 빠른 실력 향상을 위한 10개 프로젝트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">실전 HTML과 CSS 빠른 실력 향상을 위한 10개 프로젝트</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link posts_-active__YVJEi" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"협업 편집 기능 추가 우리 뉴스룸 CMS 구축 과정 공개","description":"","date":"2024-06-23 13:12","slug":"2024-06-23-WeBuiltCollaborativeEditingforOurNewsroomsCMSHeresHow","content":"\n\nSophia Ciocca와 Jeff Sisson\n\n뉴욕 타임스 기사를 게시하려면 많은 사람이 필요하고 때로는 상황이 복잡해질 수 있습니다. 여러 기자와 편집자가 한 편의 이야기를 쓰고 개정하고 발표하는 데 참여할 수 있으며, 이 협업은 종종 비선형적이며, 서로의 발을 짓게할 수 있습니다.\n\n특히 많은 유형의 협력자(사진 편집자, 복사 편집자, 기자, 프로듀서)가 동시에 문서를 편집해야 하는 긴급 상황에서 이는 특히 사실입니다. 뉴욕 타임스의 차세대 기사 편집 인터페이스인 Oak을 처음 개발할 때 한 번에 한 사람만 문서를 작업할 수 있었습니다. Oak은 \"필드 잠금\"을 사용하여 서로 다른 사람들이 별도의 메타데이터 필드를 편집하도록 허용하는 것과 같은 일부 동시 협업 기능을 용이하게 했지만, 한 번에 한 사람만 기사 내용을 편집할 수 있었습니다.\n\n협업 편집 기능이 필요했던 Oak에서 협력자가 동시에 자연스럽게 문서에서 작업할 수있는 더 완벽한 기사 편집기가 필요했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 협업 편집은 해결하기 어려운 문제입니다. 실시간 업데이트를 통합하는 방법, 충돌하는 편집에 대처하는 방법, 불안정한 와이파이로 인한 오류를 처리하는 방법 등 많은 새로운 수수께끼를 제시합니다. Google Docs와 같은 제품은 대규모로 이러한 문제를 해결하기 위해 막대한 팀과 자원을 투입하고 있습니다. 저희 팀은 The Times의 편집 작업 흐름에 적합한 방식으로 이러한 수수께끼를 해결할 시간이 몇 달밖에 없었습니다. 다행히도 이러한 종류의 기술적 도전에 대한 지원이 Oak의 기술 기반으로 ProseMirror를 선택한 초기 이유 중 하나였습니다.\n\n# 모든 사람이 단계들이 필요합니다\n\nOak 글이 협업적이 되기 위해서는 글에 접근 권한이 있는 모든 사람이 실시간으로 가장 최신 버전을 가지고 있어야 합니다. 이는 편집이 이루어질 때마다, 해당 편집이 협업자의 컴퓨터에서 보이도록 해야 한다는 것을 의미합니다. 개별 편집을 인터넷으로 전송할 수 있는 형태로 변환하는 것은 ProseMirror가 낮은 수준에서 수행하는 작업입니다. 각각의 편집을 \"단계\"라고 부릅니다. 사용자가 글자를 입력할 때, 그것이 단계입니다. 새 줄로 이동하기 위해 엔터 키를 누르는 것도 단계입니다. 문서를 조작하는 모든 것 - 이미지 추가, 제목 편집, 단락 삭제 - 모두 단계로 간주됩니다.\n\n정확히 어떻게 단계의 데이터가 표현되는 걸까요? 우리는 단계를 문서를 어떻게 변경하는지에 대한 지시사항으로 작동하는 JSON 객체로 나타냅니다. 문서의 두 번째 위치에 글자 \"H\"를 넣는 것이 어떻게 보이는지 여기에 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n  “단계ID”: 1,\n  “단계”: {\n    “단계유형”:”대체”,\n    ”출발지”: 2,\n    ”도착지”: 2,\n    ”슬라이스”: {\n      “내용”:[{\n        “종류”:”텍스트”,\n        ”텍스트”:”h”\n      }]\n    }\n  },\n  “클라이언트ID”: “1111–42783748297342”,\n  “타임스탬프”: “Sun Feb 10 2019 12:31:32 GMT-0500 (Eastern Standard Time)”\n}\n```\n\n사용자가 단어를 입력하거나 이미지를 변경하거나 코멘트를 추가할 때, 해당 동작의 단계는 사용자의 로컬 문서에 추가됩니다. 그러나 이러한 단계는 아직 다른 사람에게 전송되지 않았습니다. 다른 사람의 컴퓨터에서 이러한 단계가 표시되려면 이를 원격 서버, 즉 “권한 서버”로 보내야 하며 원격 서버에서 확인을 받아야 합니다.\n\n권한 서버는 클럽의 용병처럼 작동합니다. 사용자로부터 단계를 받으면 그 단계를 데이터베이스에 저장할지 여부를 결정해야 합니다. 사용자의 브라우저가 마지막으로 권한 서버와 통신한 후에 저장된 단계가 없다면, 권한 서버는 해당 단계를 저장합니다. 그렇지 않으면 사용자의 브라우저에 아직 보지 못한 단계를 가져오라고 알려줍니다.\n\n로컬 문서와 원격 권한 서버 간의 전형적인 대화는 다음과 같을 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n1. 로컬: \"안녕하세요, 한, 둘, 셋 단계를 가지고 있어요.\"\n2. 원격: \"좋아요, 한, 둘, 셋 단계를 저장했습니다.\"\n3. 로컬: \"다시 안녕하세요... 넷, 다섯, 여섯 단계를 가지고 있어요.\"\n4. 원격: \"아! 다른 사람이 넷과 다섯 단계를 삽입했어요. 가져와주세요.\"\n5. *로컬이 넷과 다섯 단계를 가져오고, 이전의 넷, 다섯, 여섯 단계를 새로운 것으로 바꿔 여섯, 일곱, 여덟 단계로 반영합니다.*\n6. 로컬: \"안녕하세요... 이제 여섯, 일곱, 여덟 단계를 가지고 있어요.\"\n7. 원격: \"멋져요, 여섯, 일곱, 여덟 단계를 저장했습니다.\"\n```\n\n선 네 번째 줄에서 로컬 문서가 네, 다섯, 여섯 단계를 전송하려 시도하지만, 원격 서버는 이미 해당 단계가 존재한다고 브라우저에 알립니다. 브라우저는 해당 단계를 가져와 다시 전송하려고 합니다. 여기에서 무슨 일이 벌어지나요?\n\n리베이스는 동일한 시기에 두 사용자가 단계를 삽입했을 때 발생하는 프로세스입니다. 코드가 어떻게 조정되는지를 결정해야 하는 중요한 부분 중 하나인 ProseMirror의 협업 편집 지원의 핵심인 Operational Transformation이라는 알고리즘이 관여합니다.\n\n# 단계가 있는 곳이 집이다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nProseMirror은 협업 편집 서버를 구현하기 위한 매우 훌륭한 구성 요소(그리고 완벽히 작동하는 데모)를 제공하지만, 데이터베이스에 단계를 저장하는 방법을 명시하지 않습니다. 우리는 우리의 특정 요구 사항에 맞는 솔루션을 설계하고 구현해야 했습니다. 저희는 프로토타이핑 단계에서 고려한 몇 가지 질문은 다음과 같습니다. 권한 있는 서버를 어떻게 확장하여 많은 수정을 허용할 수 있을까요? (기사 당 최대 25,000회) 협업 문서의 편집 기록을 어떻게 보존할 수 있을까요? 마지막으로, 최신 문서를 인쇄 생산 시스템에 전달하는 등, 우리 뉴스룸의 고유한 필요에 맞는 다양한 기능을 지원하는 방법은 무엇일까요?\n\n다양한 프로토타입을 스케치한 후, 우리는 실시간 데이터베이스 Firestore를 사용하여 단계를 저장하고 들어오는 단계를 거르는 데 이를 사용하기로 결정했습니다. Firestore는 데이터베이스 트랜잭션을 지원하므로 여러 사람으로부터 제출된 단계가 Firestore 라이브러리에 의해 여러 번 시도되어 한 사람의 삽입이 \"이기고\" 데이터베이스에 기록될 때까지 다시 시도됩니다. 이러한 방식으로 여러 사람의 단계를 정렬함으로써 Firestore를 권한 있는 서버로서 좋은 선택으로 만듭니다.\n\n데이터베이스로의 쓰기 작업이 성공하면 Firestore는 원격 사용자에게 새로운 단계가 데이터베이스에 추가되었음을 알리며, 이로 인해 앱이 새로 확인된 단계를 가져와서 문서의 복사본을 최신 상태로 가져오게 됩니다.\n\n# 여러 사람이 입력 중입니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n협업 문서를 최신 상태로 유지하는 것은 중요하지만, 문서를 지켜보고 있는 다른 사람이 누구인지 알아내는 것도 중요합니다. 문서에 있는 모든 사람이 협업자의 커서 위치를 볼 수 있거나, 협업자가 마우스로 특정 부분을 강조한 것을 볼 수 있기를 원했습니다. ProseMirror와 Firebase API (Firestore의 동생)를 활용하여 Oak에 추가한 기능은 문서에 누가 있고 그들이 커서를 둔 위치를 보여주는 것입니다.\n\n![image](/assets/img/2024-06-23-WeBuiltCollaborativeEditingforOurNewsroomsCMSHeresHow_0.png)\n\n사용자가 Oak 편집기 내에서 타이핑, 클릭 또는 끌기를 통해 선택을 변경할 때마다, ProseMirror는 브라우저 선택의 현재 상태의 변경을 관찰하고 해당 정보로 Selection 데이터 구조를 만듭니다. 이 데이터는 사용자의 커서가 텍스트에서 어디에 있는지에 대한 정보를 반영하며, 시작 위치(머리) 및 끝 위치(앵커)를 포함합니다.\n\n사용자가 문서에서 선택을 만들면, 해당 선택이 문서를 열어둔 모든 컴퓨터에 렌더링되고 그 옆에 사용자의 이름이 표시됩니다. 사용자가 브라우저에서 선택을 변경할 때, 해당 변경 사항이 문서에 반영되어야 하므로 업데이트된 선택 데이터(머리 + 앵커 위치)를 Firebase로 푸시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 선택 사항을 처리하기 위해 가끔은 미래를 예측해야 합니다. 선택 데이터와 문서 변경 사항이 별도의 서버로 전송되기 때문에 Oak 앱은 브라우저가 아직 수신하지 않은 문서 버전의 선택 변경을 수신할 수 있습니다. Oak 앱이 문서 편집에 대응하는 선택 변경을 받기 전에 문서 편집을 수신하면 해당 선택이 어떻게 변경될 지 시뮬레이션해야 합니다. 마찬가지로, 아직 도착하지 않은 편집에 관련된 선택 변경을 수신하면 앱은 해당 편집이 도착할 때까지 선택 변경을 렌더링하기 전까지 기다려야 합니다. 이를 위해 미래에서 선택 업데이트를 기다렸다가 적용하기 위해 Redux Saga를 사용합니다.\n\n우리는 선택 사항을 저장하기 위해 Firestore(단계 저장에 사용 중) 대신 Firebase를 선택했음을 언급할 가치가 있습니다. 왜냐하면 Firebase는 onDisconnect 후크를 사용할 수 있게 해줍니다. 이로써 사용자가 탭을 닫더라도 실행이 보장된 데이터베이스 수정을 수행할 수 있습니다. 이는 Oak 편집기를 떠나는 사용자의 커서가 그들을 따라 깔끔하게 정리되도록 도와줍니다.\n\n# 게시하거나 소멸하라\n\n모든 기사 편집물 또는 단계가 Firestore에 삽입되면 해당 기사를 열어둔 모든 브라우저 창이 최신 단계로 업데이트됩니다. 기사를 게시할 준비가 되면, 게시를 처리하는 백엔드 서비스는 최신 기사 데이터도 가져와 사이트와 앱이 기사를 렌더링하기 위해 사용자 끝단에 제공하는 게시 파이프라인으로 전송합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 협업 편집을 구현하기 전에는 이 흐름이 더 간단했습니다: 백엔드 서비스는 기사 내용과 메타데이터가 저장된 MySQL 데이터베이스로 직접 이동할 수 있었습니다. 그러나 협업 편집 기사의 경우에는 Firestore에서 기사 내용을 퍼블리싱 서비스로 이동시키는 앱 엔진 서비스(우리가 “협업 서비스”라고 명명했습니다)를 만들었습니다. 사용자가 게시 버튼을 클릭하면 브라우저가 이 협업 서비스에 요청을 보내고, 해당 서비스는 Firestore로부터 데이터를 퍼블리싱 파이프라인으로 복사합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-WeBuiltCollaborativeEditingforOurNewsroomsCMSHeresHow_1.png\" /\u003e\n\n협업 편집된 기사가 디지털로 게시된 후 인쇄를 위해 세부 조정이 필요할 수 있습니다. 기사가 인쇄 공장으로 보내기 전에 뉴스룸의 편집자들이 하이퍼링크와 삽입 콘텐츠를 제거하거나 기사를 줄여야 할 수 있습니다.\n\n이러한 인쇄 편집을 수행하는 인터페이스는 기존 MySQL 데이터베이스에 의존합니다. 협업 기사는 Firestore에 저장되어 이 인쇄 데이터베이스와 연결이 끊겨 있기 때문에, 기사의 협업 상태가 정기적 간격으로 주요 MySQL 데이터베이스로 복사되는 시스템을 개발했습니다. 이 시스템에는 Google Cloud Functions와 Google Cloud Tasks가 포함되어 있으며, 최소 한끗 차이로 콜라보레이티브 변경 사항을 신문에 인쇄될 것과 동일하게 미리 볼 수 있게 해줍니다. 이는 우리의 인쇄 편집자들에게 유용한 기능입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n공동으로 편집된 Oak 기사가 게시되고 인쇄되었을 때, 드디어 결승선에 오르게 되었습니다! 게시 후에 수정 사항이 있는 경우 일부 기사는 변경 사항을 추적하기 위해 Firestore에 저장되며, 그 단계는 디지털 게시를 마침으로 우리 기사와 해당 단계의 이야기는 끝납니다. 우리는 이제 뉴스룸 전체의 협력자들에게 대대적으로 향상된 사용자 경험을 제공하는 기존 뉴스 워크플로우와 매끈하게 작동하는 공동 편집자를 보유하고 있습니다.\n\n이것은 거대한 다수의 팀이 노력한 결과입니다. Oak 및 CMS 팀의 많은 멤버들이 지난 및 현재에 우리를 기고유로 편집이 가능한 상태로 이끌었습니다. 특히 Oak 팀 - Minerva Archer, Sophia Ciocca, Tom Holcolmb, Dmitriy Matveev, Shane Moore, Dylan Nelson, Thomas Rhiel, Alexandra Shaheen, Jeff Sisson 및 Matthew Stake -은 2016년 이후 이 문제에 대한 놀라운 작업을 해왔습니다.\n\n또한 PubPub의 Travis Rich에게 ProseMirror와 Firebase를 사용하는 데 대한 첫 인사이트를 제공해 준 것에 감사를 표합니다. 그리고 이 프로젝트에 유용한 조언을 제공해준 ProseMirror의 저자인 Marijn Haverbeke에게도 감사를 표합니다.\n\nSophia Ciocca는 뉴욕 타임즈 출판팀 소프트웨어 엔지니어로 Oak에서 일하고 있습니다. 그녀의 Medium을 팔로우하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제프 시슨은 뉴욕타임스의 퍼블리싱 팀에서 리드 소프트웨어 엔지니어로 일하며 Oak에 참여하고 있습니다. 트위터에서 그를 팔로우하거나 그의 개인 홈페이지를 방문해보세요.","ogImage":{"url":"/assets/img/2024-06-23-WeBuiltCollaborativeEditingforOurNewsroomsCMSHeresHow_0.png"},"coverImage":"/assets/img/2024-06-23-WeBuiltCollaborativeEditingforOurNewsroomsCMSHeresHow_0.png","tag":["Tech"],"readingTime":7},{"title":"JavaScript 프로미스 이해하기 BMW 이야기","description":"","date":"2024-06-23 13:11","slug":"2024-06-23-UnderstandingJavaScriptPromisesTheBMWStory","content":"\n\n![이미지](/assets/img/2024-06-23-UnderstandingJavaScriptPromisesTheBMWStory_0.png)\n\n자바스크립트에서 Promise는 기본 개념이지만 이해하기 어려울 수 있습니다. 이 글을 읽은 후에는 이 개념을 완전히 이해할 거에요. 친숙한 현실적인 비유를 사용해 설명해 보겠습니다.\n\n아버지가 새 BMW를 사주겠다고 약속한다고 상상해보세요. 이 약속은 보거나 만질 수 없지만, 여러분의 생각과 아버지의 생각 속에 존재합니다. 마찬가지로 자바스크립트에서 Promise는 비동기 작업의 결과를 나타내는 객체입니다.\n\n간단히 말해, 자바스크립트의 Promise는 아버지의 약속과 비슷합니다. 미래의 결과를 위한 자리 표시자인 것이죠. 하지만 우리의 머릿속에만 존재하는 게 아니라 컴퓨터 메모리에 있고 코드를 통해 조작할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에서 유사성을 살펴보겠습니다:\n\n약속하기: 아빠가 BMW를 약속해줄 때, 즉시 차를 주지 않는다. 마찬가지로, JavaScript 함수가 약속을 반환할 때도 즉시 결과를 제공하지 않습니다.\n\n대기 상태: BMW를 기다리는 동안 당신은 일상생활을 하며 다른 일을 합니다. 이것은 JavaScript 약속의 '대기 중' 상태와 유사합니다. 해당 작업이 아직 완료되지 않았지만 다른 작업은 여전히 동시에 실행될 수 있습니다. 이것이 비동기 프로그래밍이라고도 하며, 주 스레드를 블로킹하지 않고 작업이 수행되는 방식입니다.\n\n성공: 아빠가 결국 BMW를 사주면, 약속이 이행됩니다. JavaScript에서는 약속이 성공적으로 해결되어 예상한 결과를 제공하는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n거절: 아버지가 BMW을 사지 않으면 약속이 깨집니다. JavaScript 용어로 말하면 이 약속은 거부되어 작업이 실패했음을 나타냅니다.\n\n# Promise의 라이프사이클\n\n자바스크립트 Promise의 상태에 대해 좀 더 자세히 살펴보겠습니다:\n\n1. 대기 중: 이것은 초기 상태입니다. 이 Promise은 충족되지도 거절되지도 않았으며 결과를 기다리고 있습니다. 이는 아버지가 \"잠깐만 기다려, 좀 더 시간을 주세요\"라고 말할 때 상황과 대응됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 이행됨: 약속이 성공적으로 완료되었습니다. 우리의 비유에서는 BMW를 수령할 때입니다. JavaScript에서는 약속이 값으로 해결됩니다.\n\n3. 거부됨: 약속이 실패했습니다. 이는 BMW를 받지 못하는 것과 같습니다. JavaScript에서는 약속이 이유(에러)와 함께 거부됩니다.\n\n# JavaScript에서 약속(Promises) 생성 및 처리하기\n\n다음은 JavaScript에서 약속을 생성하고 처리하는 간단한 예제입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Promise 생성\nlet promise = new Promise((resolve, reject) =\u003e {\n  let isPromiseKept = true; // 약속을 지키는지를 시뮬레이션\n  if (isPromiseKept) {\n    resolve('BMW를 받았어요!');\n  } \n  else {\n    reject('약속을 어겼네요, BMW가 없어요.');\n  }\n });\n```\n\n```js\n// Promise 처리\npromise\n .then((message) =\u003e {\n   console.log(message); // 출력: BMW를 받았어요!\n })\n .catch((error) =\u003e {\n   console.log(error); // 출력: 약속을 어겼네요, BMW가 없어요.\n });\n```\n\n# 코드 설명하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet promise = new Promise((resolve, reject) =\u003e {....});\n```\n\n위 코드는 'Promise' 생성자를 사용하여 프로미스를 생성합니다. 생성자는 인수로 함수(콜백)를 취합니다. 이 콜백 함수는 resolve 및 reject라는 두 개의 매개변수를 사용합니다.\n\n프로미스 결과 시뮬레이션:\n\nlet isPromiseKept = true;: 이 변수는 프로미스가 유지될지 여부를 시뮬레이션합니다. 시연 목적을 위해 간단한 boolean 값입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPromise 해결 또는 거부:\n\n```js\nif (isPromiseKept) {\n    resolve('BMW를 받았습니다!');\n} else {\n    reject('약속이 깨졌습니다, BMW가 없어요.');\n}\n```\n\n위 조건은 isPromiseKept의 값을 확인합니다. 만약 true이면, 'BMW를 받았습니다!' 메시지와 함께 resolve 함수가 호출됩니다. 만약 false이면, '약속이 깨졌습니다, BMW가 없어요.' 메시지와 함께 reject 함수가 호출됩니다.\n\nPromise 결과 처리하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\npromise\n .then((message) =\u003e {\n   console.log(message); // Output: BMW received!\n })\n .catch((error) =\u003e {\n   console.log(error); // Output: Promise broken, no BMW.\n });\r\n```\r\n\r\n프로미스가 처리된 후 — 성공적으로 해결되거나 거부된 경우 — 프로미스 객체의 .then() 또는 .catch() 메서드를 사용하여 결과를 가져옵니다. 이러한 메서드는 콜백 함수를 매개변수로 사용합니다. 이러한 콜백은 resolve 또는 reject에서 반환된 데이터를받습니다. 프로미스가 해결되거나 거부되는 경우 결과를 처리하기 위해 .then() 또는 .catch() 중 하나가 실행됩니다.\r\n\r\n.then() 메서드는 해결된 상태를 처리하고 해결된 데이터(일반적으로 message로 지칭)를 콜백 함수로 전달합니다. 반대로 프로미스가 거부되면 .catch() 메서드가 거부 이유(일반적으로 error로 표시)를 처리합니다. .then()은 원칙적으로 해결된 상태와 거부된 결과를 모두 처리할 수 있지만 두 개의 매개변수(첫 번째 콜백은 해결된 상태, 두 번째는 거부된 상태)를 제공함으로써기 때문에 성공적인 결과에 대해 .then()을 사용하고 오류 처리에는 .catch()을 사용하는 것이 일반적으로 더 명확합니다.\r\n\r\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트의 Promise는 비동기 작업을 효과적으로 관리할 수 있는 강력한 도구입니다. 이를 통해 코드가 결과를 기다리는 동안 멈추지 않고 작업을 처리할 수 있습니다. 약속을 아빠가 BMW를 사주겠다고 하는 것처럼 생각하면, Promise가 가질 수 있는 다양한 상태인 보류 중(pending), 이행됨(fulfilled), 거부됨(rejected)을 더 잘 이해할 수 있습니다. 당신이 아빠가 약속을 이행할 때까지 기다리는 동안 다른 작업을 병행하는 것처럼, JavaScript는 Promise가 해결되거나 거부될 때까지 다른 작업을 수행할 수 있게 해줍니다. 이 개념을 받아들이면 코드를 더 효율적으로 만들고 관리하기 쉽게 할 수 있으며, 더 부드럽고 반응성이 높은 애플리케이션을 구축할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-UnderstandingJavaScriptPromisesTheBMWStory_0.png"},"coverImage":"/assets/img/2024-06-23-UnderstandingJavaScriptPromisesTheBMWStory_0.png","tag":["Tech"],"readingTime":4},{"title":"실무에서 바로 써먹는 10가지 자바스크립트 꿀팁","description":"","date":"2024-06-23 13:10","slug":"2024-06-23-10PracticalJavaScriptTips","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-10PracticalJavaScriptTips_0.png\" /\u003e\n\n1. 매개변수 객체를 배열로 변환해보세요.\n\n매개변수 객체는 함수 내에서 접근할 수 있는 배열과 유사한 객체로, 해당 함수에 전달된 매개변수 값들을 포함합니다. 그러나 배열 메소드를 가지고 있지 않습니다. 다행히도 이를 일반 배열로 변환할 수 있습니다:\n\n```js\nvar argArray = Array.prototype.slice.call(arguments);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 배열 안의 모든 값을 합산해보세요.\n\n루프를 사용하는 대신 reduce 메소드를 사용할 수 있어요:\n\n```js\nvar numbers = [3, 5, 7, 2];\nvar sum = numbers.reduce((x, y) =\u003e x + y);\nconsole.log(sum); // 결과는 17이 나옵니다\n```\n\n3. 조건부 단축 평가.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n명시적인 if 문 대신에 짧게 작성할 수 있어요:\n\n```js\nif (hungry) {\n   goToFridge();\n}\n```\n\n\u0026\u0026 연산자를 사용해 더 짧게 쓸 수 있어요:\n\n```js\nhungry \u0026\u0026 goToFridge();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 조건문과 논리 OR를 함께 사용하세요.\n\nundefined를 얻지 않도록 불필요한 변수를 선언하지 마세요:\n\n```js\nfunction doSomething(arg1){ \n    arg1 = arg1 || 32; // arg1이 이미 설정되지 않았다면 32로 설정\n}\n```\n\n5. 쉼표 연산자.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쉼표 연산자는 각 피연산자를 왼쪽에서 오른쪽으로 평가하고 마지막 피연산자의 값 반환합니다:\n\n```js\nlet x = 1;\nx = (x++, x);\nconsole.log(x); // 예상 결과: 2\nx = (2, 3);\nconsole.log(x); // 예상 결과: 3\n```\n\n6. length를 사용하여 배열의 크기를 조정합니다.\n\n크기 조정 또는 배열 비우기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvar array = [11, 12, 13, 14, 15];  \nconsole.log(array.length); // 5   \narray.length = 3;   \nconsole.log(array.length); // 3   \nconsole.log(array); // [11, 12, 13]\narray.length = 0;   \nconsole.log(array.length); // 0   \nconsole.log(array); // []\n\n7. Swap values using array destructuring.\n\nSwap values without using a temporary variable:\n\nlet a = 1, b = 2;\n[a, b] = [b, a];\nconsole.log(a); // -\u003e 2\nconsole.log(b); // -\u003e 1\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n배열의 요소들을 섞어보세요.\n\n배열 요소들을 무작위로 섞어보세요:\n\nvar list = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconsole.log(list.sort(function() {\n    return Math.random() - 0.5;\n}));\n// [4, 8, 2, 9, 1, 3, 6, 5, 7]\n\n9. 동적 속성 이름.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n객체를 선언하기 전에 동적 속성을 할당해 보세요:\n\nconst dynamic = 'color';\nvar item = {\n    brand: 'Ford',\n    [dynamic]: 'Blue'\n}\nconsole.log(item);\n// { brand: \"Ford\", color: \"Blue\" }\n\n10. 고유한 값을 필터링하세요.\n\nES6를 즐기는 분들을 위해, Spread 연산자를 사용하여 Set 객체를 활용해 새로운 배열을 만들어 보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst my_array = [1, 2, 2, 3, 3, 4, 5, 5];\nconst unique_array = [...new Set(my_array)];\nconsole.log(unique_array); // [1, 2, 3, 4, 5]\n\n- 인수 객체는 함수 내에서 액세스할 수 있는 유사 배열 객체이며, 해당 함수에 전달된 매개변수의 값을 포함합니다. 그러나 배열 메서드가 없습니다. 다행히도 일반 배열로 변환할 수 있습니다:","ogImage":{"url":"/assets/img/2024-06-23-10PracticalJavaScriptTips_0.png"},"coverImage":"/assets/img/2024-06-23-10PracticalJavaScriptTips_0.png","tag":["Tech"],"readingTime":3},{"title":"Dangerjs를 사용한 코드 리뷰 작업 자동화 방법","description":"","date":"2024-06-23 13:09","slug":"2024-06-23-AutomatingCodeReviewChoresUsingDangerjs","content":"\n\n![이미지](/assets/img/2024-06-23-AutomatingCodeReviewChoresUsingDangerjs_0.png)\n\n우리 소프트웨어 엔지니어들은 코드 리뷰에 상당한 시간을 투자합니다. 그리고 그것이 중요한 활동인 이유는:\n\n- 코드를 릴리스하기 전에 잠재적인 버그를 감지할 수 있습니다.\n- 코드가 의도한 대로 작동하는지 확인할 수 있습니다.\n- 코드가 유지 관리 가능한지 확인할 수 있습니다.\n- 코드 품질, 단위 테스트 등과 같은 일관된 코딩 규칙을 유지할 수 있습니다.\n\n그러나 일부 코드 리뷰 부분은 자동화되지 않는 한 지루할 수 있습니다. 이러한 부분을 \"코드 리뷰 일\"로 분류할 수 있습니다. 몇 가지 예는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 만든 자가 풀 리퀘스트의 일부로 파일을 업데이트했는지 확인해주세요. 예: CHANGELOG.md와 package.json 파일들.\n- 새로 만든 함수에 테스트를 추가했는지 확인해주세요.\n- 풀 리퀘스트(PR)가 너무 큰지 확인해주세요.\n- 오타가 있는지 확인해주세요.\n\n우리는 풀 리퀘스트(PR) 크기를 작게 유지하거나 package.json 파일을 최신 상태로 유지하라고 계속 상기시키는 개발자가 되고 싶지 않아요. 동일한 PR 피드백을 반복할 때 코드 리뷰 일이 뚜렷해져요.\n\n우리는 PR이 해결하려는 실제 문제를 리뷰하는 데 더 많은 시간을 할애해야 해요. 그래서 코드 리뷰 일에 소비하는 시간을 최소화할 수 있어요.\n\n일상적인 작업들을 자동화하면 코드의 품질과 팀의 효율성이 향상될 거예요. 일상적인 일을 걱정할 필요가 적어지면, 비즈니스 로직과 잠재적 버그와 같은 중요한 부분을 리뷰하는 데 더 많은 시간을 쓸 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 위험 JS\n\n다행히도, 코드 리뷰를 자동화해 주는 무료 도구인 Danger가 있어요. Danger에는 루비용 Danger와 자바스크립트용 Danger(JS)와 같이 여러 버전이 있어요. 두 버전 모두 동일한 일을 처리해요. 당신이 선호하는 프로그래밍 언어를 선택해서 Danger 규칙을 작성할 수 있는 거에요. 이 글에서는 Danger JS를 사용할 거예요.\n\n이전 블로그 게시물에 있는 \"Danger란?\" 섹션을 읽어보면 Danger에 대한 간단한 소개를 볼 수 있어요.\n\n다음 섹션에서 Danger JS를 사용하여 자동화할 수 있는 몇 가지 일상적인 작업의 예시를 공유할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-AutomatingCodeReviewChoresUsingDangerjs_1.png\" /\u003e\n\n# PR에서 특정 파일 업데이트\n\n예를 들어, PR에서 CHANGELOG.md 및 package.json 파일을 업데이트하는지 확인합니다. JavaScript 라이브러리를 공유하는 경우, 해당 라이브러리의 변경 로그와 버전을 추적하는 것이 좋은 관행입니다.\n\n다음은 당신이 Danger 함수에서 수행할 수 있는 작업입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 당신의 PR에 변경 사항이 있는지 변경 로그 파일과 package.json 파일을 확인하세요.\n- 변경 사항이 없는 경우, 파일을 업데이트해야 함을 나타내는 코멘트를 PR에 남기세요.\n\n다음은 danger.systems/js에서 일부 샘플 코드입니다:\n\n```js\n// 앱 변경 사항에 대한 CHANGELOG 항목 추가\nconst hasChangelog = danger.git.modified_files.includes(\"changelog.md\")\nconst isTrivial = (danger.github.pr.body + danger.github.pr.title).includes(\"#trivial\")\r\n```\n\n```js\nif (!hasChangelog \u0026\u0026 !isTrivial) {\n  warn(\"변경 사항에 대한 변경 로그 항목을 추가해주세요.\")\n}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n차단 JS 확장 프로그램에는 변경 로그 파일을 추적하는 Danger JS 확장 프로그램 (danger-plugin-keepachangelog)도 있습니다. 이 확장 프로그램을 직접 사용할 수 있으므로 처음부터 기능을 작성할 필요가 없습니다.\n\n## 의도하지 않은 인쇄 문장\n\n로컬에서 변경 사항을 디버그하거나 테스트하기 위해 인쇄 문장을 사용합니다. 불행하게도 이러한 문장을 가끔 우리의 브랜치에 의도치 않게 커밋할 수 있습니다.\n\n메인 브랜치에서 불필요한 인쇄 문장을 제외하는 것이 좋은 실천 방법입니다. 중복되는 인쇄 문장은 앱이나 서비스를 실행할 때 소음을 더해 코드베이스가 디버깅하기 어렵게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 경우, 작성자나 검토자가 문제를 발견합니다. 그러나 불가피하게 몇 가지 문제는 여전히 누락될 수 있습니다. Danger JS를 사용하여 이 확인을 자동화해야 합니다.\n\n참고용 의사코드는 다음과 같습니다:\n\n```js\n// DangerJS를 사용하여 수정된 파일을 가져옵니다\nmodifiedFiles = getModifiedFiles()\nfor (modifiedFile in modifiedFiles) {\n    // 각 파일에 대해 추가된 diff를 가져옵니다\n    diffAddedForFile = getDiffAdded(modifiedFile)\n    // 각 diff 문자열에 print 문이 포함되어 있는지 확인합니다 (예: Go의 fmt.print 또는 JS의 console.log)\n    if (diffAddedForFile.includes('fmt.print')) {\n        warn('fmt.print가 감지되었습니다')\n    }    \n}\n```\n\nJavaScript를 사용하는 경우, 다른 대안적인 솔루션을 사용할 수 있어서 Danger 규칙을 처음부터 작성할 필요가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Danger JS 확장 기능: danger-plugin-noconsole.\n- ESLint의 no-console.\n\n## PR이 너무 큰지 확인하기\n\n우리는 PR을 가능한 한 작게 유지하고 싶습니다. 큰 PR은 인지 부담을 증가시킵니다. 작은 PR은 더 관리하기 쉬우며 리뷰하기도 쉽습니다. 때로는 PR 작성자에게 PR을 작은 조각들로 나누도록 상기해야 할 수도 있습니다.\n\n우리는 Danger JS 규칙을 작성하여 PR에서 변경된 라인 수를 세어볼 수 있습니다. 숫자가 지정된 \"크게 PR 임계값\"을 초과하면 PR을 작은 PR로 나누도록 의견을 남길 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n변경 라인 수 = 삭제된 라인 수 + 추가된 라인 수\n\n팀 전체에서 수용할 수 있는 큰 PR 임계값에 대해 합의해야 합니다. 팀이 처음에 충분히 좋다고 느끼는 임의의 임계값으로 시작하십시오. 제 경험상 500에서 600 값을 사용하는 것이 일반적입니다. 그런 다음 시간이 지남에 따라 세부 조정할 수 있습니다.\n\n다음은 https://danger.systems/js/에서 샘플 코드입니다:\n\n```js\nvar bigPRThreshold = 600;\nif (danger.github.pr.additions + danger.github.pr.deletions \u003e bigPRThreshold) {\n  warn(':exclamation: 큰 PR (' + ++errorCount + ')');\n  markdown('\u003e (' + errorCount + ') : 풀 리퀘스트 크기가 비교적 크게 보입니다. 여러 변경 사항이 포함된 경우 각각을 별도의 PR로 분리하면 더 빠르고 쉬운 검토를 할 수 있습니다.');\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신이 원하는 대로, 빅 PR 임계값에 대한 계산에 카운트되기를 원치 않는 파일을 제외할 수도 있어요. 예를들어, mock 파일을 제외하고 싶다면:\n\n```js\nconst linesCount = await danger.git.linesOfCode(\"**/*\");\n// mock 파일을 제외합니다\nconst excludeLinesCount = await danger.git.linesOfCode(\"**/*mock*\");\nconst totalLinesCount = linesCount - excludeLinesCount;\n```\n\n```js\nif (totalLinesCount \u003e bigPRThreshold) {\n  warn(\"대규모 PR입니다. 작은 PR로 분할해 보세요.\");\n}\n```\n\n## 마크다운 오타 확인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문서의 오타는 코드베이스에서 \"깨진 창문\"으로 이어질 수 있어요. 그것들을 무시해서는 안 돼요. 다행히도 오타를 확인하는 데 유용한 Danger JS 확장 프로그램이 이미 있어요: danger-plugin-spellcheck.\n\nGitHub 리포지토리에서의 샘플 사용법은 다음과 같아요:\n\n```js\n// dangerfile.js\nimport spellcheck from 'danger-plugin-spellcheck'\n```\n\n```js\nspellcheck({\n  ignore: ['Nachoz', 'Tacoz'],\n  ignoreFiles: ['README.md']\n})\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 긍정적인 규칙, 예를 들어 PR 작성자 칭찬\n\nDanger JS는 \"이것을 잊었어\" 타입의 규칙만 있는 것은 아닙니다. 당신은 dangerfile에 긍정적인 규칙을 추가하여 PR에서 동료들을 칭찬할 수 있습니다.\n\n예를 들어: 작성자가 추가한 코드보다 더 많은 코드를 제거했을 때, 칭찬을 해주는 것입니다. 이는 여러분의 팀이 코드 추가를 피해야 한다는 것이 아닙니다. 중복 코드를 제거할 수 있도록 팀을 격려하는 방법입니다. 덜한 코드, 덜한 유지 보수.\n\n간단한 if 블록을 사용하여 Danger JS에서 이를 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nif (danger.github.pr.deletions \u003e danger.github.pr.additions) {\n  message(`:thumbsup: 더 많은 코드를 삭제했군요!`);\n}\n```\n\n우리는 Danger JS의 긍정적 규칙에 대한 자세한 설명을 확인할 수 있습니다.\n\n## 누락된 테스트 확인\n\n얼마나 자주 이런 PR 피드백을 작성하고 받을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아마도 많이 할 것 같아요. 다시 한 번 하지 않아도 돼요.\n\n저희가 PR에서 테스트를 검토할 때 필요한 단계들이에요:\n\n- 새로운 기능 또는 메소드에 테스트가 필요한지 확인해요.\n- 테스트가 이미 존재하는지 확인해요 — 패턴 매칭.\n- 테스트가 우리가 테스트해야 하는 경로들을 커버하고 있는지 확인해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위험 JS를 사용하여 단계 2를 자동화할 수 있어요. 단계 1과 3을 자동화할 필요조차 없어요. 단계 2를 자동화하는 것이 더 직관적이고 많은 시간을 절약할 수 있어요.\n\n테스트 누락을 확인하는 것은 테스트 커버리지를 계산하는 것과 같지 않아요. 테스트 커버리지를 계산할 때, 빌드가 지정된 커버리지 임계값을 충족하지 못하면 실패해요.\n\n코드 리뷰 중에 테스트를 확인할 때 테스트 커버리지를 직접 계산하지 않아요. 대신 패턴을 찾아요. 예를 들어, Golang의 PR을 리뷰할 때:\n\n- 새로운 함수 GetUsers()가 있는 경우 Test_GetUsers()라는 연관된 테스트가 있는지 확인해봐요.\n- Test_GetUsers()가 누락된 경우, \"누락된 테스트를 추가하세요\"라는 피드백을 남겨주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 패턴 매칭 로직을 Danger JS를 사용하여 프로그래밍적으로 실행할 수 있어요. 그러려면 특정 명명 규칙을 따라야 해요.\n\n우리 Danger JS 코드에서 PR 내의 테스트를 찾는 단계는 아래와 같아요:\n\n- PR diff를 가져와요.\n- 새로 추가된 함수가 있는지 확인해요. 여기에는 정규식을 사용할 수 있어요.\n- 새로운 함수가 있다면, 해당 함수에 대한 테스트가 있는지 찾아요. 예를 들어, PR에서 새로 추가된 함수 GetUsers()를 발견했다면, 해당 함수에 대한 테스트 Test_GetUsers()를 찾아야 해요.\n- Test_GetUsers()가 존재하지 않는다면, PR에 주석을 남겨요.\n\n의사 코드는 다음과 같을 거에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// PR에 추가된 함수에서 누락된 테스트를 확인합니다:\naddedFunctionNames = []\ndiffs = []\nmodifiedFiles = getModifiedFiles()\nmodifiedTestFiles = getModifiedTestFiles()\ndiffs = modifiedFiles.map(m =\u003e getDiffAdded(m))\ntestDiffs = modifiedTestFiles.map(m =\u003e getDiffAdded(m))\nfor (diff in diffs) {\n    parsedFunctionName = parseFunctionNames(diff) \n    // 패턴이 일치하는지 확인합니다\n    testsFound = testDiffs.filter(diff =\u003e diff.includes(`test_${parsedFunctionName}`))\n    if (testsFound.length === 0) {\n        warn(`테스트 누락: ${parsedFunctionName}`)\n   }\n}\n```\n\nGoogle CloudBuild에서 Danger JS를 설정하는 것은 간단합니다. 자세한 내용은 이전 블로그 포스트를 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-23-AutomatingCodeReviewChoresUsingDangerjs_0.png"},"coverImage":"/assets/img/2024-06-23-AutomatingCodeReviewChoresUsingDangerjs_0.png","tag":["Tech"],"readingTime":7},{"title":"JavaScript로 정의되지 않은 객체에 속성을 자동으로 추가하는 방법","description":"","date":"2024-06-23 13:08","slug":"2024-06-23-HowtoAutomaticallyAddPropertiestoanObjectthatisUndefinedwithJavaScript","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoAutomaticallyAddPropertiestoanObjectthatisUndefinedwithJavaScript_0.png\" /\u003e\n\n가끔은 JavaScript로 정의되지 않은 객체에 속성을 자동으로 추가하고 싶을 때가 있습니다.\n\n이 글에서는 JavaScript로 정의되지 않은 객체에 속성을 자동으로 추가하는 방법을 살펴보겠습니다.\n\n# JavaScript로 정의되지 않은 객체에 속성을 자동으로 추가하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJavaScript에서 정의되지 않은 객체에 속성을 자동으로 추가하려면 hasOwnProperty 메서드를 사용하여 속성이 있는지 확인할 수 있습니다.\n\n해당 속성이 있으면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n\n만약 false를 반환하면, 원하는 값으로 속성 값을 설정할 수 있습니다.\n\n예를 들어, 다음과 같이 작성할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst test = {}\nif (!test.hasOwnProperty('hello')) {\n  test.hello = {};\n}\ntest.hello.world = \"Hello World!\"\n```\n\n우리는 hello 속성을 추가하고 싶은 test 객체를 가지고 있어요.\n\n!test.hasOwnProperty('hello')로 존재하지 않는지 확인해요.\n\n만약 그게 사실이라면, test.hello를 빈 객체로 설정해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 test.hello.world를 \"Hello World!\"로 설정해 봅시다.\n\nhasOwnProperty 메서드는 Object 생성자로부터 상속되므로 쉽게 재정의할 수 있습니다.\n\n따라서 정확한 hasOwnProperty 메서드를 항상 호출하도록 하려면 다음과 같이 작성할 수 있습니다:\n\n```js\nconst test = {}\nif (!Object.prototype.hasOwnProperty.call(test, 'hello')) {\n  test.hello = {};\n}\ntest.hello.world = \"Hello World!\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nObject.prototype.hasOwnProperty.call을 사용하여 test로 test.hasOwnProperty와 같은 작업을 수행할 수 있지만, 항상 Object 생성자에서 올바른 것을 호출한다는 것을 확인합니다.\n\n# 결론\n\nJavaScript로 정의되지 않은 객체에 자동으로 속성을 추가하려면 hasOwnProperty 메서드를 사용하여 속성이 있는지 확인할 수 있습니다.\n\n해당 속성이 존재하면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFalse가 반환되면 속성 값을 원하는 값으로 설정할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-HowtoAutomaticallyAddPropertiestoanObjectthatisUndefinedwithJavaScript_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoAutomaticallyAddPropertiestoanObjectthatisUndefinedwithJavaScript_0.png","tag":["Tech"],"readingTime":2},{"title":"env 파일 이제는 그만 둘 때  더 나은 대안 찾기","description":"","date":"2024-06-23 13:05","slug":"2024-06-23-Itstimetodeprecatetheenvfile","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-Itstimetodeprecatetheenvfile_0.png\" /\u003e\n\n반년마다 우리는 개발자들이 환경 변수를 관리하고 .env 파일을 사용해야 하는지에 대해 논의합니다. 이 논의는 주로 개발자들이 .env 파일 또는 기타 방법 또는 시크릿 매니저를 사용하여 환경 변수를 관리해야 하는지에 대한 것입니다. 짜증난 트윗부터 비디오와 블로그까지 많은 증거가 있어 보여주지만 많은 개발자들이 최적의 방법에 동의할 수 없다는 것을 나타낸다.\n\n명확히 말하자면, 나의 입장은 항상 \"적합한 도구가 있다\"는 것입니다. 간단하거나 샌드박스용 경우에는 .env 파일을 사용하는 것을 고려할 수 있습니다. 그러나 진지한 조직은 시크릿 매니저를 사용하여 전체 인프라 스택 및 개발 주기 전체에 걸쳐 변수를 효율적으로 관리하고 자동화해야 한다고 생각합니다. 이는 그들의 스택에서 .env 파일을 폐기하는 것을 의미합니다.\n\n# .env에 대한 내 의견은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n.env 파일을 사용하는 접근 방식은 zuverlässigekeit(신뢰성) 및 보안과 관련된 상당한 결함을 가지고 있다고 생각하지만 여기에서 자세히 설명하는 것과는 별개로, 이를 계속해서 사용하여 오래된, 부실한 개념을 앞세우는 데 대해 더 큰 문제를 느낍니다. 특히 클라우드 네이티브 컴퓨팅 시대를 고려할 때, 우수한 도구를 대면하여 오래된 개념을 보급하는 것은 더욱 부적절합니다. 요즘에는 각 소프트웨어 인프라 수직으로 필요한 목적에 맞는 도구가 있으므로, 오래된, 오류가 발생하기 쉬우며 비효율적인 방식을 대체하기 위한 새로운 산업 표준을 배우고 채택해야 합니다.\n\n.env가 오래된 이유는 인프라와 개발 주기의 차이점 때문이라고 생각합니다. 적어도 현재처럼 확장성이 더 낮고 넓어진 환경이 아니었다고 주장할 수 있습니다. 그런 \"단순한\" 컴퓨팅 환경에서 이러한 구성 파일을 사용하는 것이 더 타당했었습니다. 이 이유로, 나는 후에 더 설명할 것을 생각해도 간단한 사용 사례를 위해 .env 파일을 사용하는 것에 동의합니다. 왜냐하면 \"일에 적합한 적절한 도구\"가 필요한데, 간단한 작업에는 실제로 간단한 도구만 필요하기 때문입니다.\n\n그러나 오늘날의 컴퓨팅 환경은 근본적으로 다릅니다. 기술적으로는 수평적으로 확장 가능한 서비스를 지원하는 경향이 있으며, 이러한 서비스는 종종 마이크로 서비스 아키텍처, 컨테이너화 및 Kubernetes와 같은 오케스트레이션 도구를 사용하여 운영 환경에서 기계를 수평으로 확장합니다. 또한 캐싱, 로깅, 데이터베이스 및 저장소 솔루션에 의존하는 애플리케이션과 같은 종속 서비스의 수가 증가했습니다(AWS만이 각 소프트웨어 공급 사슬 수직으로 200개 이상의 서비스를 제공한다는 것은 비밀이 아닙니다). 현재는 CI/CD 및 \"임시\" 환경을 포함하는 더 정교한 개발 프로세스도 사용합니다. 전반적으로, 프로세스는 매우 확대됐으므로 대부분의 대규모 조직에서는 복잡한 시스템을 관리하고 최적화하기 위해 플랫폼 엔지니어와 같은 전문 인력을 고용합니다. - 이런 플랫폼 엔지니어들은 자신들의 환경 변수 관리를 더욱 체계적으로 하기 위해 전용 도구를 사용합니다. 이에 대해서 곧 다루어 보겠습니다.\n\n이전에 언급했듯이, \"일에 적합한 적절한 도구\"가 필요하며, 특히 오늘날의 환경에서 일의 성격은 확실히 변했습니다. 변수를 관리하는 문맥에서는 대규모 조직에서 복잡한 스택 전반에 걸쳐 조정되는 수천 개 또는 수십만 개의 변수에 대해 빠르게 이야기하게 됩니다. 따라서 이와 관련하여 귀하의 조직 전반에서 사용해야 할 것들에 대해 논의해 보겠습니다, 이미 채택하지 않았다면요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 시크릿 매니저란 무엇이며 환경 변수 관리에서의 역할은 무엇인가요?\n\n익숙하지 않은 분들을 위해, 시크릿 매니저의 개념에 대해 소개해드리겠습니다: 팀이 애플리케이션 구성 및 API 키, 데이터베이스 자격 증명과 같은 민감한 데이터를 관리하는 데 도움이 되는 전용 솔루션으로, “시크릿”을 관리하는 데 사용됩니다. 인기 있는 시크릿 매니저 예시로는 Infisical, HashiCorp Vault, 그리고 AWS Secret Manager, GCP Secret Manager, Azure Key Vault와 같은 주요 클라우드 제공업체가 있습니다.\n\n시크릿 매니저를 사용하는 주된 이점은 중앙 집중화를 통해 시크릿 확산을 막는 능력입니다. 시크릿 확산의 아이디어는 인프라가 다양한 클라이언트(개발자, 애플리케이션, CI/CD 파이프라인 등)를 가질 수 있고 각각이 자체 변수를 필요로 할 때, 많은 변수를 관리해야 하며 이는 보안 위험, 잘못된 구성, 오류의 가능성을 가져온다는 것입니다. 환경 변수의 진실의 원천을 도입함으로써, 시크릿 매니저는 많은 연관된 시나리오를 피할 수 있도록 도와줍니다:\n\n- 변수를 도입하고 업데이트에 대해 다른 팀 멤버에게 알리지 않는다. 그들이 개발을 진행하다가 누락된 변수와 관련된 버그에 부딪히게 된다.\n- 코드베이스에 변수를 추가하였지만 제품에는 추가하지 않은 채로 운영에 배포하는 경우, 제품 서비스를 다시 배포한 후 모두에게 잘 작동하지 않는 것을 발견할 수 있습니다.\n- 시크릿이 어떤 식으로 유출되었는지 알게 되지만, 사건을 조사하는 능력이 부족하여 그에 대한 다섯 가지 질문에 대답할 수 없게 됩니다.\n- 시크릿이 유출되고, 복잡한 인프라 내에서 그 위치가 명확하지 않아 즉시 폐기하지 못하는 경우가 발생하여, 확산이 발생합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떤 사람들에게는 관련성이 적을 수도 있지만 매우 흔하고 문제가 되는 상황들도 있습니다:\n\n- 지금까지 100명 넘는 엔지니어로 성장한 당신의 조직은 개발 주기의 다양한 영역에 접근 가능한 엔지니어들이 있습니다. 새로운 엔지니어들이 조직에 합류하고 떠날 때, 민감한 변수에 대한 직원의 접근을 효과적으로 허용/차단하고 모니터링하는 데 어려움을 겪고 있습니다. 더 나쁜 상황은 최근 해고된 직원이 회사의 프로덕션 데이터베이스에 여전히 접근할 수 있다는 것이 밝혀진다는 것입니다 (실제 이야기를 바탕으로 함).\n- 당신의 조직은 각 고객을 위해 별도의 멀티텐넌트 전용 클러스터 또는 인스턴스를 제공합니다. 각 클러스터/인스턴스는 자체 환경 변수 세트를 필요로 하며, 100,000명을 넘는 고객들의 변수를 추적하는 데 어려움을 겪고 있습니다.\n\n시크릿 늘어남에 대응하는 것 외에도, 시크릿 매니저는 많은 보안 및 운영상의 이점을 제공합니다: 특권이 있는 엔티티에게 변수에 대한 세밀한 접근을 분할, 주기적으로 변수를 회전하거나 트리거에 의해 회전, 플라이에 대한 일회성 데이터베이스 자격 증명 생성, 레코드 보관을 위해 변수 버전 관리/감사, 등과 같은 기능을 포함합니다.\n\n전반적으로, 시크릿 매니저를 응용 프로그램 구성 및 시크릿에 관한 모든 것을 효과적으로 관리하는 데 도움을 주기 위해 만들어진 목적에 맞는 도구로 생각할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 모두가 \"적절한 도구를 올바른 작업에 사용\"을 찾고 있습니다\n\n의견을 조율하기 전에, 적어도 한 가지 사항에 동의할 수 있다고 믿습니다: 우리는 \"작업에 적합한 적절한 도구\"를 사용하려고 합니다. 이는 간단한 작업을 처리하기 위한 최소한의 오버헤드를 도입하고 실제로 요구되는 복잡한 작업을 처리하기 위한 충분한 도구를 사용하겠다는 것을 의미합니다.\n\n환경 변수 관리의 맥락에서, 효율적이고 안전하게 변수를 관리하는 방법이나 도구를 원합니다. 또한 당사 조직의 가용 자원, 능력, 내부 정책 등의 가변적 제약 조건 하에 이를 수행하길 원합니다; 이는 예산, 인프라 복잡성, 팀 규모, 위협 모델 등을 포함합니다. 다르게 말하면, 환경 변수 관리를 최적화하기 위한 작업인 곳에 \"작업에 적합한 적절한 도구\"를 원합니다.\n\n# \"적절한 도구를 올바른 작업에 사용\"은 모두에게 다르게 적용됩니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 사람들이 환경 변수를 가장 잘 관리하는 방법에 대해 의견이 분분한 이유는 \"작업\" 정의가 다른 사람에게는 다르기 때문이라고 믿습니다. 결과적으로, 일부는 최소한의 추가 도구 사용으로 .env 파일을 사용할 것을 주장하고, 다른 사람들은 시크릿 매니저나 보다 정교한 도구가 필요하다는 데에 동의합니다.\n\n일반적인 상황을 설명하자면, 어떤 사람들에게는 \"작업\"이 Vercel에 배포된 단일 애플리케이션에 대해 2개의 환경(개발 및 프로덕션)을 가진 50개의 환경 변수를 관리하는 것을 의미할 수 있습니다. 한편, 다른 사람들에게는 \"작업\"이 수 천 개의 마이크로 서비스를 다중 클라우드 제공업체에 배포하고 온프레미스 구성 요소와 몇 개의 환경(개발, 스테이징, 프로덕션 또는 일회성 환경)에 걸쳐 50,000개 이상의 환경 변수를 조율하는 일을 의미할 수 있습니다. 이 서비스들은 고객을 대상으로 하는 애플리케이션이 아닐 수도 있고, 인프라 스택 내에서 지원 서비스일 수도 있습니다. 예를 들어, 애플리케이션은 데이터베이스, 스토리지, 모니터링/가시성 등을 위해 포스트그레SQL, 레디스, 프로메테우스 등의 서비스 조합에 의존할 수 있습니다.\n\n전자의 경우에는 개발 주기에 시크릿 스프롤(이전에 논의한)이 아직 존재하지 않기 때문에 시크릿 매니저를 도입하는 것이 의미가 없을 수 있습니다. 따라서, 이러한 규모의 팀은 처음부터 굳이 도입할 필요가 없기 때문에 시스템에 오버헤드를 도입하는 것으로 인해 더 높은 재정 및 운영 비용을 부담해야 할 수 있습니다. 그러나 후자의 경우에는 \"작업\"의 거대한 규모 때문에 운영자들이 시크릿 스프롤과 그로 인한 잠재적인 결과에 직면하게 될 것이며, 이를 적절히 대응하지 않을 경우 심각한 다운타임과 재정적 부담이 발생할 수 있습니다. 수천개의 시크릿에 의존하는 인프라 상황에서는 잘못 관리된 시크릿(누락, 노출된 등)이 심각한 다운타임과 재정적 부담을 유발할 수 있으므로, 시크릿 관리의 확률을 최소화할 수 있는 도구를 도입함으로써 장기적으로 상당한 재정 및 운영 비용을 절감할 수 있습니다. 그러나 일반적으로, 우리는 모두 어느 정도는 클라우드 네이티브 컴퓨팅 시대의 일부이기 때문에, 오늘날의 \"작업\"은 결국 더 많은 서비스를 도입함으로써 필연적으로 더 복잡해질 것으로 생각됩니다.\n\n오늘날 더 정교한 환경 변수 관리 도구가 필요한 더 구체적인 예시는 현대 은행 인프라에서 발생합니다. 여기서는 핵심 은행 및 대출 발행 등을 포괄하는 시스템이 복잡하며 규정 및 보안 문제로 인해 멀티 클라우드 및 온프레미스로 구성되어 시크릿 스프롤에 직면하는 경우가 일반적입니다. 애플리케이션/서버 구성의 실수가 수백만 명의 은행 고객에게 지불에 영향을 미칠 수 있기 때문에 오류 허용 여부가 낮으며, 그 결과 환경 변수를 잘못 관리하는 가능성을 낮추기 위해 시크릿 매니저를 사용하는 것은 장기적으로 중요한 비용 절감을 이끌어낼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n고유한 케이스 스펙트럼에 따라 각각의 요구 사항이 다르므로, \"일에 알맞은 적절한 도구\"는 작업의 규모와 함께 조절됩니다. 언제나 도구 선택은 조직의 사용 가능한 자원, 능력 및 적응해야하는 정책을 고려해야 합니다.\n\n# 가끔은 \"일\"로 다른 사람들의 작업을 관리해야 할 때가 있습니다\n\n사용자를 위해 자사의 서비스 뿐만 아니라 멀티 테넌트, 전용 서비스도 관리해야 하는 경우라면 많은 환경 변수를 관리해야 하는 사용 사례가 매우 흔합니다.\n\n한 가지 예를 들어보겠습니다. SaaS 플랫폼을 구축하고 다른 조직에게 판매하는 경우를 상상해보세요. 자신의 플랫폼을 공유 클러스터로 구축하여 노드 간에 적용된 환경 변수를 하나의 세트로 제공하는 대신에, 이제 각 고객에게 플랫폼의 전용 클러스터 또는 인스턴스를 제공하도록 인프라를 변경했다고 가정해 봅시다. 이 새로운 모델에서 각 클러스터는 고유한 환경 변수 세트가 필요합니다. 관리해야 할 조직이 1만개일 경우, 각 조직의 클러스터를 위한 비밀 관리를 체계화하고 자동화할 일정 수준의 구조가 필요하다는 것을 빨리 깨닫게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보통 비록 특이해 보일지라도, 이 사용 사례는 GitHub, MongoDB, Fly.io 등 다양한 플랫폼에 매우 관련이 높습니다. 예를 들어 Fly.io는 풀 스택 앱 및 데이터베이스를 실행하는 플랫폼으로, 여기에서 플랫폼을 통해 배포된 애플리케이션의 환경 변수/시크릿을 어떻게 관리하는지 공개적으로 문서화하고 있습니다. 이 경우에는 \"시크릿이 암호화된 보관소에 저장\"되며, \"flyctl을 통해 시크릿을 설정하면 시크릿 값이 우리의 API를 통해 전송되어, Fly 앱에 대한 보관소로 기록됩니다. API 서버는 암호화만 할 수 있고, 시크릿 값을 해독할 수는 없습니다. 시크릿 값은 절대 기록되지 않습니다.\"\n\n이 사용 사례에서 배울 수 있는 점은 전문화된 보관소나 시크릿 매니저를 사용하여 인프라를 프로비저닝한다는 것이며, API(프론트엔드 UI에 연결되는)는 시크릿에 대한 쓰기 액세스만을 갖고 있고, 아마도 Fly.io의 응용 프로그램을 배포하는 인프라 영역은 응용 프로그램을 읽을 수 있는 능력을 가지고 있다는 것입니다. 수백만 개의 앱의 시크릿을 관리하는 데 도움을 주는 동시에, 시크릿 매니저는 기반이 되는 시스템의 보안을 최적화하기 위해 필요한 안전한 세분화된 권한 시스템을 제공합니다.\n\n# 언제 시크릿 매니저를 사용하는 것이 적절한가요?\n\n일반적으로, 조직이 시크릿 매니저가 필요하다고 판단하는 것은 시크릿 매니저 없이 작업하는 것이 고통스러워질 때입니다. 그렇지만 적정한 타이밍을 결정하는 데 도움이 되는 두 가지 지표는 시크릿이 널리 퍼지기 시작하고 회사가 인프라에 더 관심을 기울이기 시작할 때입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 알아차릴 수 있었을 것으로 생각되는대로, 시크릿 관리자가 필요한 정도는 개발자, CI/CD 파이프라인, 및 변수에 액세스해야 하는 애플리케이션 등의 클라이언트 수에 많이 의존합니다. 일반적으로 그 숫자가 충분히 많아지고 연관된 시크릿 확산이 문제가 될 때, 혼돈을 완화하기 위해 전용 도구를 도입하고 싶어할 것입니다.\n\n둘째로, 귀하의 조직이 기술 제품을 운영하고 있다고 가정하면, 시크릿 관리자의 필요성은 주로 인프라에 투자하기 시작했을 때 형성됩니다. 이러한 투자의 성격은 구체적인 기능을 구축하는 데보다는 고객 서비스의 원활한 배포, 테스트, 시스템 신뢰성 등을 보장하는 데 더 관련이 있습니다. 5명 또는 20명의 엔지니어가 되었을 때, 언젠가는 DevOps 엔지니어가 투자의 일환으로 팀에 고용될 것입니다. 이 시점에서 엔지니어는 개발 주기에 시크릿 관리를 포함한 모범 사례를 도입하기 시작할 것입니다.\n\n이러한 지표를 넘어서, 모든 규모와 산업의 기업이 시크릿 관리를 실시한다는 사실을 알 수 있습니다. 규모 구상 계획을 시작하는 5~10명의 팀부터 시크릿 확산을 잡기 위해 필요한 1,000명 조직까지, 시크릿 관리자를 사용하는 기업의 수는 많으므로 일찍 채택하는 데 두려워하지 마세요.\n\n# 그런데... 인터넷에서는 시크릿 관리자가 필요 없다고 생각하는 사람도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔직히 말해서, 모든 산업 전반에 걸친 소프트웨어 도구 카테고리는 지지자와 반대자가 있습니다. 공급망에서 비밀 관리 소프트웨어를 포함한 다양한 도구 집합이 \"필요하지 않다\"는 이유로 채택하지 말아야 한다고 주장할 수는 있지만, 그 도구들이 산업 전반에 표준으로 자리 잡고 있다는 점에 대해 당신은 틀렸습니다. 사실은 목적에 특화된 개발자 도구는 소프트웨어 스택 및 개발 프로세스를 개선하고, 제품 제공과 직접적으로 관련이 없는 항목들을 전문적으로 제공하는 업체에게 외부로 전담하여 도와줍니다. 예를 들어,\n\n- 관측 가능한 로깅 도구를 도입하는 것은 불필요하다고 주장할 수 있습니다. 왜냐하면 로그를 자체 호스팅된 오픈 소스 데이터베이스 인스턴스로 전달하고 로그를 직접 쿼리할 수 있기 때문입니다.\n- 키 관리 시스템을 도입하는 것이 불필요하다고 주장할 수 있습니다. 왜냐하면 애플리케이션 수준에서 환경 변수로 저장된 키를 사용하여 직접 데이터의 암호화/해독을 할 수 있기 때문입니다.\n- 당연히 비밀 관리 도구를 도입하는 것은 불필요하다고 주장할 수 있습니다. 왜냐하면 .env 파일을 사용하거나 소스 컨트롤로 직접 공유 변수의 암호화/해독을 할 수도 있기 때문입니다.\n\n이론적으로는 위의 해결책을 직접 구현하여 사용할 수 있지만, 그럴 경우 각자의 문제점을 안고 있을 것입니다. 주요 장점을 잃거나 프로세스의 최적화를 잃게 되거나, 마지막에는 해당 소프트웨어 스택의 일부에 대해 전용 도구를 채택하는 것보다 해당 부분을 자체적으로 개발하는 데 더 많은 시간을 투자하게 될 것입니다.\n\n비밀 관리의 맥락에서, 이것은 저만의 권고가 아닌 업계 전체에서 채택되는 인프라 실천 방식 및 도구입니다. 비밀 퍼지기가 심각한 문제로 여겨질 때 특정 규모에 도달한 조직이 채택하는 것입니다. 제가 말하는 게 마구잡이 광고가 아니라 그것은 주요 클라우드 제공 업체들이 자사의 비밀 관리 제품을 보유하거나 GitHub나 Ubisoft와 같은 조직들이 어떻게 비밀 관리자를 사용하는지 알아보는 것을 통해 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 좋은데… 하지만 도구의 안전성은 어떻게 되나요?\n\n당연히 시크릿 관리에 대한 새로운 이용자들은 API 키와 데이터베이스 자격 증명을 신뢰할 수 있는 제3자가 관리할 수도 있는 서비스에 전달하는 것에 대해 유효한 보안 우려가 있습니다. 알다시피, 제3자의 서비스는 여러 액세스 토큰을 한꺼번에 훔치기를 원하는 나쁜 행위자들에게 주로 대상이 될 수 있습니다. 플랫폼 코드에 보안 취약점이 포함되어 있다면 침입당할 수 있고 … 그 이후 일들은 엉망이 될 수 있습니다.\n\n이러한 우려를 고려하여 아래에 몇 가지 생각을 정리해 보았습니다:\n\n- 모든 변수를 하나의 도구에 저장하면 해당 도구가 침해당하면 모든 변수가 유출될 수 있다고 걱정하실 지도 모릅니다. 이는 정당한 우려이지만, 모든 시크릿 매니저는 조직 수준과 제품 수준 모두 최고 수준의 보안을 보장하기 위한 중요한 조치들을 시행한다는 점을 알아야 합니다. 보통 이에는 보안 감사, 인증, 침투 테스트, 특정 기능 (예: 인증/인가 제어, IP 제한과 관련된 토큰 바인딩 제한; TTL; 그리고 더 많은 것들) 등이 포함됩니다. 시크릿 관리 워크플로에 적용할 수 있는 맞춤화와 레이어링이 얼마나 많은지 깜짝 놀랄 것입니다. 마지막으로, 이에 대해 항상 믿을 수 있는 또는 잘 알려진 공급업체를 사용하는 것을 권장합니다. 시크릿 관리는 본질적으로 매우 민감한 영역이므로요.\n- 특히 나쁜 행위자들을 위한 주요 대상이 될까봐 걱정하실 수도 있습니다. 이에 대해, Infisical 및 Vault와 같은 오픈 소스 솔루션들을 살펴보는 것을 강력히 추천드립니다. 이러한 솔루션들은 클라우드 인프라나 온프레미스에 배포하여 다른 사람의 대상이 되는 것을 방지할 수 있습니다.\n- 마지막으로, 규모 확장에 따른 시크릿 분산과 관련된 위험을 다루는 것이 문제를 완화하는 전용 도구를 사용하는 것보다 훨씬 나을 수 있습니다. 아직 느끼지 못했을지 모르겠지만, 문제가 자연스럽게 발생하면 알게 될 것입니다. 여기서 사용하는 비유는 시크릿 관리자를 패스워드 관리자에 비교하는 것인데, 많은 암호를 관리해야 할 때 더 유용해집니다. 사용하기 전에 여러 서비스에 걸친 약간의 패스워드에 만족했으며 때때로 암호를 잊어버린 적이 있어 암호 복구 과정을 거쳐 서비스 로그인을 재설정했었습니다. 그렇지만, 서로 다른 암호 요구 사항을 충족시키는 각 암호의 수가 증가함에 따라, 각 조합을 수동으로 추척하고 효과적으로 패스워드 분산에 직면하게 되었습니다. 이것은 나에게 비밀번호 관리자에 가입하도록 설득하였고, 그 이후로는 되돌아보지 않았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최종적으로, 비밀 노출 문제에 직면할 때 보안 정보가 널리 퍼지는 상황을 고려할 때 비밀 관리자를 사용하는 필요성이 그것이 없는 것에 비해 더 높습니다. 따라서 신뢰할 수 있는 솔루션을 채택하고 권장된 보안 제어를 구현해야 합니다. 해결책 구성이든 개발 주기 전체에서 변수를 최상의 방법으로 검색하는 워크플로 권장사항이든 상관없이요.\n\n# 알겠어. 난 설득됐어. 비밀 관리자를 어떻게 사용하는지 보여줘, 코드 좀 줘봐\n\n일을 간단하게 유지하기 위해, Infisical을 사용할 거야. 이 오픈 소스 비밀 관리 플랫폼을 사용할 텐데. Vault나 AWS Parameter Store와 같은 다른 비밀 관리자도 사용할 수 있는데, Infisical을 선택한 이유는 빠르게 구동할 수 있고, 자체 인프라에서 호스팅할 수 있으며 잘 문서화되어 있기 때문이야.\n\n![그림](/assets/img/2024-06-23-Itstimetodeprecatetheenvfile_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어쨌든, 이 간단한 예제를 통해 런타임에 환경 변수를 가져오기 위해 Node SDK를 사용할 것입니다. 그러나 환경 변수를 API 호출을 통해 가져오거나, 다른 SDK(파이썬, 자바, C# 등), CLI, 쿠버네티스 오퍼레이터, 인피지컬 에이전트 등의 다른 메서드도 사용할 수 있습니다. 이는 당신의 스택 및 개발 주기와 같은 여러 요인에 따라 당신에게 더 적합할 수 있습니다.\n\n그럼 시작해봅시다.\n\n먼저, 프로젝트에 패키지를 설치하세요:\n\n```js\n$ npm install @infisical/sdk\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로 SDK를 가져와서 기계 식별 유니버설 인증 자격증명으로 클라이언트 인스턴스를 생성하세요.\n\n```js\nimport { InfisicalClient, LogLevel } from \"@infisical/sdk\";\n\nconst client = new InfisicalClient({\n    clientId: \"YOUR_CLIENT_ID\",\n    clientSecret: \"YOUR_CLIENT_SECRET\",\n    logLevel: LogLevel.Error\n});\n```\n\n최적의 성능을 보장하기 위해 클라이언트의 단일 인스턴스를 생성하고 전체 앱에서 사용하도록 내보내는 것을 권장합니다. SDK는 주기적으로 업데이트될 수 있는 비밀을 캐시할 수 있기 때문에 불필요한 호출을 줄이고, 이 내장 캐싱은 환경 변수를 대규모로 동기화하는 것을 원활하게 만듭니다.\n\n이제 클라이언트를 사용하여 애플리케이션에 필요한 비밀을 필요에 따라 가져올 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\napp.get(\"/\", async (req, res) =\u003e {\n    // 접근 값 설정\n\n    const name = await client.getSecret({\n        environment: \"dev\",\n        projectId: \"PROJECT_ID\",\n        path: \"/\",\n        secretName: \"NAME\"\n    });\n\n    res.send(`안녕하세요! 제 이름은: ${name.secretValue}`);\n});\n```\n\n이제 애플리케이션이 환경 변수를 필요로 할 때, 필요한 환경 변수를 Infisical로부터 요청할 수 있습니다. 이제 Node 애플리케이션의 모든 환경 변수를 한 곳에서 확인하고 누락된 환경 변수를 방지할 수 있습니다.\n\n이전에 언급했듯이, 이는 런타임 중에 애플리케이션을 위한 변수를 가져오기 위해 시크릿 매니저를 사용하는 방법의 미니멀한 예시입니다. 사용 사례에 따라, 또 다른 방법으로 시크릿 매니저와 프로그래밍 방식으로 상호 작용하는 것이 더 적합할 수 있습니다. 어떠한 경우에도, 이에 관심이 있다면 여기서 Infisical 문서를 참고해야 합니다.\n\n# 결론\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시크릿 매니저는 인프라스트럭처 공간에 처음 입문하는 사람들에게 종종 오해받는 도구지만, 복잡한 인프라 작업을 간소화하고 여러 변수에 의존하는 조직에게 매우 관련이 있습니다. 클라우드 네이티브 컴퓨팅 시대에는 전형적인 인프라가 수백 개 이상의 분산된 서비스 및 복제로 구성되어 있기 때문에, 작업에 적합한 도구를 배우고 사용하는 것이 중요합니다.","ogImage":{"url":"/assets/img/2024-06-23-Itstimetodeprecatetheenvfile_0.png"},"coverImage":"/assets/img/2024-06-23-Itstimetodeprecatetheenvfile_0.png","tag":["Tech"],"readingTime":13},{"title":"웹 컴포넌트에서 커스텀 상태의 숨겨진 힘","description":"","date":"2024-06-23 13:03","slug":"2024-06-23-TheHiddenPowerofCustomStatesForWebComponents","content":"\n\n사용자 정의 요소의 진화 과정에서 중요한 단계\n\n![image](/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png)\n\n이전에 썼던 \"웹 컴포넌트가 이제 네이티브 폼 요소가 될 수 있게 되었고\"와 \"웹 컴포넌트의 네이티브 폼 유효성 검사\"라는 기사에서, ElementInternals 속성에 대해 설명했었어요. 이 속성을 통해 사용자 정의 요소가 양식과 관련되도록 할 수 있게 되었죠.\n\n이 인터페이스는 또한 개발자들이 사용자 정의 상태와 사용자 정의 요소를 연관시킬 수 있도록 하며, 이 상태에 기반하여 스타일을 입힐 수 있게 해줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nElementInternals의 states 속성은 사용자 지정 요소가 있는 상태를 나타내는 CustomStateSet을 반환합니다. 이 CustomStateSet은 집합에 추가 및 제거를 가능하게 합니다.\n\n집합의 각 상태는 문자열로 표시되며 현재 그에는 두 가지 유형의 구문이 있습니다:\n\n- 이전 구문: --mystate (향후 지원 중단 예정)\n- 새로운 구문: mystate\n\n이러한 상태는 내장된 상태와 마찬가지로 사용자 지정 상태 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 선택된 체크박스는 내장된 :checked 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.\n\n```js\ninput[type=”checkbox”]:checked {\n outline: solid green;\n}\n```\n\n다른 예로, 비활성화된 버튼은 :disabled 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.\n\n```js\nbutton:disabled {\n cursor: not-allowed;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비슷하게, 사용자 정의 상태를 포함하는 요소는 다음과 같은 방식으로 CSS에서 액세스할 수 있습니다:\n\n```js\n/* 이전 구문 */\nmy-element:--mystate {\n  color: red;\n}\n\n/* 새 구문 */\nmy-element:state(mystate) {\n  color: red;\n}\n```\n\n# 사용자 정의 상태의 사용 사례\n\n사용자 정의 상태는 강력한 기능을 해제합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내부 상태에 기반을 둔 Web Components의 스타일링을 지원하기 때문에 이러한 상태를 반영하기 위해 컴포넌트에 속성이나 클래스를 추가할 필요가 없어요. 따라서 완전히 내부적으로 유지됩니다.\n\n예를 들어, `video-player` 컴포넌트가 있고 이 컴포넌트는 비디오를 재생하는 데 사용되는 재생 버튼을 표시합니다.\n\n재생 버튼을 클릭하면 비디오가 재생되고, 이 때 재생 버튼이 숨겨지고 일시 정지 버튼이 표시되기를 원합니다.\n\n그런 후 일시 정지 버튼을 클릭하면 이 버튼이 숨겨지고 재생 버튼이 다시 표시되어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n이 작업을 간단히 수행하는 방법은 플레이 속성을 소개하고 해당 속성을 반영하고 :host 가상 클래스를 사용하여 버튼을 표시하거나 숨기는 것입니다.\n\n```js\nclass VideoPlayer extends HTMLElement {\n\n  constructor() {\n    super();\n\n    const shadowRoot = this.attachShadow({mode: 'open'});\n\n    shadowRoot.innerHTML = `\n      \u003cstyle\u003e\n        :host {\n          display: block;\n          width: 300px;\n          height: 300px;\n          border: 2px solid red;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          background-color: transparent;\n        }\n\n        #pause {\n          display: none;\n        }\n\n        :host([playing]) #play {\n          display: none;\n        }\n\n        :host([playing]) #pause {\n          display: block;\n        }\n      \u003c/style\u003e\n\n      \u003cbutton id=\"play\" type=\"button\"\u003ePlay\u003c/button\u003e\n      \u003cbutton id=\"pause\" type=\"button\"\u003ePause\u003c/button\n    `;\n  }\n\n  connectedCallback() {\n    const playButton = this.shadowRoot.querySelector('#play');\n    const pauseButton = this.shadowRoot.querySelector('#pause');\n\n    playButton.addEventListener('click', () =\u003e {\n      this.playing = true;\n    });\n\n    pauseButton.addEventListener('click', () =\u003e {\n      this.playing = false;\n    });\n  }\n\n  get playing() {\n    return this.hasAttribute('playing');\n  }\n\n  set playing(isPlaying) {\n    if(isPlaying) {\n      this.setAttribute('playing', '');\n    }\n    else {\n      this.removeAttribute('playing');\n    }\n  }\n}\n```\n\n기본적으로 재생 버튼이 표시됩니다. 플레이 속성을 위한 설정자가 정의되어 해당 속성을 설정하거나 제거하며 CSS 규칙은 :host 가상 클래스를 사용하여 버튼을 표시하거나 숨기는 역할을 합니다.\n\n아래에 작동하는 예제가 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법은 잘 작동하지만 이 구현에 잠재적인 문제가 있을 수 있어요.\n\n이렇게 내부 속성을 속성으로 노출하는 것은 항상 바람직하지 않을 수 있고 캡슐화를 깨버릴 수 있어요.\n\n이 경우 playing 속성을 노출하는 것은 나쁜 생각은 아닐 수 있지만, 이는 사용자가 그냥 속성을 추가함으로써 컴포넌트를 재생 상태로 수동 설정할 수 있지만, 실제로 비디오가 재생되는 것은 아니라는 점이에요.\n\n이 속성을 노출함으로써 사용자가 playing 속성을 추가하기만 하면 비디오를 재생할 수 있다는 기대감조차 줄 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사실 특정 상태의 웹 컴포넌트를 설정하기 위해 속성을 추가하는 것은 해당 상태를 설정하는 것이 아니기 때문에 playing 속성을 true로 설정하지 않습니다. playing 속성에 playing 속성을 추가하는 것만으로 playing 속성을 true로 설정하지는 않습니다.\n\n이 경우 실제로 심각한 피해를 입히지는 않겠지만 내부 속성을 노출하는 것이 좋지 않은 경우가 항상 있을 수 있습니다.\n\n이것은 사용자 정의 상태에 대한 완벽한 사용 사례입니다. 속성은 노출되지 않지만 이러한 상태에 기반한 CSS 스타일을 사용하여 컴포넌트를 여전히 스타일링할 수 있습니다.\n\n# 사용자 정의 상태 추가 및 제거\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n언급한 바와 같이 모든 사용자 지정 상태는 ElementInternals 인터페이스의 states 속성에 저장된 CustomStateSet 객체에 저장됩니다.\n\n상태를 추가하고 제거하는 데 사용되는 add 및 delete 메서드와 요소가 특정 상태를 갖고 있는지 확인하는 has 메서드가 있습니다.\n\n다른 주목할 만한 메서드로는 모든 상태를 지우는 clear 및 요소의 모든 상태를 반복하는 forEach가 있습니다:\n\n```js\n// 내부 구현 부착\nthis.internals = this.attachInternals();\n\n// 상태 추가 예전 문법\nthis.internals.states.add('--foo');\n\n// 상태 추가 새 문법\nthis.internals.states.add('bar');\n\n// 상태 반복\nthis.internals.states.forEach(state =\u003e {\n console.log(state); // foo bar\n});\n\n// 상태 제거 예전 문법\nthis.internals.states.delete('--bar');\n\n// 상태 제거 새 문법\nthis.internals.states.delete('bar');\n\n// 상태 존재 여부 확인 예전 문법\nthis.internals.states.has('--foo'); // true\nthis.internals.states.has('--bar'); // false\n\n// 상태 존재 여부 확인 새 문법\nthis.internals.states.has('foo'); // true\nthis.internals.states.has('bar'); // false\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n브라우저에서 오래된 구문만 지원하는 경우 --로 시작하지 않는 상태를 추가하려고 할 때 오류가 발생합니다:\n\n```js\nthis.internals = this.attachInternals();\nthis.internals.states.add('foo'); // 오류, '--'로 시작하지 않음 (오래된 구문만 지원)\n```\n\n이전 예제가 사용자 정의 상태와 함께 작동하도록 하려면 `playing` 속성의 게터 및 세터를 상태와 함께 작동하도록 변경해야 합니다. 이를 오래된 및 새로운 구문을 지원하는 브라우저에서 작동하도록 하려면 --없이 상태를 설정하는 것은 try/catch 블록으로 감싸야 합니다:\n\n```js\nget playing() {\n  return this.internals.states.has('--playing') || this.#internals.states.has('playing');\n}\n\nset playing(isPlaying) {\n  if(isPlaying) {\n    try {\n      this.internals.states.add('playing');\n    }\n    catch(e) {\n      this.internals.states.add('--playing');\n    }\n  }\n  else {\n   this.internals.states.delete('playing');\n   this.internals.states.delete('--playing');\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경했습니다.\n\n```js\n/* 이전 구문 */\nhost(:--playing) #play {\n  display: none;\n}\n\n/* 이전 구문 */\n:host(:--playing) #pause {\n  display: block;\n}\n\n/* 새로운 구문 */\nhost(:state(playing)) #play {\n  display: none;\n}\n\n/* 새로운 구문 */\n:host(:state(playing)) #pause {\n  display: block;\n}\n```\n\n내부 속성이 속성으로 노출되지 않도록 하는 것은 좋지만, 여전히 소비자가 내부 속성을 통해 상태에 액세스하고 add 및 delete 메서드를 호출하여 상태를 추가하거나 제거할 수 있습니다:\n\n```js\nconst player = document.querySelector('video-player');\n\n// 이전 구문\nplayer.internals.states.add('--playing');\n\n// 새로운 구문\nplayer.internals.states.add('playing');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 좋지 않은 점은 소비자가 내부 상태를 변경하기 위해 playing의 setter를 호출할 수 있다는 것입니다.\n\n이를 수정하여 getter와 setter 및 내부 속성을 모두 #으로 접두사를 붙여 private로 만들 수 있습니다:\n\n```js\n// internals is now private\nthis.#internals = this.attachInternals();\n\nget playing() {\n  return this.#internals.states.has('--playing') || this.#internals.states.has('playing');\n}\n\nset playing(isPlaying) {\n  if(isPlaying) {\n    try {\n      this.#internals.states.add('playing');\n    }\n    catch(e) {\n      this.#internals.states.add('--playing');\n    }\n        \n  }\n  else {\n   this.#internals.states.delete('playing');\n   this.#internals.states.delete('--playing');\n  }\n}\n```\n\nprivate 속성에 대한 getter와 setter 쌍을 작성하는 것이 직관적이지 않을 수 있지만, 이것이 실제로 작동한다는 것에 주목하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비록 playing에 getter와 setter가 정의되어 있지만, 여전히 private이며 클래스 내에서만 접근 가능합니다.\n\n값을 할당하면 setter가 호출되고 값을 읽으면 getter가 호출됩니다.\n\n아래에 전체 코드가 있습니다:\n\n```js\nclass VideoPlayer extends HTMLElement {\n  #internals;  // private property를 필요로 하는 클래스 필드\n\n  constructor() {\n    super();\n\n    const shadowRoot = this.attachShadow({mode: 'open'});\n\n    this.#internals = this.attachInternals();\n\n    shadowRoot.innerHTML = `\n      \u003cstyle\u003e\n        :host {\n          width: 300px;\n          height: 300px;\n          border: 2px solid red;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          background-color: transparent;\n        }\n\n        #pause {\n          display: none;\n        }\n\n        /* 예전 문법 */\n        :host(:--playing) #play {\n          display: none;\n        }\n\n        :host(:--playing) #pause {\n          display: block;\n        }\n\n        /* 새로운 문법 */\n        :host(:state(playing)) #play {\n          display: none;\n        }\n\n        :host(:state(playing)) #pause {\n          display: block;\n        }\n      \u003c/style\u003e\n\n      \u003cbutton id=\"play\" type=\"button\"\u003e재생\u003c/button\u003e\n      \u003cbutton id=\"pause\" type=\"button\"\u003e일시정지\u003c/button\u003e\n    `;\n  }\n\n  connectedCallback() {\n    const playButton = this.shadowRoot.querySelector('#play');\n    const pauseButton = this.shadowRoot.querySelector('#pause');\n\n    playButton.addEventListener('click', () =\u003e {\n      this.#playing = true;\n    });\n\n    pauseButton.addEventListener('click', () =\u003e {\n      this.#playing = false;\n    });\n  }\n\n  get playing() {\n    return this.#internals.states.has('--playing') || this.#internals.states.has('playing');\n  }\n\n  set playing(isPlaying) {\n    if(isPlaying) {\n      try {\n        this.#internals.states.add('playing');\n      }\n      catch(e) {\n        this.#internals.states.add('--playing');\n      }\n    }\n    else {\n      this.#internals.states.delete('playing');\n      this.#internals.states.delete('--playing');\n    }\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 여기에는 오래된 구문과 새 구문 둘 다 작동하는 작동 예제가 있습니다:\n\n이 예제들은 커스텀 상태에 기반하여 커스텀 요소를 내부 컴포넌트 내에서 :host 가상 클래스를 사용하여 스타일링하는 방법을 보여줍니다.\n\n커스텀 요소는 사용자 정의 상태에 기반하여 외부에서 스타일링될 수도 있습니다.\n\n이 스타일링은 :checked나 :hover와 같은 내장 상태에 기반하여 구성 요소를 스타일링하는 것과 동일한 형태를 가지고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/* 예전 구문 */\nvideo-player:--playing {\n  border: 1px solid red;\n}\n\n/* 새로운 구문 */\nvideo-player:state(playing) {\n  border: 1px solid red;\n}\n```\n\n같은 CSS 속성에 대한 사용자 지정 상태를 기반으로 스타일 지정이 내부와 외부에서 모두 정의된 경우, 외부에서 정의된 스타일이 우선합니다.\n\n다음 예제에서 컴포넌트는 --playing/playing 사용자 지정 상태일 때 녹색 테두리가 추가됩니다.\n\n--playing/playing 상태에 대해 컴포넌트 내부에서 정의된 파란색 테두리는 덮어씌워집니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 컴포넌트 외부에서 정의된 스타일\n// 이렇게 하면 컴포넌트에 녹색 테두리가 우선적으로 적용됩니다.\n// 이전 구문\nvideo-player:--playing {\n  border: 2px solid green;\n}\n\n// 새로운 구문\nvideo-player:state(playing) {\n  border: 2px solid green;\n}\n\n// 컴포넌트 내부에서 정의된 스타일\n// 외부에서 정의된 스타일에 덮어씌워지게 됩니다.\n// 이전 구문\n:host(:--playing) {\n  border: 2px solid blue;\n}\n\n// 새로운 구문\n:host(:state(playing)) {\n  border: 2px solid blue;\n}\n```\n\n# 결론\n\n사용자 정의 상태(Custom States)는 웹 컴포넌트의 진화를 위한 중요한 단계입니다.\n\n이를 통해 컴포넌트의 상태를 속성이나 클래스를 추가하지 않고도 스타일링할 수 있어 외부에서 상태를 조작할 수 없도록 유지할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n커스텀 상태는 Chrome, Edge, Safari Tech Preview 187에서는 CustomStateSet 기능 플래그가 활성화되어 있고, Firefox 122에서는 dom.element.customstateset.enabled가 true로 설정되어 있을 때 지원됩니다.\n\n현대 웹 플랫폼, 웹 컴포넌트, 그리고 Progressive Web Apps에 관한 제 주간 뉴스레터 'Modern Web Weekly'에 가입해보세요.","ogImage":{"url":"/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png"},"coverImage":"/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png","tag":["Tech"],"readingTime":11},{"title":"상위 1 웹 개발자가 되기 위해 꼭 가져야 할 10가지 기술","description":"","date":"2024-06-23 13:02","slug":"2024-06-23-10must-haveskillstobecomeatop1webdeveloper","content":"\n\n\n![Image](/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_0.png)\n\n웹 개발자가 반드시 갖추어야 할 10가지 필수 기술…\n\n이미 알고 있을 수 있는 웹 기초부터 시작하여 브라우저 개발 도구를 활용하고 AI로 빠르게 코딩하는 것과 같은 중요한 기술까지 배워보세요.\n\n이론적 지식보다는 실제 행동에 초점을 맞춘 것을 알 수 있죠 — 왜냐하면 그것이 중요하기 때문입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. HTML essentials: Create a basic functional web page\n\n웹 사이트의 핵심 뼈대에 대해 알아보세요.\n\n다음과 같이 진행해보세요:\n\n- 편집기에서 HTML 페이지를 만들고 브라우저에서 엽니다\n- 페이지 제목 및 아이콘 설정\n- 텍스트 단락 만들기\n- 제목 만들기\n- 다른 페이지로 연결하는 링크 만들기\n- 이미지 표시\n- 테이블 데이터 표시\n- 요소 목록 표시\n- 폼을 사용하여 입력 처리\n- 주석 만들기 및 코드 주석 처리\n- 시맨틱 HTML로 페이지를 더 유의미하게 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 사람들은 CSS 때문에 시맨틱 HTML이 무의미하다고 생각하지만, 그들은 틀렸어요.\n\n접근성과 페이지 내용을 검색 엔진에 설명하여 결과 페이지에서 높은 순위를 얻는 데 여전히 중요합니다.\n\n\n![image](/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_1.png)\n\n\n시맨틱 요소가 없다면, 모든 것에 'div'를 사용하는 개발자들처럼 될 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. CSS 핵심: 웹 페이지 스타일링\n\n이렇게 변화시킬 수 있어요:\n\n![Before and after](/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/0*OjV0rbJN2AKW1VAh.gif)\n\n뼈대에 생명을 불어넣는 방법:\n\n- 페이지에 스타일 추가하기\n- 색상 추가: 채우기, 그라데이션, 불투명도, 전경 및 배경 색상\n- 글꼴 사용자 정의: 글꼴 패밀리, 크기, 스타일, 두께, 웹 안전한 글꼴, Google Fonts\n- 레이아웃 만들기: 여백 및 안팎 간격, 시각적 쌓임, 상대적 정렬\n- 배경 추가 및 사용자 정의\n- 애니메이션 및 전환으로 더 매력적으로 꾸미기\n- 특정 상태 및 요소 부분에 스타일 적용: 가상 선택자 및 가상 클래스\n- 모양 사용자 정의: 외곽선 및 테두리, 높이, 너비\n- 스타일 재사용: CSS 변수\n- 모든 화면 크기에 대해 멋지게 보이도록 페이지 스타일링하기: 미디어 쿼리, 반응형 이미지\n- 프레임워크로 더 빨리 스타일링하기: Tailwind, Sass\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. JavaScript essentials\n\n웹 페이지에 상호 작용성을 추가하고 일어나는 일들을 만드는 방법:\n\n# 기본 사항\n\n코딩을 처음 시작하신 분들에게:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떻게:\n\n- 프로그래밍에 대해 생각해보기\n- 페이지에 JavaScript 코드 추가\n- 출력하기: alert(), innerHTML, console logging\n- 데이터 관리하기 — 변수 만들기, 사용하기, 업데이트하기, 출력하기: 데이터 타입, 스코프\n- 주석 작성하기 및 기존 코드를 주석 처리하기\n- 동작 재사용하기: 함수 만들기 및 호출하기: 구문, 매개변수 및 인자, 반환 값, 타입, 스코프\n- 현실 세계 엔티티를 나타내는 객체들 생성하기: 데이터 및 변수, 동작 및 메소드, 중첩된 객체\n- 페이지의 요소 선택 및 조작하기: getElementById, querySelector, 메소드 및 속성 사용 등\n- 입력 및 이벤트 처리하기: 웹 페이지에서 등\n- 문자열로 텍스트 조작하기: 여러 줄, 부분 문자열, 대소문자, 연결, 보간, 분할 및 결합, 자르기 및 채우기, 검색 및 대체, 정규 표현식\n- 목록 사용하기: 초기화, 추가, 업데이트, 제거, 반복, 변환, 검색, 필터, 정렬, 역순\n- 날짜와 시간 사용하기: 생성, 업데이트, 형식화 및 표시\n- 조건부로 데이터 가져오거나 동작하기: if/else, switch, 삼항 연산자, 사전 선택\n- 조건부로 계속해서 동작하기: while, do while, for, break, continue\n- TypeScript로 개발 환경 업그레이드하기: 타입, 제네릭, 인터페이스, 트랜스 파일링, 구성 설정 등.\n\n# 클라이언트 측 개발\n\n당신은 코딩 기초를 알고 계시겠지만, 브라우저에 특히적인 JS 코드를 작성할 수 있나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같은 방법으로:\n\n- 서버에 네트워크 요청을 보내는 방법: fetch() API, HTTP 동사, 데이터 전송 및 수신\n- UI 상태 다루기: 비어 있는 상태, 로딩 중인 상태, 오류가 발생한 상태, 일부만 화면에 나타낸 상태, 이상적인 상태\n- 데이터를 로컬에 저장하기: 쿠키, 로컬 저장소, 세션 저장소 등\n- 코드를 구성하고 패키지화하는 방법: 모듈 및 모듈 번들러\n- 폼 입력 처리하기\n- NPM 패키지를 사용하여 더 빠르게 코딩하는 방법\n\n# 4. 개발 도구로 삶의 질 개선하기\n\n아래와 같은 방법으로:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 콘솔 로그를 만들고 검사하고 필터링하세요: 정보, 오류, 경고\n- 임시 스크립트 및 작업을 추가하세요\n- HTML 요소를 검사, 선택, 및 디버그하세요\n- 스타일을 임시로 수정하세요\n- 네트워크 요청을 모니터링하세요\n- 여러 화면 크기에서 페이지를 테스트하세요\n- 더 빨리 개발하기 위해 편집기 확장 기능을 설치하세요\n- 편집기 테마, 글꼴 및 설정을 사용자 정의하여 개발을 더 즐기세요\n- 통합된 디버거를 사용하세요\n- Emmet을 포함한 스니펫을 사용하여 더 빠르게 코드를 작성하세요\n- 키보드 단축키를 사용하여 더 빨리 개발하세요\n- AI를 사용하여 더 빨리 개발하세요\n\n# 5. 사이트 성능 향상\n\n방법:\n\n- 성능을 측정하세요\n- 인지 성능을 향상시키세요\n- 핵심 웹 핵심 지표 개선: LCP, CLS, INP\n- 일반적인 리소스 전달을 최적화하세요: 캐싱,\n- 이미지를 최적화하세요: 압축, WebP\n- 이미지와 비디오를 지연 로드하세요\n- CSS를 최적화하세요\n- 웹 글꼴을 최적화하세요: 압축, 스와핑 등.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 6. 자바스크립트 프레임워크: 빠르게 개발하기\n\nReact, Angular 또는 Vue인 경우에 관계없이 모두 동일한 기본 개념을 가지고 있습니다.\n\n다음 방법에 대해 알아 봅시다:\n\n- 컴포넌트를 생성하고 재사용합니다\n- 컴포넌트에서 데이터를 수락하고 표시합니다: 데이터 바인딩, 조건부 렌더링 등\n- 컴포넌트에서 상태를 관리합니다\n- 목록 데이터를 표시하고 업데이트합니다\n- 컴포넌트에서 이벤트를 처리합니다\n- 부작용 및 외부 데이터 변경 및 상태 변경을 처리합니다\n- 앱-수준 상태를 관리합니다 — 컴포넌트와 독립적으로\n- 폼 입력을 처리합니다\n- 컴포넌트를 스타일링합니다\n- 프론트엔드 라우팅을 사용한 SPA 네비게이션을 처리합니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 7. 버전 컨트롤: 변경 사항 추적\n\n버전 컨트롤을 사용하면 코드베이스 전체의 변경 사항을 추적하고 실험하는 것이 쉬워집니다.\n\n방법:\n\n- 로컬 저장소를 만들어 코드 및 에셋을 저장합니다.\n- 파일 및 변경 사항을 스테이징하고 커밋합니다: 최선의 방법, 등.\n- .gitignore를 사용하여 파일 무시\n- 이전 커밋 가져오기\n- 새 브랜치 생성: 최신 또는 이전 커밋에서\n- 브랜치 병합: 병합 충돌 해결 등.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Git \u0026 GitHub\n\n다음을 참고하세요:\n\n- 자신의 GitHub 레포지토리 만들기: README.md, 라이센스 등\n- 원격 저장소 사용하기: 만들기, 푸시, 풀, 제거\n- GitHub에서 레포지토리 복제하기\n- GitHub 레포지토리 포크하기\n- GitHub 레포지토리에 풀 리퀘스트 만들기\n\n# 8. 데이터베이스에서 데이터 관리하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트엔드에 전념하고 있더라도 데이터 처리 및 조작에 대한 이해력을 향상시킬 수 있습니다.\n\n다음을 하는 방법:\n\n- 데이터를 위한 스키마 설계\n- 스키마 구현: 테이블, 키, 데이터 형식, 외래 키, 컬렉션 (NoSQL)\n- 데이터베이스에 데이터 추가\n- 데이터 읽기: 조인, 필터링, 정렬, 검색, 집계\n- 데이터 업데이트\n- 데이터 삭제\n\n# 9. 서버 측 개발\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 필요 시 빠르게 학습하기\n- 코드에서 독립적으로 문제 해결하기\n- 디자이너, 클라이언트 및 다른 개발자와 소통하기\n- 디버그하고 인내심을 갖기\n- 필요에 따라 정보를 검색하고 필요에 맞게 처리하기\n\n# 마무리\n\n이 모든 것을 배우면 웹 앱과 사이트의 99%를 높은 품질과 빠른 속도로 처음부터 끝까지 구축할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_0.png"},"coverImage":"/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_0.png","tag":["Tech"],"readingTime":5},{"title":"React로 카운트다운 타이머 만드는 방법","description":"","date":"2024-06-22 15:35","slug":"2024-06-22-BuildingaCountdownTimerinReact","content":"\n\n\n![Countdown Timer](/assets/img/2024-06-22-BuildingaCountdownTimerinReact_0.png)\n\nReact 애플리케이션에 동적 카운트다운 타이머를 추가해보고 싶었나요? 생산성 앱을 만들고 있거나 라이브 이벤트를 진행하거나 웹사이트를 화려하게 꾸미고 싶은 경우, 카운트다운 타이머는 매력적이고 기능적인 추가물이 될 수 있습니다. 이 기사에서는 React.js를 사용하여 간단하면서도 강력한 1시간 카운트다운 타이머를 구축하는 방법에 대해 살펴보겠습니다.\n\n# 시작하기\n\n코드에 들어가기 전에, 우리가 달성하려는 목표를 명확히 해 봅시다. 우리의 목표는 실시간으로 업데이트되는 시각적으로 매력적인 카운트다운 타이머를 만드는 것입니다. 이 타이머는 1시간부터 0까지 카운트다운됩니다. 이를 달성하기 위해 우리는 인기 있는 React 라이브러리와 useState 및 useEffect 훅을 활용할 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 카운트다운 컴포넌트\n\n시작해봅시다. 카운트다운 타이머 컴포넌트를 만들어봅시다. 이 컴포넌트는 카운트다운 논리와 렌더링을 캡슐화할 것입니다.\n\n```js\nimport React, { useState, useEffect } from 'react';\n\nconst CountdownTimer = () =\u003e {\n  // 초기 시간 (1시간 단위)\n  const initialTime = 60 * 60;\n  const [timeRemaining, setTimeRemaining] = useState(initialTime);\n\n  useEffect(() =\u003e {\n    const timerInterval = setInterval(() =\u003e {\n      setTimeRemaining((prevTime) =\u003e {\n        if (prevTime === 0) {\n          clearInterval(timerInterval);\n          // 타이머가 0이 되면 수행할 작업\n          console.log('카운트다운 완료!');\n          return 0;\n        } else {\n          return prevTime - 1;\n        }\n      });\n    }, 1000);\n\n    // 컴포넌트가 언마운트될 때 인터벌 정리\n    return () =\u003e clearInterval(timerInterval);\n  }, []); // 빈 의존성 배열은 효과가 마운트 시에 한 번만 실행되도록 함\n\n  // 초를 시간, 분, 초로 변환\n  const hours = Math.floor(timeRemaining / 3600);\n  const minutes = Math.floor((timeRemaining % 3600) / 60);\n  const seconds = timeRemaining % 60;\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003e카운트다운 타이머:\u003c/p\u003e\n      \u003cp\u003e{`${hours}시간 ${minutes}분 ${seconds}초`}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default CountdownTimer;\n```\n\n# 카운트다운타이머 컴포넌트 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React from 'react';\nimport CountdownTimer from './CountdownTimer';\n\nconst App = () =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eReact Countdown Timer\u003c/h1\u003e\n      \u003cCountdownTimer /\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default App;\n```\n\n# 결론\n\nReact와 해당 훅을 이용하여, 유연하고 매력적인 카운트다운 타이머를 제작했습니다. 이를 프로젝트에 손쉽게 통합할 수 있습니다. 스타일링을 맞춤화하거나 음향 효과를 추가하거나, 애플리케이션의 요구 사항에 기반한 추가 기능을 통합하는 자유를 누려보세요.\n\n자, 이제 다음 React 프로젝트에서 시간을 효율적으로 활용해 보세요. 즐거운 코딩되세요!\n","ogImage":{"url":"/assets/img/2024-06-22-BuildingaCountdownTimerinReact_0.png"},"coverImage":"/assets/img/2024-06-22-BuildingaCountdownTimerinReact_0.png","tag":["Tech"],"readingTime":3},{"title":"실전 HTML과 CSS 빠른 실력 향상을 위한 10개 프로젝트","description":"","date":"2024-06-22 15:35","slug":"2024-06-22-Hands-OnHTMLandCSS10ProjectsforRapidSkillImprovement","content":"\n\nHTML과 CSS를 숙달하는 것은 시각적으로 매력적인 웹사이트를 만드는 데 그치지 않습니다 — 사용자 경험을 공감시키는 것입니다. 처음부터 시작하든지 기술을 더욱 향상시키는 중이든, 저희가 선별한 10일 가이드는 실전 프로젝트로 학습을 가속화하는 데 도움이 될 것입니다.\n\n1일차: 미디어 쿼리를 사용하여 반응형 네비게이션 바를 만들어, 다양한 화면 크기에 매끄럽게 적응되도록 합시다.\n\n- 프로젝트 1: 드롭다운이 있는 반응형 네비게이션 바\n- 프로젝트 2: 호버 효과가 있는 세련된 네비게이션 바\n- 프로젝트 3: 로고와 메뉴 항목이 있는 네비게이션 바\n- 프로젝트 4: 검색 창이 있는 투명한 네비게이션 바\n- 프로젝트 5: 아이콘 링크가 있는 네비게이션 바\n\n2일차: Flexbox를 사용하여 유연한 항목 위치 지정 및 그리드를 사용하여 구조화된 카드 배열을 디자인하고 구현해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 프로젝트는 나중에 추가될 예정입니다. (22/6/24)\n\nDay 3: CSS Grid을 활용하여 반응형이고 시각적으로 매력적인 고급 레이아웃을 생성하는 데 초점을 맞춘 Grid Stock 프로젝트를 살펴보세요.\n\n- 프로젝트는 나중에 추가될 예정입니다. (23/6/24)\n\nDay 4: 부드러운 전환 효과와 컨트롤을 갖춘 가로 및 세로 이미지 슬라이더를 개발하여 이미지를 쇼케이스하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 나중에 프로젝트가 추가될 예정입니다. (24/6/24)\n\n5일차: 다음 튜토리얼에서 프로젝트를 구현해 보세요: https://www.youtube.com/watch?v=NU6BqU67Lv8, 해당 개념을 이해하고 적용에 중점을 두세요.\n\n6일차: 적어도 3–5개의 다른 프로젝트로 푸터의 디자인 및 스타일링을 연습해 보며 레이아웃, 내용 정렬 및 시각적 매력에 실험해 보세요.\n\n- 나중에 프로젝트가 추가될 예정입니다. (26/6/24)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일일 프로젝트를 수행하면서 링크를 업데이트할 예정입니다. 이를 통해 CSS를 단계별로 숙달하는 데 집중하고, 각 날짜 학습 목표와 일치하는 관련 자습서 및 자료에 액세스할 수 있습니다. 제 진행을 따라가고 최신 업데이트를 확인하려면 정기적으로 방문해주세요. 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-22-Hands-OnHTMLandCSS10ProjectsforRapidSkillImprovement_0.png"},"coverImage":"/assets/img/2024-06-22-Hands-OnHTMLandCSS10ProjectsforRapidSkillImprovement_0.png","tag":["Tech"],"readingTime":2}],"page":"11","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"11"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>