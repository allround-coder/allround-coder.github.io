<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/118" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/118" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Choreo에서 Vite  React 앱을 만들고 배포하는 방법" href="/post/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Choreo에서 Vite  React 앱을 만들고 배포하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Choreo에서 Vite  React 앱을 만들고 배포하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Choreo에서 Vite  React 앱을 만들고 배포하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Create-React-App과 react-beautiful-dnd를 사용하여 간단한 드래그 앤 드롭을 구현하는 방법" href="/post/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Create-React-App과 react-beautiful-dnd를 사용하여 간단한 드래그 앤 드롭을 구현하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Create-React-App과 react-beautiful-dnd를 사용하여 간단한 드래그 앤 드롭을 구현하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Create-React-App과 react-beautiful-dnd를 사용하여 간단한 드래그 앤 드롭을 구현하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React에서 React Router 링크를 테스트하는 방법 초심자를 위한 안내" href="/post/2024-05-14-HowtoTestaReactRouterLinkinReactABeginnersGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React에서 React Router 링크를 테스트하는 방법 초심자를 위한 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowtoTestaReactRouterLinkinReactABeginnersGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React에서 React Router 링크를 테스트하는 방법 초심자를 위한 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React에서 React Router 링크를 테스트하는 방법 초심자를 위한 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="스켈러블한 마이크로서비스 구축 Go로 GRPC 서비스 만들기 및 Envoy를 통해 React 앱에서 사용하기" href="/post/2024-05-14-BuildingScalableMicroservicesCreatingaGRPCServicewithGoandConsumingitinaReactAppviaEnvoy"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="스켈러블한 마이크로서비스 구축 Go로 GRPC 서비스 만들기 및 Envoy를 통해 React 앱에서 사용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BuildingScalableMicroservicesCreatingaGRPCServicewithGoandConsumingitinaReactAppviaEnvoy_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="스켈러블한 마이크로서비스 구축 Go로 GRPC 서비스 만들기 및 Envoy를 통해 React 앱에서 사용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">스켈러블한 마이크로서비스 구축 Go로 GRPC 서비스 만들기 및 Envoy를 통해 React 앱에서 사용하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label=" Nextjs 142의 새로운 기능을 살펴보세요 " href="/post/2024-05-14-ExplorewhatisnewinNextjs142"><div class="PostList_thumbnail_wrap__YuxdB"><img alt=" Nextjs 142의 새로운 기능을 살펴보세요 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ExplorewhatisnewinNextjs142_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt=" Nextjs 142의 새로운 기능을 살펴보세요 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl"> Nextjs 142의 새로운 기능을 살펴보세요 </strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트를 위한 전문 성능 향상 팁" href="/post/2024-05-14-ExpertPerformanceTipsforREACT"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트를 위한 전문 성능 향상 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ExpertPerformanceTipsforREACT_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트를 위한 전문 성능 향상 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트를 위한 전문 성능 향상 팁</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기" href="/post/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="워커 스레드 NodeJS에서의 멀티태스킹" href="/post/2024-05-13-WorkerThreadsMultitaskinginNodeJS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="워커 스레드 NodeJS에서의 멀티태스킹" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="워커 스레드 NodeJS에서의 멀티태스킹" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">워커 스레드 NodeJS에서의 멀티태스킹</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트의 숨은 보석 돌연변이 감시자의 힘 탐구" href="/post/2024-05-13-JavaScriptsHiddenGemExploringthePowerofMutationObserver"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트의 숨은 보석 돌연변이 감시자의 힘 탐구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-JavaScriptsHiddenGemExploringthePowerofMutationObserver_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트의 숨은 보석 돌연변이 감시자의 힘 탐구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트의 숨은 보석 돌연변이 감시자의 힘 탐구</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="5가지 팁과 트릭으로 Nextjs 14와 함께 더 쉽게 살아가는 방법" href="/post/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="5가지 팁과 트릭으로 Nextjs 14와 함께 더 쉽게 살아가는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="5가지 팁과 트릭으로 Nextjs 14와 함께 더 쉽게 살아가는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">5가지 팁과 트릭으로 Nextjs 14와 함께 더 쉽게 살아가는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link" href="/posts/116">116</a><a class="link" href="/posts/117">117</a><a class="link posts_-active__YVJEi" href="/posts/118">118</a><a class="link" href="/posts/119">119</a><a class="link" href="/posts/120">120</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Choreo에서 Vite  React 앱을 만들고 배포하는 방법","description":"","date":"2024-05-14 10:19","slug":"2024-05-14-HowtoBuildandDeployaViteReactApponChoreo","content":"\n\n더블육을 전에 WSO2가 주굜한 코딩 대회에 참여했어요 (choreo.dev/cybertruck). 거기서 제가 경험해 본 내부 개발자 플랫폼인 Choreo를 탐험할 수 있었어요. 이 챌린지의 목표는 개인 개발자들이 Choreo를 경험할 수 있도록 하는 거에요.\n\nChoreo가 뭔데요?\n\n\"Choreo는 디지털 경험을 만드는 방식을 재정의하는 내부 개발자 플랫폼이에요. Choreo는 클라우드 네이티브 애플리케이션을 원활하게 디자인하고 개발하고 배포하고 관리할 수 있게 해 주어 혁신을 불러 일으키면서 시장 진입 시간을 줄여 줘요.\"\n\n그래서 오늘은 Vite+ React 앱을 Choreo에 빌드하고 배포하는 방법에 대해 설명할게요.\n\n\n\n시작하기 전에 다음 사항이 있는지 확인하세요:\n\n\n- Github 계정\n- Choreo 계정(https://console.choreo.dev/로 이동하여 가입하고 조직을 생성하세요.)\n \n\n앱 생성\n\n터미널을 열고 다음 명령어를 실행하세요:\n\n\n\n```js\nnpm create vite@latest my-project -- --template react\n```\n\n프로젝트 디렉토리로 이동하여 필요한 종속성을 설치하세요\n\n```js\ncd my-project\nnpm install\n```\n\n설치 프로세스를 완료한 후, IDE를 사용하여 프로젝트에 일부 변경을 가하실 수 있습니다. 이 데모에서 제가 한 작업은 다음과 같습니다.\n\n\n\n```js\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    \u003c\u003e\n      \u003ch1\u003eChoreo 데모\u003c/h1\u003e\n    \u003c/\u003e\n  );\n}\n\nexport default App;\n```\n\n프로젝트를 수정한 후에 GitHub에 새 저장소를 만들고 프로젝트를 푸시하세요. Choreo 무료 평가판에서는 공개 저장소만 배포할 수 있습니다. 따라서 저장소 가시성을 공개로 설정해주세요.\n\n이제 Choreo에서 빌드하고 배포해봅시다.\n\n먼저, 조직 홈페이지를 볼 수 있는 console.choreo.dev로 이동해주세요.\n\n\n\n\n홈페이지에서 + 프로젝트 생성을 클릭하고, 프로젝트 이름을 입력한 후 \"새 프로젝트 생성\"을 클릭하면 새 프로젝트가 생성됩니다.\n\n프로젝트를 생성한 후, \"단일 구성 요소 생성\" 섹션 아래의 웹 애플리케이션 카드를 클릭하고 구성 요소의 이름과 설명을 입력하세요.\n\nGitHub 저장소를 이 구성 요소에 연결하려면 \"GitHub로 승인\"을 클릭하고, 이를 위해 생성한 저장소를 선택하세요.\n\n\n\n깃허브 레포지토리를 연결한 후, 데모와 관련된 필수 정보를 선택하십시오.\n\n```js\nBuildpack : React\nProject directory : /\nBuild command : npm run build \nBuild path : /dist\nNode version : 20(또는 사용 중인 버전)\n```\n\n\u003cimg src=\"/assets/img/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo_1.png\" /\u003e\n\n이제 생성 버튼을 클릭하면 컴포넌트가 성공적으로 생성됩니다.\n\n\n\n컴포넌트가 성공적으로 생성되면 대시보드의 왼쪽 사이드바에서 빌드 섹션으로 이동하여 '최신 버전 빌드'를 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo_2.png)\n\n빌드 프로세스가 완료되면 응용 프로그램을 배포할 수 있습니다.\n\n그러려면 배포 섹션으로 이동하여 설정 카드에서 '구성 및 배포'를 클릭하세요.\n\n\n\n![이미지](/assets/img/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo_3.png)\n\n이후에 왼쪽에 시트가 열리며 여기에서 파일 마운트와 인증 설정을 추가할 수 있습니다. 본 데모에서는 파일 마운트나 인증을 추가하지 않겠습니다. 이 부분은 건너뛰셔도 됩니다. (인증 패널에서 'Choreo Manage Authentication'을 끄는 것을 잊지 마세요)\n\n이제 배포 버튼을 클릭하여 애플리케이션을 개발 환경에 배포할 수 있습니다. 수 분 후에 배포 상태가 성공적으로 완료되었음을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo_4.png)\n\n\n\n웹 애플리케이션을 성공적으로 호스팅했는지 확인하려면 개발 카드의 웹 앱 URL을 클릭해주세요.\n\n이제 Vite + React 앱을 Choreo에 성공적으로 배포했습니다.\n\n원하신다면 개발 환경 카드의 '프로모트' 버튼을 클릭하여 프로덕션 환경으로 승격시킬 수 있습니다. 게다가, 프로덕션 환경에서 애플리케이션에 대한 짧은 URL 접두사를 설정할 수도 있습니다.\n\n![이미지](/assets/img/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo_5.png)\n\n\n\n위의 데모에 대한 내 GitHub 레포를 확인해볼 수 있어요:\n\nhttps://github.com/chamals3n4/Vite-Choreo\n\n간단히 말해서, 오늘은 Vite + React 앱을 Choreo에 빌드하고 배포하는 방법을 배웠어요. Choreo를 사용하면 클라우드 네이티브 앱을 쉽게 배포할 수 있어요.\n\nChoreo에 대한 자세한 정보 및 고급 개념은 그들의 문서에서 찾을 수 있어요.\n\n\n\nhttps://wso2.com/choreo/docs/\n\n본 글을 읽어 주셔서 감사합니다. 즐거운 코딩 하세요!!","ogImage":{"url":"/assets/img/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo_0.png","tag":["Tech"],"readingTime":3},{"title":"Create-React-App과 react-beautiful-dnd를 사용하여 간단한 드래그 앤 드롭을 구현하는 방법","description":"","date":"2024-05-14 10:17","slug":"2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd","content":"\n\n오늘은 개인 프로젝트를 진행하면서 애플리케이션 내에서 더 많은 사용자 정의를 가능하게하기 위해 드래그 앤 드롭 기능을 구현해야 했어요. 문서, 공식 문서 및 YouTube 비디오를 많이 살펴보느라 많은 시간을 보냈죠. 공부하고 구현을 시도한 깁ㄴ 긴 과정 끝에, 마침내 작동하게 만들었어요. 그런데 어떻게 하느냐구요? 그러기 전에, React 앱을 만들어 봐요!\n\n```js\nnpx create-react-app dnd-example\ncd dnd-example\nnpm start\n```\n\n축하해요! 이제 React 앱을 만들었어요.\n\n![드래그 앤 듭 구현 방법](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_0.png)\n\n\n\n하지만 이것은 시작에 불과해요. 오늘 사용할 패키지를 설치해봅시다.\n\nnpm i react-beautiful-dnd\n\nreact-beautiful-dnd가 무엇인지 모른다면 괜찮아요. Atlassian 팀에서 개발한 라이브러리인데, Jira를 만든 회사입니다. 또한 완전히 오픈 소스이며 프로젝트는 여기에서 확인할 수 있어요. 그리고 우리는 앱을 DragDropContext 컴포넌트 사이에 감싸야 해요. 기억하세요, DragDropContext는 하나만 가질 수 있어요. 그래서 권장하는 공식 문서의 사용 방법을 따르면 전체 앱을 이 사이에 감싸는 것이 좋은 아이디어에요. 현재 내 App.js 파일은 이렇게 생겼어요.\n\n\n\n드래그 앤 드롭 기능을 사용하기 위해서는 react-beautiful-dnd가 제공하는 DragDropContext가 필요합니다. 우리가 사용하는 라이브러리는 중첩된 DragDropContext를 지원하지 않습니다. 그러나 DragDropContext는 onDragEnd 콜백이 필요합니다. 이 콜백은 요소를 드래그한 후에 호출됩니다. 간단하게 하기 위해 함수를 사용할 것입니다. 제가 코드를 복사하여 붙여넣을 수 있는 형식으로 제공하지는 않겠습니다. 연습이 중요하다고 생각하기 때문입니다. 지금까지 우리 앱이 어떻게 보이는지 살펴봅시다:\n\n![이미지](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_2.png)\n\n하나씩 살펴보겠습니다.\n\n우리는 handleOnDragEnd라는 함수를 정의했고, result라는 매개변수를 받는데, 현재 중요하지 않습니다. 드래그 앤 드롭 기능이 작동하려면 DragDropContext 구성 요소로 둘러싸여야 합니다. 많은 사용 가능한 속성과 콜백이 있지만 onDragEnd를 제외하고는 필수 사항이 없습니다. 따라서 핸들러 함수를 DragDropContext 구성 요소의 속성으로 추가했습니다. 웹 사이트에 드래그 앤 드롭할 항목(빨간색 상자 목록)을 추가해보겠습니다. HTML 및 CSS 코드에 대해서는 HTML이나 CSS 튜토리얼이 아니기 때문에 코드를 제공하겠습니다. App.js 파일에는 DragDropContext 태그 내의 드래그 가능한 콘텐츠가 필요합니다. 그러므로 다음을 수행하겠습니다:\n\n\n\n\n![이미지](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_3.png)\n\n```js\n\u003cul\u003e\n\u003cli\u003e\u003cdiv className=\"box red\"\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\u003cdiv className=\"box green\"\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n```\n\n그리고 App.css 파일에서 다음을 수행할 거예요:\n\n![이미지](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_4.png)\n\n\n\n\n```jsx\nul {\nlist-style: none;\npadding-left: 5px;\n}\n.box {\nwidth: 200px;\nheight: 50px;\nmargin-bottom: 5px;\n}\n.red {\nbackground: red;\n}\n.green {\nbackground: green;\n}\n```\n\n이 내용에 대해 자세히 언급하지 않겠습니다. 여러분은 여전히 상자를 끌어다 놓거나 드롭할 수 없다는 것을 알 수 있을 겁니다. 먼저 상자를 놓기에 집중해 보겠습니다. 이를 위해 Droppable이라는 다른 구성 요소를 가져와야 합니다. Droppable은 요소를 놓을 수 있는 영역을 정의하는 데 도움이 됩니다. 현재 사용 중인 경우 ul 요소 전체를 놓을 수있는 영역으로 하고 싶습니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_5.png\" /\u003e\n\n좋아요, 쉬운 부분이죠? 그런데, Droppable 구성 요소에도 droppableId라는 속성이 필요합니다. 왜 그런지 궁금할 수 있습니다. HTML 페이지 전체에는 1개 이상의 놓을 수있는 영역이 있을 수 있으며 react-beautiful-dnd는 무슨일이든 요소를 놓는 지점을 식별해야 합니다. 그래서 id를 추가해 보겠습니다. 이는 문자열이면 무엇이든 상관없습니다. 저는 \"boxes\"라고 부를 것입니다.\n\n\n\n\n![이미지](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_6.png)\n\n더 많은 속성이 있습니다. 'type', 'isDropDisabled' 등이 있지만 이번에는 간단한 드래그 앤 드롭을 할 것입니다. 더 자세히 살펴보고 싶다면 여기에서 공식 문서를 확인할 수 있어요. 이제 우리의 Droppable 구성 요소도 두 개의 인수가 있는 함수가 필요합니다. 이러한 인수들은 provided와 snapshot입니다. 이 예시에서는 provided만 사용하고 이것만 필요한 매개변수입니다. provided를 통해 중요한 3가지를 얻을 수 있습니다; provided.innerRef, provided.placeholder, provided.droppableProps입니다. 간단히 말하면 provided.innerRef를 가능한 높은 DOM 노드에 바인딩해야 합니다. 이것은 ReactDOM을 사용하지 않고도 DOM 노드를 찾을 수 있게 도와줍니다. provided.placeholder는 요소를 드래그할 때 플레이스홀더 공간을 만듭니다. 중요한 점은 provided.innerRef에 바인딩한 구성 요소 내에 플레이스홀더를 두어야 합니다. 마지막 props인 provided.droppableProps는 전개 연산자입니다. react-beautiful-dnd가 필요로 하는 모든 데이터와 스타일을 포함합니다. 이러한 props를 모두 동일한 요소에 넣어야 합니다. 인라인 스타일이 있는 경우, provided.droppableProps를 먼저 입력해야 합니다. provided.droppableProps에 스타일도 포함되어 있어 인라인 스타일이 덮어씁니다. 이제 실습해 봅시다:\n\n![이미지](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_7.png)\n\n지금 웹사이트를 확인해보면 아무 변화가 없을 것입니다. 그 이유는 무엇일까요? 우리의 요소들은 아직 드래그할 수 없기 때문입니다! 이제 이 문제를 해결해 봅시다. 먼저 Draggable을 가져와야 합니다. Draggable은 Droppable과 많은 경우 비슷하지만 요소를 드래그할 수 있게 만듭니다. DragDropContext와 달리, 여러 개의 Droppable과 Draggable을 가질 수 있습니다. Draggable은 항상 하나의 Droppable 내에 포함되어야 하고 Droppable은 항상 DragDropContext 내에 포함되어야 합니다. Droppable과 마찬가지로 Draggable도 동일한 문서에서 여러 개를 사용할 수 있기 때문에 ID가 필요합니다. 그러나 더 나아가기 전에, 여기서 배열을 사용하고 수동으로 작성된 div가 아닌 배열과 함께 사용할 것이므로 코드를 리팩토링하고 싶습니다. 또한 그 논리를 설명할 것이므로, 수동으로 작성된 div와 함께 사용한다 해도 잘 이해할 수 있도록 하겠습니다. 함께 따라오신다면, App 구성 요소 내에서 다음과 같이 객체들의 간단한 배열을 정의할 것입니다:\n\n\n\n아주 명확하지요. 이제 div를 표시하는 방법을 개선해 봅시다:\n\n이 기사는 적어도 React의 기본 지식이 있음을 가정하므로 map에 대해 자세히 설명하지는 않겠습니다. 배열을 해체하고 목록 항목에 키 값을 할당했습니다. 클래스에는 템플릿 리터럴이라는 것을 사용했습니다. 이게 무엇인지 모르겠다면 여기에서 내 기사를 읽어보세요. 페이지를 새로 고쳐도 아무것도 바뀌지 않을 겁니다. 이제 웹사이트에 드래그 기능을 추가해 봅시다. 먼저, 드래그 가능한 내용을 감싸는 데 필요한 것은 Draggable 컴포넌트입니다. 제 경우에는 li 요소가 됩니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_10.png\" /\u003e\n\n드래그 가능한 항목을 만들려면 index와 ID가 필요합니다. ID는 다시 한 번 문자열이어야 합니다. 여기서는 map 함수에서 받은 index를 사용할 것입니다. 그런데 문제는 ID가 숫자인데, 그래서 우리는 그 아주 오래된 toString() 함수를 사용할 겁니다. 시작해 봅시다!\n\n\u003cimg src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_11.png\" /\u003e\n\n좋아요, 여기서부터는 좀 더 가까워졌네요. Droppable과 유사하게, Draggable 컴포넌트도 두 가지 인수를 받는 함수가 필요합니다. 이 인수들은 우리 친구인 provided와 snapshot입니다. 다시 한 번, 우리는 provided만 사용할 것이고, 이것이 유일한 필수 인수입니다. Droppable과 마찬가지로, provided.innerRef, provided.draggableProps, provided.dragHandleProps라는 3가지 중요한 것을 얻습니다. 이들을 다시 동일한 요소에 할당해야 합니다. 이것들이 하는 일은 Droppable과 유사합니다. 우리는 리스트 요소에 이것들을 추가할 것입니다. 왜냐하면 우리는 이것이 드래그 가능하도록 하고 싶기 때문이죠.\n\n\n\n![이미지](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_12.png)\n\n하지만 조금 변경을 해줘야 해요. key prop을 Draggable 컴포넌트로 옮기겠어요. 각 draggable 요소에는 key가 필요해요.\n\n![이미지](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_13.png)\n\n좋아요, 멋지죠! 이제 페이지를 새로 고치면 요소를 드래그 앤 드롭할 수 있어요. 와아아!\n\n\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:638/1*QSGvvVpg3ZwZF1ecxNeB3g.gif\" /\u003e\n\n알겠어요, 그거 좋은데 이건 의미가 없어요. 드래그앤드랍하는 동안 저장조차 안돼있네요. 이러한 경우에는 상태(states)를 사용할 거예요. 먼저 useState를 import해보죠.\n\n\u003cimg src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_14.png\" /\u003e\n\n다음으로, 상태(states)를 정의할거예요. 저는 이를 박스(boxes)라고 부를거에요. 그리고 시작할 때 배열을 삭제하고 상태로 할당할거에요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_15.png\" /\u003e\n\n알겠어요, 페이지를 새로고침하면... 아무것도 변하지 않을 거예요! 그건, 드래그가 끝났을 때 어떻게 동작하는지 다뤄주지 않았기 때문이죠. 그래서 handleonDragEnd를 정의했던 거예요, 맞죠? 그럼, 그걸 처리해 볼게요! 일단 결과가 무엇인지 간단히 console.log로 확인해 볼 거예요.\n\n\u003cimg src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_16.png\" /\u003e\n\n알겠어요, 그것은 우리가 사용할 수 있는 여러 멋진 요소들을 가진 객체네요. 그 중에서도 destination과 source에 관심이 있지만요. Source는 우리가 드래그한 요소에 대한 정보를 가지고 있고, destination은 우리가 그것을 끌어다 놓은 위치에 대한 정보를 가지고 있어요. 이 지식을 바탕으로, box 배열에서 새 배열을 만들어 볼게요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-Create-React-App와 react-beautiful-dnd를 사용하여 간단한 드래그 앤 드롭을 구현하는 방법_17.png\" /\u003e\n\n좋아요. 다음으로, 새 배열에서 드래그 된 요소를 제거하고 이동한 위치에 추가하려고 합니다. 이를 위해 다음과 같이 소스와 대상의 인덱스를 사용해야합니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-Create-React-App와 react-beautiful-dnd를 사용하여 간단한 드래그 앤 드롭을 구현하는 방법_18.png\" /\u003e\n\n좋아요, 그런데 그것만으로는 의미가 없어요, 맞죠? 우리는 그냥 새 배열을 만드는 것 뿐이에요. 그래 놓은 새 배열을 우리의 상태로 설정해야 해요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-Create-React-App와-react-beautiful-dnd를 사용하여 간단한 드래그 앤 드롭을 구현하는 방법_19.png\" /\u003e\n\n자, 이제 웹사이트를 다시 확인해 봅시다!\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:596/1*6BHSxIDCCkGF_gQq3sl5Ew.gif\" /\u003e\n\n잘 작동하네요! 하지만 작은 버그가 있네요. 만약 박스를 우리가 Droppable을 정의하지 않은 곳에 끌어다 놓으면 어떻게 될까요? 한번 시도해 보죠:\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_20.png\" /\u003e\n\n음, 예상대로 제 상자가 원래 위치로 돌아가고 이 오류가 발생했어요. 해결 방법은 간단해요. 목적지가 null이면 간단히 리턴하면 돼요:\n\n\u003cimg src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_21.png\" /\u003e\n\n이제 Atlassian의 react-beautiful-dnd를 사용하여 완벽하게 작동하는 간단한 드래그 앤 드롭 기능이 준비됐어요! 이 기사를 위해 작성한 코드를 검토하려면 아래에 GitHub repo 링크를 추가하겠습니다.\n\n\n\n언제나 이 코드에 대해 개선 사항이나 질문이 있으면 아래 댓글을 남겨 주세요. 또한 제 일일 학습 루틴에서 더 많은 글을 보고 싶다면 제 팔로우를 고려해 주세요. 그렇다면, 다음 글에서 만나요!\n\n깃허브 저장소","ogImage":{"url":"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_0.png"},"coverImage":"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_0.png","tag":["Tech"],"readingTime":9},{"title":"React에서 React Router 링크를 테스트하는 방법 초심자를 위한 안내","description":"","date":"2024-05-14 10:15","slug":"2024-05-14-HowtoTestaReactRouterLinkinReactABeginnersGuide","content":"\n\n안녕하세요! 유닛 테스트의 바다에 발을 담그기 시작하셨나요? 그렇다면 올바른 곳에 왔어요! 오늘은 React Router를 사용하는 React 애플리케이션에서 클릭 가능한 링크를 테스트하는 재미있는 시간을 갖도록 할 거예요. 재미있고 간단하게 진행하며 테스팅의 세계로 여행을 시작해보아요!\n\n# 왜 네비게이션 링크를 테스트해야 하나요?\n\n네비게이션 링크는 많은 웹 애플리케이션에서 사용자 상호작용의 중추입니다. 페이지를 새로고침하지 않고 사용자를 부드럽게 이동시키며, 이를 테스트하는 것이 사용자 경험의 연속성을 보장하는 데 중요합니다. 오늘은 이 링크들이 사용자를 목적지로 올바르게 안내하는지 확인하는 방법을 배우게 될 거예요.\n\n# 코드: React Router 링크\n\n\n\n작은 링크 컴포넌트를 작성해 보겠습니다. MagicDoor라고 부를게요. 보기에는 이렇습니다:\n\n```js\n// MagicDoor.js\nimport React from 'react';\nimport { Link } from 'react-router-dom';\n\nfunction MagicDoor({ destinationId }) {\n  return (\n    \u003cdiv\u003e\n      \u003cLink to={{\n        pathname: `/mystery-destination/${destinationId}`,\n        state: { from: window.location.pathname }\n      }}\u003e\n        목적지로 이동하기\n      \u003c/Link\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default MagicDoor;\n```\n\n이 컴포넌트에서 destinationId는 열고자 하는 목적지를 결정하는 고유한 키입니다. 상태(state)는 어디서 왔는지의 기억을 갖고 있어요.\n\n# 테스트 시간: 제대로 열리나요?\n\n\n\n자, 이제 MagicDoor가 예상대로 작동하는지 확인해 봅시다. 올바른 URL을 가지고 있는지 확인하고 클릭했을 때 어떻게 되는지 살펴봅시다:\n\n```js\n// MagicDoor.test.js\nimport React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport configureStore from 'redux-mock-store';\nimport { BrowserRouter } from 'react-router-dom';\nimport theme from 'core/theme';\nimport { MuiThemeProvider } from '@material-ui/core/styles';\nimport MagicDoor from './MagicDoor';\n\ndescribe('MagicDoor Component', () =\u003e {\n  let store;\n  beforeAll(() =\u003e {\n    const mockStore = configureStore([]);\n    store = mockStore({}); // 초기 상태\n  });\n\n  it('문 사용시 올바른 목적지로 이동해야 함', () =\u003e {\n    const destinationId = '123';\n    const destinationLink = `mystery-destination/${destinationId}`;\n    render(\n      \u003cProvider store={store}\u003e\n        \u003cMuiThemeProvider theme={theme}\u003e\n          \u003cBrowserRouter\u003e\n            \u003cMagicDoor destinationId={destinationId} /\u003e\n          \u003c/BrowserRouter\u003e\n        \u003c/MuiThemeProvider\u003e\n      \u003c/Provider\u003e,\n    );\n    \n    const door = screen.getByText('Step through to your destination');\n    expect(door).toHaveAttribute('href', destinationLink);\n    \n    fireEvent.click(door);\n    expect(window.location.pathname).toBe(destinationLink);\n  });\n});\n```\n\n# 방금 무엇을 했나요?\n\n- 링크 찾기: getByText를 사용하여 텍스트에 따라 링크를 찾았습니다.\n- URL 확인: 링크의 href 속성이 제공한 목적지와 일치하는지 확인했습니다.\n- 클릭 시뮬레이션: fireEvent를 사용하여 클릭을 모방하고 올바른 URL이 열렸는지 확인했습니다.\n\n\n\n# 왜 이겪소!\n\nReact Router로 테스트를 진행하면 앱의 내부 이동이 의도한 대로 작동하는지 확인할 수 있어 사용자 경험에서 중요합니다. 사용자 상호작용을 모방하고 결과 경로를 확인함으로써, 사용자가 정확히 이동할 위치를 확인합니다.\n\n# 결론\n\n이제 React Router를 사용하여 React 애플리케이션의 네비게이션 링크를 테스트할 견고한 방법을 갖게 되었습니다. 작성하는 모든 테스트는 더 신뢰할 수 있는 애플리케이션을 구축하는 데 도움이 되며, 네비게이션이 매끄럽고 올바르게 흘러가는 것을 확인합니다.\n\n\n\n# 다음은 무엇인가요?\n\n어플리케이션의 다른 유형의 상호작용을 위한 테스트를 추가해보는 것은 어떨까요? 모든 조각의 테스트는 연결되어 매끄럽고 버그가 없는 사용자 경험을 만들어냅니다. 여러분이 어떤 것들을 만들어내는지 댓글에서 제 경험을 공유해 주시면 정말로 좋겠어요!\n\n기억하세요, 테스팅은 연습과 인내력으로 향상되는 기술입니다. 계속 하며 언젠가는 React 어플리케이션을 전문가처럼 테스트할 수 있게 될 거예요. 행복한 테스팅하세요!","ogImage":{"url":"/assets/img/2024-05-14-HowtoTestaReactRouterLinkinReactABeginnersGuide_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoTestaReactRouterLinkinReactABeginnersGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"스켈러블한 마이크로서비스 구축 Go로 GRPC 서비스 만들기 및 Envoy를 통해 React 앱에서 사용하기","description":"","date":"2024-05-14 10:14","slug":"2024-05-14-BuildingScalableMicroservicesCreatingaGRPCServicewithGoandConsumingitinaReactAppviaEnvoy","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildingScalableMicroservicesCreatingaGRPCServicewithGoandConsumingitinaReactAppviaEnvoy_0.png\" /\u003e\n\n# 준비물\n\n구현에 들어가기 전에 시스템에 다음 사항이 설치되어 있는지 확인하세요:\n\n- Go: 공식 웹사이트(https://golang.org/)에서 Go를 설치하세요.\n- Node.js와 npm: (https://nodejs.org/)에서 Node.js를 다운로드하고 설치하세요.\n- Docker: Envoy 프록시 컨테이너를 실행하기 위해 Docker를 설치하세요(https://www.docker.com/).\n\n\n\n# 단계 1: Go에서 GRPC 서비스 만들기\n\n먼저 Go로 GRPC 서비스를 만들어봅시다. 프로젝트를 위한 새 디렉토리를 만들고 Go 환경을 설정해보세요:\n\n```js\ngo-grpc-server-with-envoy\n```\n\n아래 명령을 실행하여 프로젝트를 초기화하세요:\n\n\n\n```js\ncd go-grpc-server-with-envoy\ngo mod init\n```\n\n지금은 새로운 Go 파일을 만들어서 서비스를 구현해보세요. 예를 들어 main.go 파일을 만들 수 있습니다. 이 파일에서 GRPC 서비스와 그 메서드를 정의해보세요. 다음은 간단한 예시입니다:\n\n```js\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n)\n\n// YourService should implement the methods of your GRPC service.\ntype YourService struct{}\n\n// 여기에 GRPC 메서드를 구현하세요.\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\t// 여기에 서비스를 등록하세요.\n\n\tif err := grpcServer.Serve(listener); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}\n```\n\n# 스텝 2: 프로토버프 정의 만들기\n\n\n\n\n서비스와 메시지를 Protocol Buffers(Protobuf)를 사용하여 정의하세요. \"proto\" 폴더 안에 .proto 파일을 만들어주세요. 예를 들어 UserInfo.proto 파일을 만들어서 서비스와 메시지 유형을 정의해주세요:\n\n```js\nsyntax = \"proto3\";\n\npackage proto;\n\noption go_package = \"app/proto\";\n\nmessage User {\n    string name = 1;\n    int32 age = 2;\n    Address address = 3;\n    PhoneNumber phone = 4;\n    string updated_at = 5;\n    string created_at = 6;\n}\n\nmessage Address {\n    string street = 1;\n    string city = 2;\n    string state = 3;\n    string zip = 4;\n}\n\nmessage PhoneNumber {\n    string primary = 1;\n    map\u003cstring, string\u003e others = 2;\n}\n\nmessage UserRequest {\n    string name = 1;\n}\n\nmessage UserResponse {\n    User user = 1;\n    int32 status = 2;\n    string error = 3;\n}\n\nservice Usr {\n    rpc GetUser(UserRequest) returns (UserResponse) {}\n}\n```\n\n.proto 파일을 컴파일하여 Go 코드를 생성하세요:\n\n```js\n protoc ./proto/userInfo.proto --go_out=. --go-grpc_out=.\n```\n\n\n\n# 단계 3: GRPC 서비스 구현하기\n\nmain.go 파일에 .proto 파일의 정의에 따라 GRPC 서비스 메소드를 구현해주세요.\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"log\"\n    \"net\"\n    \"time\"\n\n    \"github.com/digvijay17july/golang-projects/go-grpc-react-example/go-grpc-server-with-envoy/app/proto\"\n    \"google.golang.org/grpc\"\n)\n\ntype server struct {\n    proto.UnimplementedUsrServer\n}\n\nfunc (*server) GetUser(ctx context.Context, in *proto.UserRequest) (*proto.UserResponse, error) {\n    \n    others := make(map[string]string)\n    others[\"secondary\"] = \"233453\"\n    phone := \u0026proto.PhoneNumber{Primary: \"1234567890\", Others: others}\n    user := \u0026proto.User{Name: \"Digvijay\", Age: 23, Address: \u0026proto.Address{Street: \"Pune\", City: \"Pune\", State: \"MAHARASHTRA\", Zip: \"201223\"}, Phone: phone, UpdatedAt: time.Now().UTC().String(), CreatedAt: time.Now().UTC().String()}\n    return \u0026proto.UserResponse{User: user, Status: 200, Error: \"\"}, nil\n}\n\nfunc main() {\n    lis, err := net.Listen(\"tcp\", \":8080\")\n    if err != nil {\n        log.Fatalf(\"failed to listen: %v\", err)\n    }\n    s := grpc.NewServer()\n    grpcServer := \u0026server{}\n    proto.RegisterUsrServer(s, grpcServer)\n    log.Printf(\"Starting server on port :%v\", lis.Addr())\n    if err := s.Serve(lis); err != nil {\n        log.Fatalf(\"failed to serve: %v\", err)\n    }\n\n}\n```\n\n# 단계 4: GRPC 서비스 Docker 이미지 빌드 및 실행하기\n\n\n\nDockerfile for the Grpc Service app -\n\n```js\nFROM golang:1.21.4-alpine\n\nWORKDIR /app\n\nCOPY go.sum ./\n\nCOPY . ./\n\nRUN go build -o /go-grpc-server-with-envoy\n\nEXPOSE 8080\n\nCMD [\"/go-grpc-server-with-envoy\"]\n```\n\n이미지 빌드하기 -\n\n```js\ndocker build -t go-grpc-server-with-envoy .\n```\n\n\n\n# 단계 5: Envoy Proxy 설정하기\n\nEnvoy 폴더를 생성하세요. 이 폴더에는 2개의 파일이 포함됩니다.\n\n- ./config/envoy.yaml\n\n```js\nadmin:\n  address:\n    socket_address: { address: 0.0.0.0, port_value: 9901 }\nstatic_resources:\n  listeners:\n    - name: listener_0\n      address:\n        socket_address: { address: 0.0.0.0, port_value:  8080 }\n      filter_chains:\n        - filters:\n            - name: envoy.filters.network.http_connection_manager\n              typed_config:\n                \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n                codec_type: auto\n                stat_prefix: ingress_http\n                route_config:\n                  name: local_route\n                  virtual_hosts:\n                    - name: local_service\n                      domains: [\"*\"]\n                      routes:\n                        - match: { prefix: \"/\"}\n                          route: { cluster: grpc_service}\n                      cors:\n                        allow_origin_string_match:\n                          - prefix: \"*\"\n                        allow_methods: GET, PUT, DELETE, POST, OPTIONS\n                        allow_headers: keep-alive,user-agent,cache-control,content-type,content-transfer-encoding,custom-header-1,x-accept-content-transfer-encoding,x-accept-response-streaming,x-user-agent,x-grpc-web,grpc-timeout\n                        max_age: \"1728000\"\n                        expose_headers: custom-header-1,grpc-status,grpc-message\n                http_filters:\n                  - name: envoy.filters.http.grpc_web\n                    typed_config:\n                      \"@type\": type.googleapis.com/envoy.extensions.filters.http.grpc_web.v3.GrpcWeb\n                  - name: envoy.filters.http.cors\n                    typed_config:\n                      \"@type\": type.googleapis.com/envoy.extensions.filters.http.cors.v3.Cors\n                  - name: envoy.filters.http.router\n                    typed_config:\n                      \"@type\": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router\n  clusters:\n    - name: grpc_service\n      connect_timeout: 0.25s\n      type: LOGICAL_DNS\n      typed_extension_protocol_options:\n        envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n          \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n          explicit_http_config:\n            http2_protocol_options: {}\n      lb_policy: ROUND_ROBIN\n      load_assignment:\n        cluster_name: grpc_service\n        endpoints:\n          - lb_endpoints:\n              - endpoint:\n                  address:\n                    socket_address:\n                      address: host.docker.internal\n                      port_value: 8080\n```\n\n\n\n2. ./config/Dockerfile\n\n```js\nFROM envoyproxy/envoy:v1.28.0\nCOPY ./envoy.yaml /etc/envoy/envoy.yaml\n```\n\n# 단계 6: 앱 실행을 위한 docker-compose.yaml 생성\n\n```js\nversion: '3'\nservices:\n  grpc-server:\n    image: go-grpc-server-with-envoy:latest  # 실제 Go gRPC 서버 이미지 이름과 태그로 변경\n    ports:\n      - \"8080:8080\"  # 컨테이너의 gRPC 포트를 호스트 머신에 매핑\n    networks:\n      - go-grpc-server-with-envoy\n\n  gateway-envoy:\n    build:\n      context: ./envoy/config\n      dockerfile: Dockerfile\n    ports:\n      - '8083:8080'\n\n    networks:\n      - go-grpc-server-with-envoy\n\nnetworks:\n  go-grpc-server-with-envoy:\n```\n\n\n\n백엔드를 Envoy 프록시로 실행하려면:\n\n```js\ndocker-compose up\n```\n\n출력:\n\n![이미지](/assets/img/2024-05-14-BuildingScalableMicroservicesCreatingaGRPCServicewithGoandConsumingitinaReactAppviaEnvoy_1.png)\n\n\n\n# 단계 7: 리액트 앱 생성하기\n\n```js\nnpx create-react-app my-grpc-app\ncd my-grpc-app\n```\n\n# 단계 8: gRPC-Web 및 google-protobuf 플러그인 설치\n\n```js\nnpm install -g protoc-gen-ts\nnpm i protoc-gen-grpc-web\n```\n\n\n\n# 단계 9: 리액트 앱에서 다른 종속성 구성하기\n\n```js\n  \"dependencies\": {\n    \"@grpc/proto-loader\": \"^0.7.10\",\n    \"@testing-library/jest-dom\": \"^5.17.0\",\n    \"@testing-library/react\": \"^13.4.0\",\n    \"@testing-library/user-event\": \"^13.5.0\",\n    \"@types/react\": \"^18.2.47\",\n    \"@types/react-dom\": \"^18.2.18\",\n    \"google-proto-files\": \"^4.0.0\",\n    \"google-protobuf\": \"3.21.2\",\n    \"grpc-web\": \"^1.5.0\",\n    \"protoc-gen-grpc-web\": \"^1.4.2\",\n    \"protoc-gen-ts\": \"^0.8.7\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-scripts\": \"5.0.1\",\n    \"web-vitals\": \"^2.1.4\"\n  }\n```\n\n# 단계 10: 리액트 앱을 위한 GRPC 클라이언트 코드 생성\n\n.proto 파일을 컴파일하여 js 코드를 생성하세요:\n\n\n\n```js\nprotoc -I=src/proto userInfo.proto --js_out=import_style=commonjs,binary:./src/proto --grpc-web_out=import_style=commonjs,mode=grpcwebtext:./src/proto\n```\n\n# 단계 11: React 앱 구성하기\n\nUserDetails.js\n\n```js\nimport React, { Component } from 'react';\nimport { UsrClient } from '../proto/userInfo_grpc_web_pb';\nimport { UserRequest } from '../proto/userInfo_pb';// 생성된 클라이언트 코드를 가져옵니다\n\nclass UserDetail extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            user: null,\n            error: null,\n        };\n    }\n\n    componentDidMount() {\n        const client = new UsrClient('http://localhost:8083'); // 사용 중인 gRPC 서버 URL로 교체해주세요\n\n        // 사용자 이름을 사용해 요청 생성\n        const request = new UserRequest();\n        // 원하는 사용자 이름으로 대체해주세요\n\n        // GetUser RPC 호출\n        client.getUser(request, {}, (err, response) =\u003e {\n            if (!err) {\n                this.setState({ user: response.getUser() });\n            } else {\n                this.setState({ error: '사용자 데이터를 불러오는 중 오류 발생' });\n            }\n        });\n    }\n\n    render() {\n        const { user, error } = this.state;\n\n        return (\n            \u003cdiv\u003e\n                {error ? (\n                    \u003cp\u003eError: {error}\u003c/p\u003e\n                ) : user ? (\n                    \u003cdiv\u003e\n                        \u003ch1\u003e사용자 세부 정보\u003c/h1\u003e\n                        \u003cp\u003e이름: {user.getName()}\u003c/p\u003e\n                        \u003cp\u003e나이: {user.getAge()}\u003c/p\u003e\n                        \u003ch2\u003e주소\u003c/h2\u003e\n                        \u003cp\u003e거리: {user.getAddress().getStreet()}\u003c/p\u003e\n                        \u003cp\u003e도시: {user.getAddress().getCity()}\u003c/p\u003e\n                        \u003cp\u003e주: {user.getAddress().getState()}\u003c/p\u003e\n                        \u003cp\u003e우편번호: {user.getAddress().getZip()}\u003c/p\u003e\n                        {/* 전화번호 정보를 비슷하게 표시할 수 있습니다 */}\n                        \u003cp\u003e업데이트 날짜: {user.getUpdatedAt()}\u003c/p\u003e\n                        \u003cp\u003e생성 날짜: {user.getCreatedAt()}\u003c/p\u003e\n                    \u003c/div\u003e\n                ) : (\n                    \u003cp\u003e로딩 중...\u003c/p\u003e\n                )}\n            \u003c/div\u003e\n        );\n    }\n}\n\nexport default UserDetail;\n```\n\n\n\nApp.js\n\n```js\nimport logo from './logo.svg';\nimport './App.css';\nimport UserDetail from './components/UserDetails';\n\nfunction App() {\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cheader className=\"App-header\"\u003e\n        \u003cimg src={logo} className=\"App-logo\" alt=\"logo\" /\u003e\n        \u003cUserDetail\u003e\n          \n        \u003c/UserDetail\u003e\n      \u003c/header\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n### Step 12: React 앱 빌드 및 실행\n\nReact 앱을 빌드하고 실행하세요.\n\n\n\n```js\nnpm start\n```\n\n결과 -\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildingScalableMicroservicesCreatingaGRPCServicewithGoandConsumingitinaReactAppviaEnvoy_2.png\" /\u003e\n\n# 결론\n\n\n\n본 튜토리얼에서는 Go로 GRPC 서비스를 생성하는 방법, Envoy를 프록시로 구성하는 방법, 그리고 React 앱을 빌드하여 Envoy를 통해 GRPC 서비스와 통신하는 과정을 다루었습니다. 이 설정은 분산 시스템을 구축하는 확장 가능하고 효율적인 방법을 제공합니다. 필요에 따라 서비스 및 React 앱에 더 많은 GRPC 메서드와 기능을 추가하여 이 예제를 확장할 수 있습니다. 즐거운 코딩하세요!\n\n더 많은 정보를 위해 코드를 확인하세요: GitHub","ogImage":{"url":"/assets/img/2024-05-14-BuildingScalableMicroservicesCreatingaGRPCServicewithGoandConsumingitinaReactAppviaEnvoy_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingScalableMicroservicesCreatingaGRPCServicewithGoandConsumingitinaReactAppviaEnvoy_0.png","tag":["Tech"],"readingTime":11},{"title":" Nextjs 142의 새로운 기능을 살펴보세요 ","description":"","date":"2024-05-14 10:12","slug":"2024-05-14-ExplorewhatisnewinNextjs142","content":"\n\n![이미지](/assets/img/2024-05-14-ExplorewhatisnewinNextjs142_0.png)\n\nNext.js 14.2의 로컬 개발용 릴리스 후보인 Turbopack이 여러분의 경험을 업그레이드해줄 준비가 되어 있습니다! 💻\n\n# 주요 포인트:\n\n- 통합 테스트의 99.8%가 통과했습니다 🎉\n- Next.js 앱에서 사용되는 상위 300개 npm 패키지가 Turbopack으로 컴파일될 수 있습니다 📦\n- 모든 Next.js 예제가 매끈하게 작동합니다 🌐\n- Lightning CSS, 빠른 CSS 번들러 및 최소화 도구가 이제 통합되었습니다 🎨\n\n\n\n벌셀닷컴에 미치는 현실적인 영향, 대형 Next.js 앱:\n\n- 로컬 서버 시작 속도가 76.7% 빨라짐 ⚡\n- Fast Refresh로 코드 업데이트가 96.3% 빨라짐 🔥\n- 캐싱 없이 초기 루트 컴파일이 45.8% 빨라짐 🏎️\n\n한 번 시도해보세요:\n\n```js\nnext dev - turbo 🚀\n```\n\n\n\n# 먼저, Turbopack에 대해 간단히 알아봅시다.\n\n## 🌟웹팩의 후속제품, Rust로 만들어진 성공작 🚀\n\nTurbopack은 JavaScript와 TypeScript에 최적화된 혁신적인 점진적 번들러입니다. Rust로 설계되어 어떤 규모의 프로젝트에도 빠르고 적응할 수 있는 개발 경험을 제공합니다.\n\n## Turbopack의 주요 기능\n\n\n\n점진적 번들링: Turbopack가 작업을 완료하면 동일 작업을 다시 하지 않아 개발 프로세스를 최적화하고 시간을 절약합니다.\n\n풍부한 생태계 지원: TypeScript, JSX, CSS, CSS Modules 및 WebAssembly과의 기본적 호환성 제공.\n\n빠른 HMR: 응용 프로그램 크기와 관계없이 빠른 Hot Module Replacement는 효율적인 실시간 업데이트를 보장합니다.\n\nNative React Server Components 지원: Turbopack는 React Server Components를 기본으로 지원하여 통합을 향상시킵니다.\n\n\n\n다중 환경 최적화: 브라우저, 서버, 그리고 엣지와 같은 다양한 환경을 동시에 대상으로 삼아 최적화하며 SSR 및 React 서버 구성 요소를 지원합니다.\n\n# 🏗️ 빌드 및 프로덕션 향상 🚀\n\n## Tree-shaking 개선 사항: 🌳\n\n- 사용되지 않는 익스포트가 제거되어 프로덕션 JavaScript 번들 크기를 줄입니다 📉\n- 예: 단일 아이콘 컴포넌트를 가져오더라도 패키지에서 다른 모든 아이콘을 포함하지 않게 됩니다 🎨\n\n\n\n## 메모리 부족 충돌 방지: 💪\n\n- 대규모 앱을 위해 번들링 로직을 재구성하고 컴파일러를 최적화했습니다.\n- 새로운 `— experimental-debug-memory-usage` 플래그를 `next build`에 추가하여 메모리 성능을 디버그할 수 있습니다. 🔍 즉, 자바스크립트가 힙 사용량 및 가비지 컬렉션 통계와 같은 메모리 사용 정보를 빌드 중에 계속해서 출력합니다.\n\n## CSS 최적화: 🎨\n\n- 스타일 탐색 시 충돌을 피하기 위해 CSS를 청크로 만들었습니다. 🌈\n- CSS 청크의 순서와 병합은 import 순서로 정의되었습니다. 📂\n- 최상의 방법: CSS 모듈을 사용하고 단일 JS/TS 파일에 import하며 동일한 파일에서 전역 스타일을 import 합니다. 📂\n\n\n\n## 🔄 캐싱 개선 💾\n\n- staleTimes (실험적): ⏰ 사용자가 캐싱 휴리스틱에 대한 더 많은 제어를 원하는 현재 경험을 향상시키기 위한 것이나 완전한 솔루션이 되는 것은 아닙니다. (클라이언트 측 라우터 캐시 무효화 기간 설정을 추가 🕰️)\r\n- 기본적으로 prefetch된 라우트는 30초 동안 캐시되지만 prefetch='true'일 때는 5분 동안 캐시됩니다 📅\r\n- 기본 설정을 재정의하려면 next.config.js에서 규칙을 정의하여 사용자 정의할 수 있습니다 🛠️\n\n## 병렬 및 인터셉트 라우트: 🎡\n\n- revalidatePath 또는 revalidateTag를 사용하여 서버 액션을 호출하면 캐시를 재검증하고 보이는 슬롯을 새로고침합니다 🔄\r\n- router.refresh는 올바르게 보이는 슬롯을 새로 고치며 현재 보기를 유지합니다 🌟\n\n\n\n# 🛠️ 개발자 경험 (DX) 개선 사항 🌞\n\n## 에러 메시지 및 스택 추적: 📝 🚧\n\n- `next dev`에서 가독성 향상 🔍\n- 더 나은 에러 메시지, 오버레이 디자인 개선, 라이트 모드 및 다크 모드 지원 🌞🌙\n- 더 명확한 개발 및 빌드 로그 📜\n\n## React 수화 에러: 💧🚧\n\n\n\n- React 팀과의 협업을 통해 기본 오류 추적을 개선합니다 🤝\n- 오류가 발생한 파일 이름을 표시합니다 📂\n\nNext.js 14.2로 업그레이드하면 Turbopack의 성능, 최적화된 빌드, 개선된 캐싱, 더 나은 개발자 경험을 느낄 수 있습니다. 즐거운 코딩하세요! 👨‍💻👩‍💻🚀\n\n# 🎈 Next.js 14.2에서 무슨 변화가 있을까요? 🔍\n\n- 메모리 사용량 개선 🧠\n- 지속적인 캐싱 구현 💾\n- `next build`에 Turbopack 적용 🏗️ 여기서 추적해보세요","ogImage":{"url":"/assets/img/2024-05-14-ExplorewhatisnewinNextjs142_0.png"},"coverImage":"/assets/img/2024-05-14-ExplorewhatisnewinNextjs142_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트를 위한 전문 성능 향상 팁","description":"","date":"2024-05-14 10:11","slug":"2024-05-14-ExpertPerformanceTipsforREACT","content":"\n\n![Expert Performance Tips for REACT](/assets/img/2024-05-14-ExpertPerformanceTipsforREACT_0.png)\n\n웹 사이트의 성능은 사용자 경험, 검색 엔진 순위, 전환율, 비용 효율성, 경쟁 우위 및 접근성에 직접적인 영향을 미치기 때문에 중요합니다. 빠른 로딩 속도의 웹 사이트는 사용자 만족도를 높이고 이탈률을 낮추며 SEO 순위를 향상시킵니다. 또한 높은 전환율, 낮은 운영 비용 및 시장에서의 경쟁 우위를 가져다줍니다. 또한 최적화된 성능은 다양한 인터넷 연결과 장치를 사용하는 사용자를 대상으로하여 포용력을 보장합니다. 전반적으로 성능 최적화를 우선시함으로써 비즈니스 목표 달성과 웹 사이트 방문자에게 가치를 전달하는 것이 중요합니다.\n\n## 1. 비용이 많이 드는 계산에 useMemo 사용하기:\n\nReact 애플리케이션에서 데이터 변환과 같은 계산이 많이 드는 작업을 다룰 때 useMemo 훅을 사용하는 것이 중요합니다. 이를 통해 비용이 많이 드는 계산 결과를 기억하도록 할 수 있으며, 필요할 때만 다시 계산되도록 보장합니다. 종속성을 지정함으로써 언제 계산을 다시해야 하는지 제어하여 성능을 최적화할 수 있습니다.\n\n\n\n```js\nimport React, { useMemo } from 'react';\n\nconst MyComponent = ({ data }) =\u003e {\n  const transformedData = useMemo(() =\u003e {\n    // 여기에서 비싼 데이터 변환 수행\n    return data.map(item =\u003e item * 2);\n  }, [data]);\n  return (\n    \u003cdiv\u003e\n      {/* 변환된 데이터 사용 */}\n    \u003c/div\u003e\n  );\n};\n```\n\n## 2. 메모이제이션된 함수에 useCallback 사용하기:\n\nProps로 전달된 콜백 함수는 메모이제이션되지 않으면 불필요한 다시 렌더링을 유발할 수 있습니다. useCallback 훅을 활용하여 이러한 함수를 메모이제이션함으로써 종속성이 변경될 때까지 자식 구성요소의 다시 렌더링을 방지할 수 있습니다. 이 최적화는 불필요한 렌더링 주기를 줄이며 애플리케이션의 반응성을 향상시킵니다.\n\n```js\nimport React, { useCallback } from 'react';\n\nconst ParentComponent = () =\u003e {\n  const handleButtonClick = useCallback(() =\u003e {\n    // 여기에서 버튼 클릭 처리\n  }, []);\n  return (\n    \u003cChildComponent onClick={handleButtonClick} /\u003e\n  );\n};\n```\n\n\n\n## 3. React.memo를 사용하여 성능 최적화하기:\n\nReact.memo 고차 컴포넌트를 사용하여 함수형 컴포넌트를 최적화할 수 있습니다. 이를 통해 컴포넌트를 기억하고, props가 변경되지 않은 경우 다시 렌더링되지 않습니다. 이 최적화는 특히 정적 props를 받는 컴포넌트의 렌더링 성능을 최적화하는 데 유용합니다.\n\n```js\nimport React from 'react';\n\nconst MyComponent = React.memo(({ prop1, prop2 }) =\u003e {\n  // 컴포넌트를 여기에 렌더링\n});\n```\n\n## 4. 효율적인 렌더링을 위한 가상 목록 사용하기:\n\n\n\n긴 데이터 목록을 렌더링하면 성능에 부정적인 영향을 미칠 수 있습니다. React-window나 react-virtualized와 같은 가상 목록 라이브러리는 화면에 보이는 항목만 렌더링하여 DOM 조작을 최소화하고 렌더링 성능을 획기적으로 향상시킴으로써 이 문제를 해결합니다.\n\n```js\nimport React from 'react';\nimport { FixedSizeList } from 'react-window';\n\nconst MyListComponent = ({ data }) =\u003e {\n  const renderRow = ({ index, style }) =\u003e {\n    const item = data[index];\n    return (\n      \u003cdiv style={style}\u003e{item}\u003c/div\u003e\n    );\n  };\n  return (\n    \u003cFixedSizeList\n      height={300}\n      width={300}\n      itemSize={50}\n      itemCount={data.length}\n    \u003e\n      {renderRow}\n    \u003c/FixedSizeList\u003e\n  );\n};\n```\n\n## 5. 지연로딩을 위한 코드 분할 사용하기:\n\n코드를 작은 관리 가능한 조각으로 분할하고 동적으로 가져오기와 React lazy와 Suspense 구성 요소를 사용하여 지연 시간을 최적화하는 것은 초기 로드 시간을 최적화하는 데 중요합니다. 필요할 때만 필요한 코드를로드함으로써 응용 프로그램의 인지 성능을 향상시킬 수 있습니다.\n\n\n\n```js\nimport React, { lazy, Suspense } from 'react';\n\nconst LazyComponent = lazy(() =\u003e import('./LazyComponent'));\nconst App = () =\u003e {\n  return (\n    \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\n      \u003cLazyComponent /\u003e\n    \u003c/Suspense\u003e\n  );\n};\n```\n\n## 6. React.Fragment를 사용하여 렌더링 최적화:\n\n컨테이너 없이 여러 요소를 렌더링할 때 React.Fragment 또는 그 간략한 구문을 사용하면 추가적인 DOM 노드를 생성하지 않게 됩니다. 이 최적화는 DOM을 가볍게 유지하여 렌더링 성능을 향상시키는 데 도움이 됩니다.\n\n```js\nimport React from 'react';\n\nconst MyComponent = () =\u003e {\n  return (\n    \u003c\u003e\n      \u003cdiv\u003eElement 1\u003c/div\u003e\n      \u003cdiv\u003eElement 2\u003c/div\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n\n\n## 7. 인라인 함수 정의를 피하세요:\n\n렌더 메소드 내에서 함수를 인라인으로 정의하면 각 렌더링마다 새로운 참조를 생성하여 자식 컴포넌트가 불필요하게 다시 렌더링될 수 있습니다. 이러한 함수를 렌더 메소드 외부로 추출하거나 useCallback을 사용하여 메모이제이션함으로써 렌더링 성능을 최적화할 수 있습니다.\n\n```js\nimport React, { useState } from 'react';\n\nconst MyComponent = () =\u003e {\n  const [count, setCount] = useState(0);\n  const handleIncrement = () =\u003e {\n    setCount(count + 1);\n  };\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={handleIncrement}\u003e증가\u003c/button\u003e\n      \u003cp\u003e카운트: {count}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\n```\n\n## 8. 성능 최적화를 위해 React.PureComponent 또는 React.memo를 사용하세요:\n\n\n\nReact.PureComponent 또는 React.memo를 활용하면 깊은 계층의 prop 비교를 수행하여 컴포넌트의 불필요한 다시 렌더링을 방지하는 데 도움이 됩니다. 이 최적화는 특히 클래스 컴포넌트 (PureComponent)와 함수형 컴포넌트 (React.memo로 메모이제이션된)에서 유용하며, prop 비교를 통해 렌더링 오버헤드를 크게 줄일 수 있습니다.\n\n```js\nimport React, { PureComponent } from 'react';\n\nclass MyComponent extends PureComponent {\n  render() {\n    // 여기서 컴포넌트 렌더링하기\n  }\n}\nexport default MyComponent;\n```\n\n## 9. 컴포넌트 프로파일링:\n\nReact DevTools와 같은 React의 내장 프로파일링 도구를 사용하여 컴포넌트에서 성능 병목 현상을 식별하세요. 프로파일링을 통해 불필요한 다시 렌더링이나 비효율적인 상태 관리와 같은 최적화가 필요한 부분을 파악할 수 있습니다.\n\n\n\n## 10. 트리 조정 최적화:\n\n컴포넌트 트리의 깊이를 최소화하고 복잡한 컴포넌트를 작고 관리하기 쉬운 부분으로 나누어 불필요한 렌더링을 피하세요. 이렇게 하면 업데이트 중에 조정해야 할 컴포넌트의 수를 줄여 성능을 향상시킬 수 있습니다.\n\n## 11. 불변 데이터 구조:\n\n불변 데이터 구조인 Immutable.js나 Immer와 같은 것을 사용하여 상태 관리를 최적화하세요. 불변 데이터를 사용하면 상태 변경을 비교하고 컴포넌트를 언제 업데이트해야 하는지 결정하는 것이 더 쉽습니다. 이렇게 하면 더 효율적인 렌더링과 성능 향상이 가능합니다.\n\n\n\n```js\nimport { Map } from 'immutable';\n\nconst initialState = Map({\n  counter: 0,\n  data: Map({}),\n});\n\n// 상태 업데이트\nconst newState = state.update('counter', counter =\u003e counter + 1);\n```\n\n## 12. 서버 측 렌더링 (SSR):\n\n서버 측 렌더링을 구현하여 React 컴포넌트를 서버에서 사전 렌더링하고 정적 HTML을 클라이언트에 제공하십시오. SSR은 초기 로드 시간을 줄이고 검색 엔진 크롤러가 콘텐츠를 효과적으로 색인화할 수 있도록 함으로써 지각된 성능을 향상시킵니다.\n\n## 13. Route-Based Splitting을 사용한 코드 분할:\n\n\n\n페이지 또는 라우트마다 필요한 JavaScript만로드하기 위해 라우트 기반 코드 분할을 구현하세요. 이 기술은 필요할 때 비동기적으로 코드를 로드하여 초기 번들 크기를 줄이고로드 시간을 개선합니다.\n\n```js\nimport { lazy, Suspense } from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\n\nconst Home = lazy(() =\u003e import('./Home'));\nconst About = lazy(() =\u003e import('./About'));\n\nconst App = () =\u003e {\n  return (\n    \u003cRouter\u003e\n      \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\n        \u003cSwitch\u003e\n          \u003cRoute exact path=\"/\" component={Home} /\u003e\n          \u003cRoute path=\"/about\" component={About} /\u003e\n        \u003c/Switch\u003e\n      \u003c/Suspense\u003e\n    \u003c/Router\u003e\n  );\n};\n\nexport default App;\n```\n\n## 14. 디바운싱과 스로틀링:\n\nAPI 요청이나 이벤트 핸들러와 같은 비용이 많이 드는 작업의 빈도를 제한하기 위해 디바운싱과 스로틀링 기술을 사용하세요. 디바운싱은 지정된 지연 후에 함수가 실행되도록 보장하고, 스로틀링은 함수가 호출될 속도를 제한하는데 사용됩니다. 둘 다 성능 병목 현상을 방지할 수 있습니다.\n\n\n\n```js\nimport React, { useState } from 'react';\nimport { debounce, throttle } from 'lodash';\n\nconst SearchInput = () =\u003e {\n  const [searchTerm, setSearchTerm] = useState('');\n\n  // 지연된 검색 처리기\n  const handleDebouncedSearch = debounce(search =\u003e {\n    // 검색 작업 수행\n    console.log('다음을 검색 중입니다:', search);\n  }, 500);\n\n  // 스크롤 쓸대 처리기\n  const handleThrottledScroll = throttle(() =\u003e {\n    // 스크롤 관련 작업 수행\n    console.log('스크롤 중...');\n  }, 100);\n\n  const handleChange = event =\u003e {\n    const { value } = event.target;\n    setSearchTerm(value);\n    handleDebouncedSearch(value); // 지연된 검색\n  };\n\n  return (\n    \u003cinput\n      type=\"text\"\n      value={searchTerm}\n      onChange={handleChange}\n      onScroll={handleThrottledScroll} // 스크롤 쓸대\n    /\u003e\n  );\n};\n\nexport default SearchInput;\n```\n\n## 15. 이벤트 핸들러 최적화:\n\n렌더 메서드 내부에서 요소에 직접 이벤트 리스너를 추가하는 것은 메모리 누수 및 성능 문제를 일으킬 수 있습니다. 대신, 이벤트 위임을 사용하거나 렌더 주기 외부에서 프로그래밍 방식으로 이벤트 리스너를 추가하여 이벤트 처리를 최적화하세요.\n\n```js\nimport React, { useEffect, useRef } from 'react';\n\nconst ScrollListener = () =\u003e {\n  const scrollRef = useRef(null);\n\n  useEffect(() =\u003e {\n    const handleScroll = () =\u003e {\n      // 스크롤 관련 작업 수행\n      console.log('스크롤 중...');\n    };\n\n    // 마운트 시 이벤트 리스너 추가\n    scrollRef.current.addEventListener('scroll', handleScroll);\n\n    // 언마운트 시 이벤트 리스너 제거\n    return () =\u003e {\n      scrollRef.current.removeEventListener('scroll', handleScroll);\n    };\n  }, []); // 빈 종속성 배열은 효과가 한 번만 실행되도록 함\n\n  return (\n    \u003cdiv ref={scrollRef} style={{ overflowY: 'scroll', height: '300px' }}\u003e\n      {/* 스크롤 가능한 콘텐츠 */}\n    \u003c/div\u003e\n  );\n};\n\nexport default ScrollListener;\n```\n\n\n\n## 16. 불필요한 부작용 피하기:\n\n함수형 컴포넌트 내의 부작용에 주의하세요. API 호출이나 상태 변경과 같은 작용은 불필요한 재랜더링을 유발할 수 있습니다. useEffect 훅을 사용하여 적절한 의존성 배열을 설정하여 부작용이 발생하는 시기를 제어하고 컴포넌트 렌더링을 최적화하세요.\n\n## 17. 이미지 최적화:\n\n손실 없는 압축(품질을 희생하지 않고 파일 크기를 줄이는)이나 손실 압축(일부 품질을 희생하면서 파일 크기를 줄이는)과 같은 압축 기술을 사용하여 이미지 파일 크기를 줄이세요. WebP, JPEG XR 또는 AVIF와 같은 이미지 형식을 사용하여 JPEG나 PNG와 같은 전통적인 형식보다 더 나은 압축률과 품질을 제공하세요. 또한 사용자의 기기와 화면 크기에 따라 적절한 크기의 이미지를 제공하기 위해 srcset 및 sizes 속성을 사용하여 반응형 이미지를 서비스하세요. 이를 통해 불필요한 데이터 전송을 줄이고 로딩 시간을 향상시킬 수 있습니다. 화면에 바로 나타나지 않는 이미지에 대해 lazy loading을 구현하여 화면에 나타나면 로드되도록 하여 중요한 콘텐츠를 우선적으로 처리하고 초기 페이지 로딩 성능을 향상시키세요. 마지막으로 사용자의 기기와 네트워크 상황에 따라 이미지를 자동으로 최적화하고 제공하는 이미지 CDN 서비스를 고려해보세요.\n\n\n\n감사합니다. 끝까지 오셔서 기쁩니다.\n\n저랑 소통해요. 이 링크를 클릭해서 더 많이 알아보세요.\n\n다음 블로그를 게시할 때 알림을 받으려면 구독해주세요. 다음에 또 만나요.","ogImage":{"url":"/assets/img/2024-05-14-ExpertPerformanceTipsforREACT_0.png"},"coverImage":"/assets/img/2024-05-14-ExpertPerformanceTipsforREACT_0.png","tag":["Tech"],"readingTime":8},{"title":"Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기","description":"","date":"2024-05-13 00:34","slug":"2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs","content":"\n\n![Node.js Logo](/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png)\n\nNode.js의 핵심에 오신 것을 환영합니다. 여기는 이벤트가 다스리고 비동기가 왕이 되는 곳입니다. 이 시리즈에서는 Node.js의 이벤트 주도 아키텍처를 해독하고 비동기 능력에 대해 자세히 살펴볼 것입니다. 초보자이든 경험이 풍부한 개발자이든 Node.js의 비밀을 해제할 준비를 해주세요. 여정을 시작해봅시다!\n\n1. 이벤트 주도 아키텍처:\n\nNode.js는 이벤트 주도 아키텍처에서 작동하며 작업은 이벤트 루프를 통해 비동기적으로 관리됩니다. 이 루프는 바쁜 교차로에서 교통 규제자와 유사하게 여러 작업을 효율적으로 동시에 처리합니다. 들어오는 요청이나 파일 작업과 같은 이벤트는 논블로킹 방식으로 대기열에 추가되고 처리되어 각 작업이 완료될 때까지 기다릴 필요 없이 원활하게 실행됩니다. 이 아키텍처를 통해 Node.js는 다양한 동시 작업을 효율적으로 처리하여 반응성이 뛰어나고 확장 가능한 애플리케이션을 만들기에 이상적입니다.\n\n\n\n2. Node.js에서 이벤트 처리하기:\n\nNode.js에서는 EventEmitter 클래스를 통해 이벤트 처리를 원활하게 할 수 있습니다. 이 클래스를 사용하면 개발자가 사용자 정의 이벤트를 생성하고 해당 이벤트에 대한 리스너를 붙일 수 있어 응용 프로그램 내에서 비동기 통신을 쉽게 할 수 있습니다.\n\n다음은 Node.js에서 이벤트 처리를 시작하는 방법입니다:\n\n```js\n// EventEmitter 클래스를 가져오기\nconst EventEmitter = require('events');\n\n// EventEmitter 클래스의 인스턴스 생성\nconst myEmitter = new EventEmitter();\n\n// 사용자 정의 이벤트 생성 및 리스너 붙이기\nmyEmitter.on('sayHi', () =\u003e {\n  console.log('Hi!');\n});\n\nmyEmitter.on('sayGoodbye', () =\u003e {\n  console.log('Goodbye!');\n});\n\n// 이벤트 발생\nmyEmitter.emit('sayHi'); // 출력: Hi!\nmyEmitter.emit('sayGoodbye'); // 출력: Goodbye!\n```\n\n\n\n3. 비동기 프로그래밍:\n\n비동기 프로그래밍은 Node.js에서의 기본 개념으로, 작업을 주 프로그램 흐름과 독립적으로 실행할 수 있게 합니다. 이 접근 방식은 I/O 작업, 네트워크 요청 또는 데이터베이스 쿼리와 같이 완료까지 시간이 걸릴 수 있는 작업을 처리할 때 주 프로그램 흐름을 차단하지 않고 다른 작업을 실행하는 데 중요합니다.\n\nNode.js에서 비동기 프로그래밍은 고성능이면서 블로킹되지 않는 애플리케이션을 개발하는 데 필수적입니다. 다음은 Node.js에서 비동기 프로그래밍에 사용되는 주요 메커니즘을 살펴보겠습니다:\n\n- 콜백 함수: 콜백 함수는 다른 함수의 인수로 전달되어 작업이 완료되면 실행됩니다. Node.js에서 비동기 프로그래밍의 기본 구성 요소입니다. 그러나 여러 중첩된 콜백을 관리하는 것은 코드를 읽거나 유지하기 어렵게 만들 수 있는 콜백 지옥에 빠질 수 있습니다.\n- 프로미스: 프로미스는 비동기 작업을 처리하고 콜백 지옥을 줄이는 더 구조화된 방법을 제공합니다. 프로미스는 비동기 작업의 최종 완료(또는 실패)를 나타내며 .then() 및 .catch() 메서드를 사용하여 작업을 연결할 수 있습니다. 프로미스는 코드 가독성과 유지 관리성을 향상시킵니다.\n- Async/Await: Async/Await은 ES2017 (ES8)에서 소개된 구문 설탕으로, 비동기 코드를 더욱 간단하게 작성할 수 있습니다. 이를 사용하면 동기적으로 보이는 비동기 코드를 작성할 수 있어 이해하기 쉽고 유지하기 쉽습니다. Async 함수는 암묵적으로 프로미스를 반환하며, await 키워드는 async 함수 내에서 비동기 작업의 완료를 기다리기 위해 사용됩니다.\n\n\n\n```js\n// 콜백 함수를 사용한 예시\nconst fs = require('fs');\n\nfs.readFile('example.txt', 'utf8', (err, data) =\u003e {\n  if (err) {\n    console.error('파일을 읽는 중 오류 발생:', err);\n    return;\n  }\n  console.log('파일 내용:', data);\n});\n\nconsole.log('파일 읽는 중...');\n\n// 프로미스를 사용한 예시\nconst readFilePromise = new Promise((resolve, reject) =\u003e {\n  fs.readFile('example.txt', 'utf8', (err, data) =\u003e {\n    if (err) {\n      reject(err);\n      return;\n    }\n    resolve(data);\n  });\n});\n\nreadFilePromise\n  .then(data =\u003e {\n    console.log('파일 내용:', data);\n  })\n  .catch(err =\u003e {\n    console.error('파일을 읽는 중 오류 발생:', err);\n  });\n\nconsole.log('파일 읽는 중...');\n\n// Async/Await를 사용한 예시\nasync function readFileAsync() {\n  try {\n    const data = await fs.promises.readFile('example.txt', 'utf8');\n    console.log('파일 내용:', data);\n  } catch (err) {\n    console.error('파일을 읽는 중 오류 발생:', err);\n  }\n}\n\nreadFileAsync();\nconsole.log('파일 읽는 중...');\n```\n\n4. 이벤트 루프의 동작:\n\n이벤트 루프는 Node.js의 핵심으로, 비동기 작업을 효율적으로 실행하는 역할을 합니다. 이벤트 루프의 내부 동작 방식을 간단히 살펴보고, Node.js에서 비동기 작업을 처리하는 방법에 대해 알아봅시다.\n\n1. 이벤트 큐:\n\n\n\n- Node.js에서 I/O 작업이나 타이머와 같은 비동기 작업을 만나면, 이러한 작업은 즉시 실행되지 않습니다.\n- 대신에, 이러한 작업은 이벤트 큐에 들어가서 처리될 차례를 기다립니다.\n\n2. 이벤트 루프 반복:\n\n- 이벤트 루프는 계속해서 반복하면서, 실행 준비가 된 이벤트 큐의 작업을 확인합니다.\n- 이벤트 큐가 비어있다면, 이벤트 루프는 작업이 추가될 때까지 기다립니다.\n\n3. 실행 단계:\n\n\n\n- 이벤트 큐에서 작업이 검색되면 실행 단계로 들어갑니다.\n- 작업이 처리되고 동기 작업인 경우 즉시 실행됩니다.\n\n4. Non-Blocking I/O:\n\n- 비동기 작업인 I/O 작업과 같은 작업의 경우, 이벤트 루프는 작업을 기저 시스템에 위임하여 Node.js가 그 동안 다른 작업을 계속 실행할 수 있도록 합니다.\n- 비동기 작업이 완료되면 해당 작업과 연결된 콜백이 콜백 큐에 배치됩니다.\n\n5. 콜백 큐:\n\n\n\n- 비동기 콜백은 연관된 작업들이 완료된 후에 콜백 큐에 저장됩니다.\n- 이벤트 루프는 각 반복마다 콜백 큐를 확인하여 실행 대기 중인 콜백이 있는지 확인합니다.\n\n6. 콜백 실행:\n\n- 이벤트 루프가 콜백 큐에서 콜백을 만나면 하나씩 검색하고 실행합니다.\n- 이 과정을 통해 비동기 작업이 완료된 순서대로 실행되어 프로그램 로직의 무결성을 유지합니다.\n\n![이미지](/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_1.png)\n\n\n\n- 이벤트 기반 아키텍처:\n\n- Node.js는 이벤트 기반 아키텍처에서 작동하며, 작업들이 이벤트 루프를 통해 비동기적으로 관리됩니다.\n- 이벤트 루프는 이벤트를 대기열에 넣고 처리함으로써 여러 작업을 효율적으로 동시에 처리합니다.\n\n2. Node.js에서 이벤트 처리:\n\n- Node.js는 EventEmitter 클래스를 제공하여 사용자 정의 이벤트를 생성하고 해당 이벤트에 청취자(listener)를 연결할 수 있습니다.\n- 이벤트와 청취자는 Node.js 애플리케이션 내에서 비동기 통신을 용이하게 만듭니다.\n\n\n\n3. 비동기 프로그래밍:\n\n- 비동기 프로그래밍은 주 프로그램 흐름과 독립적으로 작업을 실행할 수 있어 애플리케이션의 응답성을 향상시킵니다.\n- 콜백, 프로미스, 그리고 async/await는 Node.js에서 비동기 작업을 처리하는 데 사용되는 메커니즘입니다.\n- 콜백은 기본적이지만 콜백 지옥에 빠질 수 있습니다. 프로미스와 async/await는 보다 구조화되고 가독성이 좋은 대안을 제공합니다.\n\n4. 이벤트 루프 동작:\n\n- Node.js의 이벤트 루프는 지속적으로 반복하여 이벤트 큐에서 작업을 확인하고 처리합니다.\n- I/O 작업과 같은 비동기 작업은 하부 시스템에 위임되어 Node.js가 여러 동시 작업을 효율적으로 처리할 수 있게 합니다.","ogImage":{"url":"/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png"},"coverImage":"/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png","tag":["Tech"],"readingTime":5},{"title":"워커 스레드 NodeJS에서의 멀티태스킹","description":"","date":"2024-05-13 00:30","slug":"2024-05-13-WorkerThreadsMultitaskinginNodeJS","content":"\n\n## Worker 스레드의 심층 탐구\n\n![WorkerThreadsMultitaskinginNodeJS_0.png](/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_0.png)\n\n안녕하세요! 이 글은 고급 NodeJS를 다루는 시니어 엔지니어 시리즈의 네 번째 글입니다. 이 글에서는 Worker 스레드가 무엇이고, 왜 필요하며, 어떻게 작동하는지 자세하게 설명하고, Worker 스레드를 사용하여 최상의 성능을 얻는 방법에 대해 알려 드리겠습니다. 공식 문서는 worker_threads에서 확인할 수 있습니다. 이 시리즈의 다른 글들도 아래에서 찾아볼 수 있어요:\n\n```js\n글 시리즈 로드맵:\n\n* V8 자바스크립트 엔진\n* NodeJS의 비동기 IO\n* NodeJS의 이벤트 루프\n* Worker Threads: NodeJS에서의 멀티태스킹 (이 글)\n* Child Processes: NodeJS에서의 멀티태스킹\n* 클러스터링과 PM2: NodeJS에서의 멀티태스킹\n* 흔한 NodeJS 오해 허물기\n```\n\n\n\n```js\n목차\n\n* 왜 우리는 모든 일꾼 스레드가 필요한 걸까요?\n* 일꾼 스레드가 무엇인지 이해하려면 필수적으로 알아야 할 것들\n  * 동시성 vs 병렬성\n  * 프로세스와 스레드 이해\n  * 비유\n* 그렇다면 일꾼 스레드가 무엇인가요?\n* 하드웨어 레벨에서 어떻게 작동하는가요?\n* 어떤 것을 사용할 수 있을까요?\n  * isMainThread, threadId\n  * 일꾼 이벤트\n  * 일꾼 옵션\n  * MessageChannel\n  * MessagePort와 MessagePort 이벤트\n  * 스레드 간 데이터 전달 방법\n  * Atomics\n  * 포트 전송\n  * 배열 버퍼 전송\n  * 공유 배열 버퍼를 사용하여 데이터 공유\n* 일꾼 스레드에 유의해야 할 점\n```\n\n# 왜 우리는 모든 일꾼 스레드가 필요한 걸까요?\n\n서버는 CPU 집약적인 작업으로 인해 빠르게 작업량이 증가할 수 있습니다. 예를 들어, 간단하고 CPU 부담이 없는 작업을 수행하는 두 가지 엔드포인트가 있다고 상상해보세요. 다른 하나는 10초가 걸리는 복잡한 CPU 집약적인 작업을 처리하는 반면, 서버가 CPU 집약적인 요청으로 작업 중이라면 CPU 부담이 없는 요청에 즉각적으로 응답할 수 없을 것입니다. 이 문제는 NodeJS의 황금 규칙을 어기기 때문에 발생합니다: 즉, 이벤트 루프를 블록하지 말아라.\n\n우리는 NodeJS가 단일 스레드 아키텍처로 CPU 집약적인 작업에 적합하지 않다는 것을 잘 아고 있습니다. 그러나 이것은 CPU 집약적인 작업에 활용할 수 없다거나 멀티 스레드 아키텍처의 이점을 누릴 수 없다는 의미는 아닙니다. 그렇지 않습니다! 등장하세요 영웅: 일꾼 스레드가 구원에 나서는 거죠...\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*tp7TwTTtOJ1VYmYP9r3whQ.gif)\n\nNode.js v10.5.0에서 worker_threads 모듈을 통해 실험적인 Worker Threads 개념이 소개되었으며, 이후 Node.js v12 LTS부터 안정적인 기능으로 제공됩니다.\n\n# Worker threads가 무엇인지 이해하기 위한 선행 조건\n\n![image](https://miro.medium.com/v2/resize:fit:800/1*qU8qdLnz7iixhKlwcsP9bw.gif)\n\n\n\n## 동시성 대 병렬성\n\n동시성은 한꺼번에 많은 일을 처리하는 것입니다. 병렬성은 한꺼번에 많은 일을 하는 것입니다. — Rob Pike\n\n![image](/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_1.png)\n\n우리는 워커 스레드의 본질을 이해하는 데부터 시작해봅시다: 동시성이 아니라 병렬성입니다. 위의 이미지에서 보듯, 단일 스레드로 여러 작업을 수행하는 것(동시성)은 동시에 실행하는 것(병렬성)에 비해 더 많은 시간이 걸립니다.\n\n\n\n동시성 모델은 네트워크 통신, 파일/데이터베이스 읽기 및 쓰기와 같은 IO 작업에서 유용합니다. 왜냐하면 네트워크나 디스크가 실제 데이터를 제공할 때 기다려야 하기 때문입니다. 그리고 CPU나 스레드는 그 속도를 빠르게 할 수 없습니다. 그래서 대부분의 시간이 대기하는 데 사용됩니다. 그래서 스레드는 그 시간에 다른 일을 할 수 있고 그게 더 의미가 있습니다.\n\n그러나 이 접근 방식은 CPU 집약적인 작업에는 적합하지 않을 수 있습니다. 비록 작업 2가 비교적 빨랐지만, 단일 코어/스레드만 사용했기 때문에 더 많은 시간이 걸렸습니다. 여러 스레드/코어를 활용하여 CPU 집약적인 작업을 작업 스레드에 위임하고, 비 CPU 집약적인 작업을 주 스레드에서 실행함으로써 우리는 더 효율적으로 작업할 수 있었습니다.\n\n## 프로세스와 스레드 이해\n\n![WorkerThreadsMultitaskinginNodeJS_2](/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_2.png)\n\n\n\n프로세스는 운영 체제에서 실행 중인 프로그램입니다. 각각의 프로세스는 자체 메모리를 갖고 있으며 다른 프로세스의 메모리를 볼거나 접근할 수 없습니다. 한 번에 한 가지 작업만 실행될 수 있습니다. 단일 코어 기계에서는 여러 프로세스가 동시에 실행됩니다. 즉, 운영 체제는 규칙적인 간격으로 프로세스 간을 전환합니다. 다중 코어 시스템에서는 운영 체제가 각 프로세스를 동시에 각 코어에서 실행하도록 일정하게 스케줄링합니다. 그러나 코어의 수보다 더 많은 프로세스를 생성하면, 각 코어가 완료될 때까지 동시에 여러 프로세스를 실행합니다.\n\n스레드는 한 번에 한 가지 작업을 실행할 수 있는 프로세스와 유사합니다. 프로세스와 달리 스레드는 자체 메모리를 갖지 않고 프로세스의 메모리 안에 존재합니다. 프로세스를 생성하면 병렬로 코드를 실행하는 여러 스레드가 있을 수 있습니다. 게다가 스레드는 메시지 전달이나 프로세스 메모리 내의 데이터 공유를 통해 서로 통신할 수 있습니다. 이는 스레드를 프로세스에 비해 가볍게 만듭니다. 왜냐하면 스레드 생성 시 운영 체제로부터 더 많은 메모리를 요청하지 않기 때문입니다. 스레드의 실행에 관해서는 프로세스와 유사한 동작을 합니다.\n\n## 비유\n\n요약하자면, 작업자 스레드는 레스토랑에서 주방장과 함께 추가 셰프가 여러 개의 음식을 동시에 준비하는 것과 같습니다.\n\n\n\n![WorkerThreadsMultitaskinginNodeJS_3](/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_3.png)\n\n# 정확히 worker 스레드는 무엇인가요?\n\n이 섹션에서는 worker-threads 모듈을 사용하여 CPU 집약적 작업을 다른 스레드로 옮겨서 메인 스레드를 차단하지 않도록 하는 방법에 대해 알아볼 것입니다. 이를 위해 CPU 집약적 작업을 포함하는 worker.js 파일을 생성합니다. 그리고 parent.js 파일에서는 worker-threads 모듈을 사용하여 스레드를 초기화하고 worker.js 파일에서 작업을 시작하여 메인 스레드와 병렬로 실행될 수 있도록 합니다. 작업이 완료되면 worker 스레드는 결과를 포함한 메시지를 메인 스레드로 다시 보냅니다.\n\nparent.js에 아래와 같은 내용이 있습니다.\n\n\n\n```js\nconst {Worker} = require('worker_threads');\nconst worker = new Worker('./worker.js', {workerData: {num: 5});\nworker.on('message', (result) =\u003e {\nconsole.log('square of 5 is :', result);\n})\nworker.on(\"error\", (msg) =\u003e {\n    console.log(msg);\n });\nconsole.log('hurreyy')\n```\n\n먼저 worker_threads 모듈을 가져와서 Worker 클래스를 언팩합니다. Worker 클래스를 사용하여 new 키워드를 사용해 worker.js 파일 경로를 사용하여 Worker의 새 인스턴스를 생성합니다. 이렇게 하면 새 쓰레드가 만들어지며 worker.js 파일에 있는 코드가 다른 코어에서 쓰레드에서 실행됩니다.\n\n이후, worker 인스턴스에 on(\"message\") 메소드를 사용하여 메세지 이벤트를 듣도록 이벤트를 추가합니다. worker.js 파일에서 결과를 포함하는 메세지를 수신하면 해당 메소드의 콜백으로 전달되어 콘솔에 CPU 작업의 결과가 포함된 응답이 표시됩니다.\n\n그 다음, worker 인스턴스에 on(\"error\") 메소드를 사용하여 오류 이벤트를 듣도록 다른 이벤트를 추가합니다.\n\n\n\n\nworker.js 파일에 대한 설명입니다.\n\n```javascript\nconst {parentPort, workerData} = require('worker_threads');\nparentPort.postMessage(workerData.num * workerData.num)\n```\n\n첫 번째 줄은 worker_threads 모듈을 불러오고 parentPort 클래스를 추출합니다. 이 클래스는 주 스레드에 메시지를 보낼 수 있는 메서드를 제공합니다. WorkerData에는 스레드가 초기화될 때 주 스레드로부터 전달받은 데이터가 포함되어 있습니다. 그런 다음 parentPort 클래스의 postMessage() 메서드를 호출하여, CPU 바운드 작업의 결과가 저장된 제곱 값을 포함한 메시지를 주 스레드로 보냅니다.\n\nnode parent.js로 부모를 실행하면 아래 내용이 표시됩니다.\n\n\n\n\n훔쳐\n5의 제곱은: 25\n\n\n# 하드웨어 안에서 무슨 일이 일어날까요?\n\n\u003cimg src=\"/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_4.png\" /\u003e\n\n이미 알고 있듯이 NodeJS 프로세스가 시작될 때 한 프로세스, 한 스레드, 한 이벤트 루프, 하나의 V8 엔진 인스턴스, 하나의 Node.js 인스턴스와 함께 시작된다는 것을 알고 있습니다. 메인 스레드와 마찬가지로 각 워커는 같은 프로세스 내에서 독자적인 V8, nod, libuv 인스턴스, 그리고 이벤트 루프를 갖게 됩니다.\n\n\n\n\nV8 isolate은 Chrome V8 런타임 내에서 별도의 엔티티를 가리킵니다. 각자의 JS 힙과 마이크로태스크 큐를 보유하고 있죠. 이 독특한 설정 덕분에 모든 Node.js 워커가 다른 워커들로부터 완전히 격리된 상태에서 자체 JavaScript 코드를 실행할 수 있게 되었습니다. 하지만 이런 격리는 비용이 딸리기도 합니다 — 각 워커들은 서로의 힙에 직접적으로 접근할 수 없습니다. 결과적으로 각 워커는 자신만의 libuv 이벤트 루프 버전을 유지하며, 다른 워커들과 부모 워커의 이벤트 루프와 독립적으로 작동합니다.\n\n워커 스레드를 사용하면 스레드가 어느 시점에 종료되더라도 이는 반드시 부모 프로세스의 종료를 의미하지는 않습니다. 워커에 의해 할당된 리소스가 워커가 사라진 후에 남아있는 것은 좋지 않은 관행입니다 — 그렇게 되면 메모리 누수가 발생하게 되고, 우리는 그렇게 하고 싶지 않습니다. 우리는 Node.js를 자체에 넣어주고, Node.js에 새로운 스레드를 생성하고 그 안에 새로운 Node.js 인스턴스를 만들어주고 싶습니다; 결국 동일한 프로세스 내에서 독립적인 스레드를 실행하고 싶은 것입니다.\n\nworker_threads 구현은 애플리케이션이 여러 격리된 JavaScript 워커를 사용할 수 있도록 함으로써 동시성을 제공합니다. 워커들 간 통신 및 부모 워커와의 통신은 Node가 제공하는 것입니다. 주 프로그램과 워커 \"스레드\" 간에는 암시적인 메모리 공유가 없습니다. 대신, 이벤트 기반 메시징 시스템이 제공되어 값들이 프로세스 간에 교환될 수 있게 됩니다.\n\n각 워커는 메시지 채널을 통해 부모 워커에 연결됩니다.\n\n\n\n![이미지](/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_5.png)\n\n작업자 스레드는 뒷면에서 두 가지 구분된 단계로 작동합니다. 첫 번째 단계는 작업자 초기화입니다. 여기서 작업자 인스턴스가 생성되고 부모 및 자식 작업자 간의 초기 통신이 수립됩니다. 이를 통해 부모에서 자식 작업자로 작업자 메타데이터를 전송할 수 있습니다.\n\n이 초기화 메타데이터는 무엇일까요? 이는 작업자 실행 스크립트가 작업자를 시작하는 데 필요한 정보입니다: 작업자로 실행할 스크립트 이름, 작업자 데이터 및 추가 세부 정보입니다. 예를 들어, 이 초기화 메타데이터는 다음과 같은 메시지일 수 있습니다: \"안녕 작업자, worker-simple.js 파일을 'num: 5'와 함께 실행해 줄 수 있을까요?\"\n\n두 번째 단계는 작업자 실행입니다. 여기서 사용자의 작업자 JavaScript 스크립트가 사용자가 제공한 workerData 및 부모 작업자가 제공한 다른 메타데이터를 사용하여 실행됩니다. 이 과정에서 새로운 v8 인스턴스가 생성되고 작업자에 할당됩니다. 그런 다음 libuv가 자체 이벤트 루프로 초기화됩니다. 초기화 메타데이터가 읽히고 worker.js가 실행됩니다.\n\n\n\n# 무엇을 작업할 수 있을까요?\n\n## isMainThread, threadId\n\n워커용 새 파일을 만들고 싶지 않다면 워커 인스턴스 스크립트 경로로 __filename을 전달할 수 있습니다. 이렇게 하면 동일한 파일을 사용할 수 있습니다. 그리고 isMainThread을 사용하여 메인 스레드와 워커 스레드에서 실행하고 싶은 논리를 구분할 수 있습니다. 생성된 객체에는 고유한 threadId 속성이 있습니다.\n\n## 워커 이벤트\n\n\n\nWorker는 우리가 원하는 콜백과 연결할 수 있는 몇 가지 이벤트를 제공합니다.\n\n- 메시지: `message` 이벤트는 워커 스레드가 parentPort.postMessage()를 호출할 때 발생합니다.\n- 종료: `exit` 이벤트는 워커가 중지될 때 발생합니다. 워커가 process.exit()를 호출하여 종료된 경우 exitCode 매개변수는 전달된 종료 코드입니다. 워커가 종료된 경우, exitCode 매개변수는 1입니다. 이는 모든 Worker 인스턴스에서 발생하는 마지막 이벤트입니다.\n- 오류: `error` 이벤트는 워커 스레드가 처리되지 않은 예외를 throw할 때 발생합니다. 이 경우 워커가 종료됩니다.\n- 온라인: `online` 이벤트는 워커 스레드가 JavaScript 코드를 실행하기 시작했을 때 발생합니다.\n\n위 예제는 각 parseJSAsync() 호출을 위해 Worker 스레드를 생성합니다. 실제로는 이러한 작업을 수행할 Worker 풀을 사용하십시오. 그렇지 않으면 Worker를 생성하는 오버헤드가 혜택을 상회할 수 있습니다.\n\n\n\n## Worker 옵션\n\n파일명과 함께 worker를 생성할 때 두 번째 인자로 특정 옵션을 전달할 수 있습니다. const worker = new Worker(__filename, OptionsObject)\n일부 OptionObject 속성은 다음과 같습니다:\n\n- argv: worker에 process.argv에 추가되기 전 문자열화 및 연결될 인수 목록입니다. 이것은 대부분 workerData와 유사하지만, 값은 CLI 옵션으로 스크립트에 전달된 것처럼 전역 process.argv에서 사용할 수 있습니다.\n- workerdata: 워커 스레드에 전달하려는 데이터입니다. 이 데이터는 HTML 구조화된 클론 알고리즘을 사용하여 복제됩니다.\n- transferList: ArrayBuffer, MessagePort, FileHandle, X509Certificate, Blob로 이루어진 항목의 배열입니다. workerData에 하나 이상의 MessagePort와 같은 객체가 전달된 경우, 해당 항목에 대해 transferList가 필요하며, 전달되지 않은 경우에는 ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST가 throw됩니다. 자세한 내용은 아래에서 더 다루겠습니다.\n- env: 설정된 경우 Worker 스레드 내부의 process.env의 초기값을 지정합니다. 특별한 값으로 worker.SHARE_ENV를 사용하여, 부모 스레드와 자식 스레드가 환경 변수를 공유해야 함을 지정할 수 있으며, 이 경우 한 스레드의 process.env 객체에 대한 변경 사항은 다른 스레드에도 영향을 줍니다.\n- resourceLimits: 새 JS 엔진 인스턴스에 대한 리소스 제한의 선택적 집합입니다. 이러한 제한에 도달하면 Worker 인스턴스가 종료됩니다. 이러한 제한은 JS 엔진에만 영향을 미치며, ArrayBuffer를 포함한 외부 데이터는 영향을 받지 않습니다. 이러한 제한을 설정해도 전역 메모리 부족 상황을 만나게 되면 프로세스가 중단될 수 있습니다. 제약 사항 중 일부는 maxYoungGenerationSizeMb (MB의 메인 힙의 최대 크기), maxOldGenerationSizeMb, codeRangeSizeMb, stackSizeMb입니다.\n- name: 디버깅 / 식별 목적을 위해 워커 제목 뒤에 추가할 수 있는 선택적 이름이며, 최종 제목은 [worker $'id'] $'name'입니다. 기본값: ``.\n\n## MessageChannel\n\n\n\n쓰레드 간 통신을 위해 중요한 두 가지 구성 요소가 있습니다. 통신 채널과 통신할 포트입니다. 먼저 통신하기 전에 통신 채널인 MessageChannel을 설정해야 합니다. MessageChannel은 비동기, 양방향 통신 채널입니다. MessageChannel에는 별도의 메서드가 없습니다. new MessageChannel()은 port1과 port2 속성을 갖는 객체를 반환하는데, 이 속성들은 연결된 MessagePort 인스턴스를 가리킵니다. 기본적으로 port1과 port2는 채널의 두 끝점에 해당합니다.\n\n```js\nconst { MessageChannel } = require('node:worker_threads');\n\nconst { port1, port2 } = new MessageChannel();\nport1.on('message', (message) =\u003e console.log('received', message));\nport2.postMessage({ foo: 'bar' });\n// Prints: received { foo: 'bar' } from the `port1.on('message')` listener\n```\n\n메시지를 보내는 용도로 한 포트를 사용하고, 메시지를 수신하는 용도로 다른 포트를 사용합니다. 기본적으로 port1과 port2는 채널의 두 끝점에 해당합니다.\n\n[Worker Threads in Node.js](/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_6.png)\n\n\n\n## MessagePort 및 MessagePort 이벤트\n\n이전에는 worker에서 부모로 메시지를 보내기 위해 `parentPort.postMessage()`를 사용했고 worker에서 메시지를 보내기 위해 `worker.postMessage()`를 사용했습니다. 이는 부모Port와 Worker가 모두 MessagePort 클래스의 인스턴스이기 때문입니다. 이 제공된 postMessage 및 message, close와 같은 이벤트들은 콜백을 태깅할 수 있습니다.\n\n- message: 어떠한 수신 메시지에 대해 이벤트가 발생합니다.\n- close: 채널의 어느 한 쪽이 연결을 해제했을 때 이벤트가 발생합니다.\n\n```js\nconst { MessageChannel } = require('node:worker_threads');\nconst { port1, port2 } = new MessageChannel();\n\n// 출력:\n//   foobar\n//   closed!\nport2.on('message', (message) =\u003e console.log(message));\nport2.on('close', () =\u003e console.log('closed!'));\n\nport1.postMessage('foobar');\nport1.close();\n```\n\n\n\n## 쓰레드 간 데이터 전달 방법\n\n- 데이터 복제\n두 개의 쓰레드 간 데이터를 전달하는 여러 가지 방법이 있습니다. 기본적으로 이 데이터는 복제됩니다. 즉, 송신자와 수신자가 데이터의 각각 고유한 사본을 갖게 됩니다. 이 데이터는 '구조화된 복제 알고리즘'을 통해 복제됩니다. 전달되는 데이터가 깊게 중첩된 경우 데이터를 복제하는 데 상당한 처리 능력이 필요할 수 있습니다. 따라서 데이터의 사본을 만들어 두는 것이 항상 최적적이라고 할 수 없습니다.\n- 데이터 전송\n위의 단점을 극복하는 한 가지 방법은 데이터를 전송하는 것입니다. transferList 옵션을 사용하여 이를 달성할 수 있습니다. transferList를 사용하면 송신자가 수신자에게 데이터를 직접 제공할 수 있습니다. 이렇게 하면 송신자의 쪽에서 해당 데이터에 액세스할 수 없게 됩니다.\ntransferList는 ArrayBuffer, MessagePort 및 FileHandle 객체의 목록일 수 있습니다. 전송 후에는 채널의 보내는 쪽에서 더 이상 사용할 수 없습니다 (value에 포함되어 있지 않더라도 해당됨). 네트워크 소켓과 같은 핸들을 전송하는 것은 현재 지원되지 않습니다 (이것은 자식 프로세스와 함께 가능합니다).\n- 동일한 데이터 공유\nSharedArray Buffer를 사용하여 송신자와 수신자 간에 동일한 데이터를 공유할 수 있습니다.\n\n## 원자성\n\n워커 또는 메인 쓰레드에서 동시에 공유 메모리를 생성하고 업데이트할 수 있으며, 이로 인해 경쟁 조건과 동기화 문제가 발생할 수 있습니다. 이 문제를 피하기 위해 Atomics를 사용할 수 있습니다. 메모리가 공유되면 여러 쓰레드가 메모리에서 동일한 데이터를 읽거나 쓸 수 있습니다. 원자 연산은 다음 연산이 시작되기 전에 작업이 완료되도록 하며, 작업이 중단되지 않도록 합니다.\nnew 연산자로 사용하거나 Atomics 객체를 함수처럼 호출할 수 없습니다. Atomics의 모든 속성과 메소드는 정적(static)입니다 (Math 객체와 마찬가지로).\n\n\n\nAtomics.load(): 배열의 지정된 인덱스에서 값 반환. 인덱스의 '게터'의 한 종류.\nAtomics.store(): 배열의 지정된 인덱스에 값 저장. 값 반환.\nAtomics.and()/Atomics.or()/Atomics.sub()/Atomics.xor()/Atomics.add(): 비트 연산\nAtomics.notify()/Atomics.wait(): 특정 조건이 충족될 때까지 대기하는 방법을 제공하며 일반적으로 블로킹 구조로 사용됨.\n\n이제 다양한 방법으로 데이터를 전달해 봅시다\n\n## 포트 전송\n\n이것은 일반적으로 전송 목록에서 포트를 전달하고 싶을 때 유용합니다. 이제 왜 그렇게 하고 싶을까요? 이 방법을 통해 메시지 채널을 재사용할 수 있습니다. 이를 해보겠습니다.\n\n\n\nIn parent.js\n\n```js\n// parent.js\n\nconst { Worker, MessageChannel } = require('worker_threads');\nconst { port1, port2 } = new MessageChannel()\n\nconst worker = new Worker('./worker.js')\nport1.on(\"message\", msg =\u003e {\n    console.log(`Worker로부터 온 메시지 ----\u003e ${msg}`)\n})\nworker.postMessage({ port: port2}, [port2])\n```\n\nIn worker.js\n\n```js\n// worker.js\n\nconst {parentPort} = require('worker_threads');\nparentPort.on(\"message\", msg =\u003e {\n    msg.port.postMessage('전달된 포트를 사용하여 Hi를 보냈습니다')\n})\n```\n\n\n\n워커로부터의 메시지: Sent Hi from using transfered port\n\n## 배열 버퍼를 사용한 데이터 전송\n\n배열 버퍼(Array Buffer)는 고정 길이 및 연속된 메모리 영역이며 한 번 길이가 선언되면 변경할 수 없습니다. 보통 배열처럼 내부 값을 직접 액세스할 수 없고 데이터 뷰(Data view)라는 것이 필요합니다. 데이터 뷰는 선언된 배열 버퍼를 볼 때 어떤 렌즈로 보는지에 대한 것입니다. \n\n예를 들어, 16바이트 배열 버퍼를 선언한다면 (16바이트 === 128비트),\n```javascript\nconst arrayBuffer = new ArrayBuffer(16)\n```\n\n이제 이 128비트를 어떤 렌즈로 볼 것인지 다음과 같은 방법으로 할 수 있습니다. \n이 128비트를 8 * 16 블록 즉, 8비트 정수 배열로 볼 수 있습니다.\n```javascript\nconst dataview = new Int8Array(arrayBuffer, 0, 16)\n```\n\n또는,\n이 128비트를 16 * 8 블록 즉, 16비트 정수 배열로 볼 수 있습니다.\n```javascript\nconst dataview = new Int16Array(arrayBuffer, 0, 8)\n```\n\n또는,\n이 128비트를 32 * 4 블록 즉, 32비트 정수 배열로 볼 수 있습니다.\n```javascript\nconst dataview = new Int32Array(arrayBuffer, 0, 4)\n```\n\n이러한 Int8Array, Int16Array, Int32Array, Int64Array는 배열 버퍼 내부 데이터를 다양하게 표현하기 위한 배열 유형(Types arrays)이라고 불립니다.\n\nparent.js에서\n\n\n\n```js\nconst { Worker } = require('worker_threads');\n\nconst worker = new Worker('./worker.js')\nconst arrayBuffer = new ArrayBuffer(16)\nconst dataview = new Int8Array(arrayBuffer, 0, 16) // all 0 by default\nconsole.log('부모 안에서 전송하기 전' + dataview)\nworker.postMessage(dataview, [dataview.buffer])\n// console.log('부모 안에서 전송 후' + dataview)\n```\n\nworker.js 파일 내용\n\n```js\nconst { parentPort } = require('worker_threads');\nparentPort.on(\"message\", msg =\u003e {\n    console.log('전송 후 워커 내에서' + msg)\n})\n```\n\n위 코드를 실행하면 출력은 다음과 같습니다.\n\n\n\n\n\u003cimg src=\"/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_7.png\" /\u003e\n\n그래서 데이터가 전송되었다는 것을 증명하는 것이죠.\n만약 parent.js의 마지막 줄의 주석을 해제한다면, parent.js가 이미 전송된 배열 버퍼에 액세스할 수 없다는 것을 보여주는 다음 오류가 발생할 겁니다.\n\n\u003cimg src=\"/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_8.png\" /\u003e\n\n## SharedArray buffer를 사용하여 데이터 공유하기\n\n\n\n이제 배열 버퍼를 전송해 봅시다.\n부모.js 파일에서 다음과 같이 작성하세요.\n\n```js\nconst { Worker } = require('worker_threads');\n\nconst worker = new Worker('./worker.js')\nconst sharedArrayBuffer = new SharedArrayBuffer(16)\nconst dataview = new Int8Array(sharedArrayBuffer, 0, 16) // 기본적으로 모두 0\nconsole.log('부모 안에서 공유하기 전' + dataview)\nworker.postMessage(dataview)\nconsole.log('부모 안에서 공유한 후' + dataview)\n```\n\nworker.js 파일에서는 다음과 같이 작성하세요.\n\n```js\nconst {parentPort} = require('worker_threads');\nparentPort.on(\"message\", msg =\u003e {\n    console.log('작업자 안에서 공유한 후' + msg)\n})\n```\n\n\n\n![WorkerThreadsMultitaskinginNodeJS_9](/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_9.png)\n\n이번에는 부모로부터 온 마지막 로그가 발생하지 않습니다. 데이터가 실제로 공유되고 전송되거나 복사되지 않기 때문입니다.\n\n# 워커 스레드 주의사항\n\n- NodeJS 워커 스레드는 일반적인 스레드가 아닙니다. 다른 언어의 멀티스레딩과 같이 멀티스레딩이 되기를 기대한다면, 기본적으로 스레드는 동일한 상태를 공유해야 합니다. Node.js 워커 스레드는 자체 V8, libuv 인스턴스, 이벤트 루프 및 별도의 힙을 가지는 다른 워커 스레드와 독립적으로 작동합니다.\n- IO에 워커 스레드를 사용하는 것은 무의미합니다. 워커 프로세스를 생성하고 유지하는 비용은 Node의 비동기 I/O 구현보다 효율적이지 않습니다.\n- 워커 스레드는 성능 절약이 프로세스 생성 비용보다 쉽게 상쇄될 수 있는 경우에 사용해야 합니다.\n- 공유 워커 스레드 풀을 활용하면 비효율성을 줄이고 새로 생성하는 필요성을 제거할 수 있습니다. 이 접근 방식은 시간과 자원을 절약할 뿐만 아니라 워커 풀의 관리를 단순화시킵니다. Piscina와 Poolifier와 같은 라이브러리는 워커 풀을 관리하는 복잡성을 처리하여 더 중요한 작업에 집중할 수 있도록 해줍니다.\n- 워커 스레드의 디버깅은 이벤트, 해당 워커 및 결과적인 영향 사이의 명확한 연결 부재로 인해 매우 어려울 수 있습니다. 디버깅을 위해 console.log() 문으로만 의존하는 것은 지루하고 오류가 발생하기 쉽습니다. 그러나 문제 해결에 도움이 되는 솔루션이 있습니다. 풀에 AsyncResource를 첨부하여 편집되어진 비동기 스택 추적을 제공받을 수 있습니다. 이 가치 있는 도구를 사용하면 풀 내에서 발생한 활동을 정확하게 추적하는 상세한 비동기 스택 추적을 확인할 수 있습니다.\n- 자식 프로세스 또는 워커 스레드를 사용할지 헷갈릴 때, CPU 집중 작업에는 워커 스레드를 사용하고 앱을 확장하려면 자식 프로세스를 사용하세요.\n- 코어의 수보다 많은 스레드를 생성하면 성능 향상이 크지 않을 것입니다. CPU 활용률이 컨텍스트 전환에서 소비되기 때문입니다. 이런 이유로 스레드 풀을 신중하게 사용해야 합니다.\n- Piscina, Bree, Poolifier, WorkerPool 등 많이 사용되는 라이브러리들은 모듈을 더 편리하게 사용할 수 있도록 랩핑하거나 스레드 풀링과 같은 상위 수준의 기능을 제공합니다.\n\n\n\n## 참고 자료\n\n- [Node.js Worker Threads에 대한 심층적 탐구](https://blog.insiderattack.net/deep-dive-into-worker-threads-in-node-js-e75e10546b11)\n- [Node.js 스레드 풀 깊이 파헤치기](https://betterprogramming.pub/a-deep-dive-into-the-node-js-thread-pool-a1f32a4f8628)\n- [YouTube 영상 - Worker Threads 소개](https://www.youtube.com/watch?v=-JE8P2TiJEg)\n- [YouTube 영상 - Node.js 멀티스레딩 사용법](https://www.youtube.com/watch?v=P1sWw1bLyVg)\n- [Node.js 공식 블로그 - Worker Threads 소개](https://nodesource.com/blog/worker-threads-nodejs/)\n- [DigitalOcean 커뮤니티 - Node.js에서 멀티스레딩 사용 방법](https://www.digitalocean.com/community/tutorials/how-to-use-multithreading-in-node-js)\n- [Snyk 블로그 - Worker Threads를 활용한 Node.js 멀티스레딩](https://snyk.io/blog/node-js-multithreading-with-worker-threads/)\n- [Snyk 블로그 - Node.js Worker Threads 장단점](https://snyk.io/blog/node-js-multithreading-worker-threads-pros-cons/)\n- [YouTube 영상 - Node.js Worker Threads 사용 예시](https://www.youtube.com/watch?v=kDr7YycaZ5E)\n- [Stack Overflow 질문 - Node.js Worker Thread가 생성될 때 같은 코어를 이용하는가?](https://stackoverflow.com/questions/61831510/when-a-workerthread-is-created-in-nodejs-does-it-utilize-the-same-core-in-which)\n\n# 떠나시기 전에!\n\n- 추가 정보 받아보세요! 팔로우하고 구독해주세요.\n- 👏 버튼을 클릭하고 길게 누르면 무슨 일이 일어나는지 보셨나요?","ogImage":{"url":"/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_0.png"},"coverImage":"/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_0.png","tag":["Tech"],"readingTime":17},{"title":"자바스크립트의 숨은 보석 돌연변이 감시자의 힘 탐구","description":"","date":"2024-05-13 00:28","slug":"2024-05-13-JavaScriptsHiddenGemExploringthePowerofMutationObserver","content":"\n\n![Javascript Hidden Gem](/assets/img/2024-05-13-JavaScriptsHiddenGemExploringthePowerofMutationObserver_0.png)\n\n# 웹사이트 변화의 호기심 깊은 사례\n\n경험이 풍부한 웹 개발자로 상상해보세요. 정교한 웹 애플리케이션을 작업 중입니다. 어느 날, 당신은 웹사이트의 행동에서 예상치 못한 변화를 발견합니다. 요소들이 이동하고, 스타일이 변경되는데, 여러분의 코드 한 줄로 인해 그렇게 되는 것이 아닙니다. 호기심을 자극받고 약간 헷갈리는 기분을 느끼며, 당신은 이 신비를 밝혀내기 위한 여정을 시작합니다. 이 여정은 JavaScript의 변이 감지자(Mutation Observer) 발견으로 이어집니다. 이 도구를 사용하면 돔(DOM)을 수맷돌처럼 지켜보고, 실시간으로 변경 사항에 대응할 수 있습니다. 이것이 동적 콘텐츠를 처리하는 방법을 혁신할 수 있다는 것을 깨닫게 됩니다.\n\n# 변이 감지자의 핵심으로의 여정\n\n\n\n조용한 저녁에 돌연변이 감시자(Mutation Observer)의 핵심 개념에 깊이 파고들었군요. 이것은 JavaScript API의 중요한 부분으로, DOM의 변화를 감시하기 위해 설계된 것입니다. DOM을 지키는 감시병 같은 존재로, 어떤 수정 사항이 있을 때 당신에게 경보를 울립니다. 오늘날의 동적 웹 환경에서 변동이 페이지 다시로드 없이 발생할 수 있는데, 이런 변화를 효율적으로 관리하고 원활한 사용자 경험을 보장하는 데 도움이 되는 중요한 요소임을 이해하게 됐습니다.\n\n# 첫 번째 돌연변이 감시자 소환하기\n\n이 새로운 도구를 탐험하고 싶어서, 첫 번째 돌연변이 감시자를 생성하기로 결심했군요. 이 작업은 놀랍도록 간단합니다. 감시할 DOM 요소를 선택하고 감시할 돌연변이 유형을 정의하는 것으로 시작합니다. 아래는 설정하는 방법입니다:\n\n```js\n// 감시할 노드 선택\nconst targetNode = document.getElementById(\"dynamicContentArea\");\n\n// 감시자를 위한 구성 정의\nconst config = { attributes: true, childList: true, subtree: true, characterData: true };\n\n// 돌연변이를 처리하는 콜백 함수 생성\nconst callback = function(mutationsList) {\n  for (const mutation of mutationsList) {\n    if (mutation.type === \"childList\") {\n      console.log(`자식 노드 개수 변화: ${mutation.addedNodes.length}개의 노드가 추가됨`);\n    } else if (mutation.type === \"attributes\") {\n      console.log(`속성이 변경됨: ${mutation.attributeName}`);\n    } else if (mutation.type === \"characterData\") {\n      console.log(\"노드 내의 텍스트 내용이 변경됨\");\n    }\n  }\n};\n\n// 돌연변이 감시자 생성\nconst observer = new MutationObserver(callback);\n\n// 감시 시작\nobserver.observe(targetNode, config);\n```\n\n\n\n당신은 관측자가 그 역할을 시작하는 것을 기다리면서 기대감에 가득 차 보고 있습니다. 대상 요소에서 DOM 변경 사항을 보고할 준비가 되어 있습니다.\n\n# DOM 왕국 관찰하기\n\n당신의 관측자가 경비를 지키는 동안, 당신은 그가 감지할 수 있는 다양한 종류의 변이를 탐험합니다. 새로운 요소가 DOM으로 몰래 들어오려는 경우, 속성이 외관을 변경하려는 경우, 또는 텍스트 내용이 조용히 메시지를 변경하는 경우까지 알려주는 수호자 같다는 것을 깨닫게 됩니다. 이것을 실제로 보기 위해 다양한 시나리오를 실험하며 요소를 수정하고 콘솔 로그를 관찰해 봅니다.\n\n예를 들어, 새로운 요소 추가를 시도해 봅니다:\n\n\n\n```js\n// 감시 영역에 새 요소를 추가합니다\nlet newNode = document.createElement(\"p\");\nnewNode.textContent = \"새 단락!\";\ntargetNode.appendChild(newNode);\n```\n\n그리고 시간이 지나면, 당신의 감시자가 추가를 보고할 것입니다.\n\n# 감시자 세부 조정하기\n\n감시자의 효율성을 향상시키기 위해 구성 옵션을 탐구합니다. 특정 요구 사항에 맞게 조정하여 특정 변형 유형에 집중함으로써 성능을 최적화하는 방법을 배울 수 있습니다. 예를 들어, 속성 변경에만 관심이 있다면, 구성을 해당 내용에 맞게 수정하면 됩니다:\n\n\n\n```js\r\n// 설정을 조정하여 속성 변경만 관찰하도록 함\nconst attributeConfig = { attributes: true };\n\n// 새 설정으로 관찰 재시작\nobserver.disconnect(); // 기존 observer를 먼저 연결 해제\nobserver.observe(targetNode, attributeConfig);\r\n```\n\n이 집중된 방식으로 observer를 더 전문화되고 효율적으로 만듭니다.\n\n# 변이 레코드 해독\n\n감시하는 각 변이는 변이 레코드를 가져옵니다. 변이 레코드는 변경된 내용, 변경된 위치 및 방법에 대한 자세한 보고서입니다. 이러한 레코드를 구문 분석하여 소중한 통찰을 추출합니다. 이들은 DOM 내의 동적 변화를 이해하는 열쇠를 갖고 있습니다. 보다 명확한 그림을 얻기 위해 콜백을 수정하여 더 자세한 정보를 기록합니다:\n\n\n\n```js\nconst detailedCallback = function(mutationsList) {\n  for (const mutation of mutationsList) {\n    console.log(\"Mutation detected:\", mutation);\n    if (mutation.type === \"attributes\") {\n      console.log(`Old attribute value: ${mutation.oldValue}`);\n    }\n  }\n};\n\n// 업데이트된 콜백으로 옵저버 설정\nobserver.disconnect();\nobserver = new MutationObserver(detailedCallback);\nobserver.observe(targetNode, config);\n```\n\n이 향상된 로깅은 각 변이에 대한 포괄적인 정보를 제공하여 당신을 해결해야 할 문제를 발견하는 탐정으로 만들어줄 것입니다.\n\n# 변이 관찰의 예술을 마스터하기\n\n변이 옵저버와의 여정이 점점 끝나가는 가운데, 당신은 습득한 깊은 통찰과 기술에 대해 반성합니다. 궁금한 변화의 관찰자에서 DOM 변경 사항을 감시하고 대응하는 마스터로 전환했습니다. 변이 옵저버에 대한 새로운 이해는 초기 미스터리를 해결할 뿐만 아니라 웹 개발에서의 가능성을 열어 주었습니다.\n\n\n\nMutation Observer의 설정 및 구성에 대한 기술을 배웠습니다. 그리고 이를 특정 필요에 맞게 맞추고 변이 레코드를 효율적으로 처리하는 법을 익혔습니다. 이 과정에서 성능과 기능성의 균형을 유지하는 중요성을 깨달았습니다. 웹 애플리케이션이 효율적이고 반응성을 유지할 수 있도록 해야 한다는 것을 알게 되었습니다.\n\n하지만 여기서 여행은 끝나지 않습니다. 웹 개발의 영역은 끊임없이 발전하고 있으며, Mutation Observer는 여러분의 방대한 도구 상자 속의 하나뿐입니다. 배울 점은 더 많고, 탐험할 것도 더 많습니다. 웹 애플리케이션을 계속해서 구축하고 향상시킬 때, Mutation Observer에서 얻은 교훈은 여러분이 웹 개발의 동적이고 흥미로운 풍경을 탐험할 때 도와줄 유일한 빛이 될 것입니다.\n\n다른 개발자들과 교환하고 지식을 공유하면서, 그들에게 Mutation Observer의 탐험을 촉구합니다. 함께 여러분은 가능한 범위를 넓혀가며 상호작용적이고 동적이며 사용자 친화적인 웹 경험을 구축할 것입니다.\n\n그래서 성취감과 미래 모험에 대한 기대감을 가지고 이 장을 마치며, 새로운 도전과 기회에 여러분의 전문 지식을 적용할 준비가 되어 있습니다.\n\n\n\n# 🔥 이 개발자 글이 유용했나요? 🔥\n\n이런 심층 가이드 작성은 시간, 헌신, 그리고 네, 풍부한 커피가 필요해요! 만약 이 글이나 다른 글들이 여러분의 개발자 여정에 가치를 더했다면, 감사를 표시해주고 싶다면 고려해 보세요.\n\n👉 제 노력을 지원하고 커피 한 잔 사주세요! https://www.buymeacoffee.com/svetloslav ☕\n\n여러분이 기부해주는 각 커피는 이런 글이 더 나올 수 있도록 보장해줘요. 이 여정에 함께해 주셔서 감사합니다!\n\n\n\n# 평문으로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수 치고 팔로우 해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-05-13-JavaScriptsHiddenGemExploringthePowerofMutationObserver_0.png"},"coverImage":"/assets/img/2024-05-13-JavaScriptsHiddenGemExploringthePowerofMutationObserver_0.png","tag":["Tech"],"readingTime":5},{"title":"5가지 팁과 트릭으로 Nextjs 14와 함께 더 쉽게 살아가는 방법","description":"","date":"2024-05-13 00:27","slug":"2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier","content":"\n\n![이미지](/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_0.png)\n\nNext.js 14은 서버 렌더링된 React 애플리케이션을 구축하는 프로세스를 간단화하는 강력한 React 프레임워크입니다. 그러나 고급 기능과 규칙 때문에 특히 이 프레임워크에 처음 접하는 개발자들에게 혼란과 모호함이 있을 수 있습니다. 이 블로그 포스트에서는 Next.js 14를 사용하여 일상을 더 편리하게 만드는 다섯 가지 팁과 요령을 살펴보겠습니다.\n\n## 팁 1: Next.js 이미지 작업\n\nNext.js에서 이미지 처리는 혼란스러운 부분입니다. 로컬 이미지 또는 원격 이미지와 작업하는 방법은 다르기 때문입니다.\n\n\n\n# 로컬 이미지\n\n로컬 이미지를 사용할 때는 너비와 높이를 지정할 필요가 없어요. Next.js가 자동으로 이미지 크기를 확인합니다. 이미지를 가져와 `next/image` 컴포넌트를 사용해 렌더링하세요.\n\n```js\nimport Image from \"next/image\";\nimport localImage from \"public/hoy.png\";\nexport default function MyComponent() {\n  return \u003cImage src={localImage} alt=\"로컬 이미지\" /\u003e;\n}\n```\n\n\n\n# 원격 이미지\n\n![Remote Image](/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_2.png)\n\n원격 이미지를 사용할 때는 레이아웃 변동을 방지하기 위해 블러 플레이스홀더를 제공하고 너비와 높이를 지정해야 합니다. `placeholder=\"blur\"` 속성을 사용하여 이미지의 완전한 버전이 로드될 때까지 이미지의 흐린 버전을 표시할 수 있습니다.\n\n원격 이미지의 블러 데이터 URL을 생성하려면 `sharp` 및 `placeholder` 패키지를 사용할 수 있습니다:\n\n\n\n```js\nimport Image from \"next/image\";\nimport getBase64 from \"./utils/getBase64\";\nexport default async function MyComponent() {\n  const blurDataUrl = await getBase64(remoteImageUrl);\n  return (\n    \u003cImage\n      src={remoteImageUrl}\n      width={600}\n      height={600}\n      alt=\"Remote Image\"\n      placeholder=\"blur\"\n      blurDataURL={blurDataUrl}\n    /\u003e\n  );\n}\n```\n\n`getBase64` 유틸리티 함수는 원격 이미지를 가져와 ArrayBuffer로 변환한 다음 `placeholder` 패키지를 사용하여 해당 이미지의 base64 표현을 생성합니다.\n\n# 팁 2: 환경 변수 처리\n\n환경 변수를 `next.config.env.NEXT_PUBLIC_*`로 표시할 때 주의하십시오. 이러한 변수는 브라우저에서 노출되며 JavaScript 번들에 포함됩니다. 민감한 API 키나 비밀 정보가 있는 경우 `NEXT_PUBLIC_`로 접두사를 붙이지 않도록 주의하십시오. Node.js 환경에서만 사용할 수 있게 됩니다.\n\n\n\n# 팁 3: Next.js에서 캐싱 이해하기\n\n![이미지](/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_3.png)\n\nNext.js의 캐싱 동작은 개발 환경과 프로덕션 환경에서 다릅니다. 개발 모드에서는 기본적으로 페이지가 동적으로 매 요청마다 렌더링됩니다. 그러나 프로덕션 모드에서는 Next.js가 페이지를 정적으로 렌더링하려고 시도합니다.\n\n프로덕션에서 캐싱을 제어하려면 `revalidate` 옵션을 사용하거나 페이지를 명시적으로 `dynamic`으로 표시할 수 있습니다.\n\n\n\n```js\n// 매 5초마다 다시 유효성 검사\nexport const revalidate = 5\n// 동적 렌더링 강제\nexport const dynamic = 'force-dynamic'\n```\n\n# 팁 4: 서버 컴포넌트에서 데이터 가져오기\n\n서버 컴포넌트의 데이터를 가져오기 위해 API 라우트 핸들러를 사용하는 것을 피하십시오. 대신 서버 컴포넌트 내에서 데이터를 직접 가져오세요. 이 방법을 통해 Next.js가 여러 서버 컴포넌트 사이에서 데이터의 캐싱 및 재사용을 최적화할 수 있습니다.\n\n만약 여러 컴포넌트 사이에서 동일한 데이터 가져오기 로직을 재사용해야 한다면, `server/` 디렉토리에 서버 액션을 생성하는 것을 고려해보세요.\n\n\n\n```js\nexport async function getJoke() {\n  const res = await fetch(\"https://api.example.com/joke\");\n  const data = await res.json();\n  if (res.ok) {\n    return { success: true, joke: data.joke };\n  } else {\n    return { error: data.error };\n  }\n}\n// app/page.jsx\nimport { getJoke } from \"../server/actions\";\nexport default async function Page() {\n  const { success, joke, error } = await getJoke();\n  if (success) {\n    return \u003cdiv\u003e{joke}\u003c/div\u003e;\n  } else {\n    throw new Error(error);\n  }\n}\n```\n\n# Tip 5: 클라이언트 및 서버 구성 요소 이해하기\n\n기본적으로 Next.js의 페이지는 서버 구성 요소입니다. 서버 구성 요소 내에서 클라이언트 구성 요소를 렌더링하여 상호작용성을 추가할 수 있습니다.\n\n```js\n\"use client\";\nimport { useState } from \"react\";\nexport default function ClientComponent() {\n  const [count, setCount] = useState(0);\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003eCount: {count}\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n\n클라이언트 컴포넌트 내에 렌더링된 자식 컴포넌트는 '사용 클라이언트' 지시문이 필요 없이 자동으로 클라이언트 컴포넌트가 됩니다.\n\n프로바이더(예: 테마 제공자)를 사용할 때는 레이아웃에서 프로바이더로 자식 컴포넌트를 감싸면 자식 컴포넌트는 여전히 서버 컴포넌트로 렌더링됩니다.\n\n```js\n// app/layout.jsx\nimport { ThemeProvider } from \"your-theme-library\";\nexport default function RootLayout({ children }) {\n  return \u003cThemeProvider\u003e{children}\u003c/ThemeProvider\u003e;\n}\n```\n\n# 결론\n\n\n\nNext.js 14은 서버 렌더링된 React 애플리케이션의 개발을 최적화하는 강력하고 기능이 풍부한 프레임워크입니다. 새로운 개념과 규칙이 소개되었지만, 이 블로그 포스트에서 안내된 꿀팁과 요령을 따르면 혼동과 모호함이 발생할 수 있는 부분을 잘 헤쳐나갈 수 있을 거예요.\n\n이미지 사용 방법, 환경 변수 처리, 캐싱 관리, 서버 컴포넌트에서 데이터 가져오기, 그리고 클라이언트 및 서버 컴포넌트 간의 차이 등을 이해하면 Next.js 14로 튼튼하고 효율적인 애플리케이션을 개발하는 데 능숙해질 거예요.\n\n기술을 마스터하는 데 있어서 연습과 경험은 중요합니다. Next.js 문서를 탐험하고 커뮤니티 포럼에 참여하며 프레임워크의 기능을 실험해보면 보다 깊이 있는 이해를 다질 수 있을 거예요.","ogImage":{"url":"/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_0.png"},"coverImage":"/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_0.png","tag":["Tech"],"readingTime":4}],"page":"118","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"118"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>